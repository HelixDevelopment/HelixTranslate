
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cli: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">digital.vasic.translator/cmd/cli/main.go (0.0%)</option>
				
				<option value="file1">digital.vasic.translator/cmd/deployment/main.go (0.0%)</option>
				
				<option value="file2">digital.vasic.translator/cmd/markdown-translator/main.go (0.0%)</option>
				
				<option value="file3">digital.vasic.translator/cmd/preparation-translator/main.go (0.0%)</option>
				
				<option value="file4">digital.vasic.translator/cmd/server/main.go (0.0%)</option>
				
				<option value="file5">digital.vasic.translator/internal/cache/cache.go (98.1%)</option>
				
				<option value="file6">digital.vasic.translator/internal/config/config.go (54.8%)</option>
				
				<option value="file7">digital.vasic.translator/pkg/api/batch_handlers.go (47.5%)</option>
				
				<option value="file8">digital.vasic.translator/pkg/api/handler.go (20.2%)</option>
				
				<option value="file9">digital.vasic.translator/pkg/batch/processor.go (77.2%)</option>
				
				<option value="file10">digital.vasic.translator/pkg/coordination/multi_llm.go (52.5%)</option>
				
				<option value="file11">digital.vasic.translator/pkg/coordination/translator_wrapper.go (66.7%)</option>
				
				<option value="file12">digital.vasic.translator/pkg/deployment/api_logger.go (64.8%)</option>
				
				<option value="file13">digital.vasic.translator/pkg/deployment/docker_orchestrator.go (0.0%)</option>
				
				<option value="file14">digital.vasic.translator/pkg/deployment/network_discovery.go (66.1%)</option>
				
				<option value="file15">digital.vasic.translator/pkg/deployment/orchestrator.go (19.6%)</option>
				
				<option value="file16">digital.vasic.translator/pkg/deployment/ssh_deployer.go (1.0%)</option>
				
				<option value="file17">digital.vasic.translator/pkg/events/events.go (100.0%)</option>
				
				<option value="file18">digital.vasic.translator/pkg/fb2/parser.go (88.9%)</option>
				
				<option value="file19">digital.vasic.translator/pkg/format/detector.go (73.4%)</option>
				
				<option value="file20">digital.vasic.translator/pkg/hardware/detector.go (41.0%)</option>
				
				<option value="file21">digital.vasic.translator/pkg/language/detector.go (83.7%)</option>
				
				<option value="file22">digital.vasic.translator/pkg/language/llm_detector.go (28.8%)</option>
				
				<option value="file23">digital.vasic.translator/pkg/markdown/epub_to_markdown.go (66.0%)</option>
				
				<option value="file24">digital.vasic.translator/pkg/markdown/markdown_to_epub.go (63.8%)</option>
				
				<option value="file25">digital.vasic.translator/pkg/markdown/translator.go (73.3%)</option>
				
				<option value="file26">digital.vasic.translator/pkg/models/downloader.go (78.5%)</option>
				
				<option value="file27">digital.vasic.translator/pkg/models/registry.go (84.3%)</option>
				
				<option value="file28">digital.vasic.translator/pkg/progress/tracker.go (100.0%)</option>
				
				<option value="file29">digital.vasic.translator/pkg/script/converter.go (100.0%)</option>
				
				<option value="file30">digital.vasic.translator/pkg/security/auth.go (93.3%)</option>
				
				<option value="file31">digital.vasic.translator/pkg/security/ratelimit.go (83.3%)</option>
				
				<option value="file32">digital.vasic.translator/pkg/storage/postgres.go (0.0%)</option>
				
				<option value="file33">digital.vasic.translator/pkg/storage/redis.go (4.8%)</option>
				
				<option value="file34">digital.vasic.translator/pkg/storage/sqlite.go (84.8%)</option>
				
				<option value="file35">digital.vasic.translator/pkg/translator/llm/anthropic.go (0.0%)</option>
				
				<option value="file36">digital.vasic.translator/pkg/translator/llm/deepseek.go (0.0%)</option>
				
				<option value="file37">digital.vasic.translator/pkg/translator/llm/gemini.go (0.0%)</option>
				
				<option value="file38">digital.vasic.translator/pkg/translator/llm/llamacpp.go (35.6%)</option>
				
				<option value="file39">digital.vasic.translator/pkg/translator/llm/llm.go (46.8%)</option>
				
				<option value="file40">digital.vasic.translator/pkg/translator/llm/ollama.go (0.0%)</option>
				
				<option value="file41">digital.vasic.translator/pkg/translator/llm/openai.go (0.0%)</option>
				
				<option value="file42">digital.vasic.translator/pkg/translator/llm/qwen.go (0.0%)</option>
				
				<option value="file43">digital.vasic.translator/pkg/translator/llm/zhipu.go (0.0%)</option>
				
				<option value="file44">digital.vasic.translator/pkg/translator/translator.go (4.5%)</option>
				
				<option value="file45">digital.vasic.translator/pkg/translator/universal.go (0.0%)</option>
				
				<option value="file46">digital.vasic.translator/pkg/verification/database.go (0.0%)</option>
				
				<option value="file47">digital.vasic.translator/pkg/verification/multipass.go (0.0%)</option>
				
				<option value="file48">digital.vasic.translator/pkg/verification/notes.go (37.5%)</option>
				
				<option value="file49">digital.vasic.translator/pkg/verification/polisher.go (48.5%)</option>
				
				<option value="file50">digital.vasic.translator/pkg/verification/reporter.go (0.0%)</option>
				
				<option value="file51">digital.vasic.translator/pkg/verification/verifier.go (0.0%)</option>
				
				<option value="file52">digital.vasic.translator/pkg/websocket/hub.go (51.7%)</option>
				
				<option value="file53">digital.vasic.translator/test/markdown_e2e.go (0.0%)</option>
				
				<option value="file54">digital.vasic.translator/test/security/mock_translator.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "digital.vasic.translator/internal/config"
        "digital.vasic.translator/pkg/coordination"
        "digital.vasic.translator/pkg/ebook"
        "digital.vasic.translator/pkg/events"
        "digital.vasic.translator/pkg/format"
        "digital.vasic.translator/pkg/language"
        "digital.vasic.translator/pkg/script"
        "digital.vasic.translator/pkg/translator"
        "digital.vasic.translator/pkg/translator/llm"
        "flag"
        "fmt"
        "os"
        "path/filepath"
        "strings"
)

const version = "2.0.0"

func main() <span class="cov0" title="0">{
        // Define CLI flags
        var (
                inputFile         string
                outputFile        string
                outputFormat      string
                provider          string
                model             string
                apiKey            string
                baseURL           string
                scriptType        string
                locale            string
                targetLanguage    string
                sourceLanguage    string
                configFile        string
                showVersion       bool
                showHelp          bool
                createConfig      string
                detectLang        bool
                disableLocalLLMs  bool
                preferDistributed bool
        )

        flag.StringVar(&amp;inputFile, "input", "", "Input ebook file (any format: FB2, EPUB, TXT, HTML)")
        flag.StringVar(&amp;inputFile, "i", "", "Input ebook file (shorthand)")
        flag.StringVar(&amp;outputFile, "output", "", "Output file")
        flag.StringVar(&amp;outputFile, "o", "", "Output file (shorthand)")
        flag.StringVar(&amp;outputFormat, "format", "epub", "Output format (epub, fb2, txt)")
        flag.StringVar(&amp;outputFormat, "f", "epub", "Output format (shorthand)")
        flag.StringVar(&amp;provider, "provider", "openai", "Translation provider")
        flag.StringVar(&amp;provider, "p", "openai", "Translation provider (shorthand)")
        flag.StringVar(&amp;model, "model", "", "LLM model name")
        flag.StringVar(&amp;apiKey, "api-key", "", "API key for LLM provider")
        flag.StringVar(&amp;baseURL, "base-url", "", "Base URL for LLM provider")
        flag.StringVar(&amp;scriptType, "script", "default", "Output script (default, cyrillic, latin, arabic, etc.)")
        flag.StringVar(&amp;locale, "locale", "", "Target language locale (e.g., sr, de, DE)")
        flag.StringVar(&amp;targetLanguage, "language", "", "Target language name (e.g., English, Spanish, French)")
        flag.StringVar(&amp;sourceLanguage, "source", "", "Source language (optional, auto-detected if not specified)")
        flag.BoolVar(&amp;detectLang, "detect", false, "Detect source language and exit")
        flag.BoolVar(&amp;showVersion, "version", false, "Show version")
        flag.BoolVar(&amp;showVersion, "v", false, "Show version (shorthand)")
        flag.BoolVar(&amp;showHelp, "help", false, "Show help")
        flag.BoolVar(&amp;showHelp, "h", false, "Show help (shorthand)")
        flag.StringVar(&amp;createConfig, "create-config", "", "Create config file template")
        flag.BoolVar(&amp;disableLocalLLMs, "disable-local-llms", false, "Disable local LLM providers, use only distributed workers")
        flag.BoolVar(&amp;preferDistributed, "prefer-distributed", false, "Prefer distributed workers over local LLMs when available")
        flag.StringVar(&amp;configFile, "config", "", "Configuration file path")
        flag.StringVar(&amp;configFile, "c", "", "Configuration file path (shorthand)")

        flag.Parse()

        // Handle version
        if showVersion </span><span class="cov0" title="0">{
                fmt.Printf("Universal Ebook Translator v%s\n", version)
                os.Exit(0)
        }</span>

        // Handle help
        <span class="cov0" title="0">if showHelp || (inputFile == "" &amp;&amp; createConfig == "") </span><span class="cov0" title="0">{
                printHelp()
                os.Exit(0)
        }</span>

        // Handle config creation
        <span class="cov0" title="0">if createConfig != "" </span><span class="cov0" title="0">{
                if err := createConfigFile(createConfig); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error creating config: %v\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">fmt.Printf("Config file created: %s\n", createConfig)
                os.Exit(0)</span>
        }

        // Parse target language from locale or language flag
        <span class="cov0" title="0">var targetLang language.Language
        var err error

        if locale != "" </span><span class="cov0" title="0">{
                targetLang, err = language.ParseLanguage(locale)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Invalid locale '%s': %v\n", locale, err)
                        fmt.Fprintf(os.Stderr, "Supported languages: %s\n", getSupportedLanguagesString())
                        os.Exit(1)
                }</span>
        } else<span class="cov0" title="0"> if targetLanguage != "" </span><span class="cov0" title="0">{
                targetLang, err = language.ParseLanguage(targetLanguage)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Invalid language '%s': %v\n", targetLanguage, err)
                        fmt.Fprintf(os.Stderr, "Supported languages: %s\n", getSupportedLanguagesString())
                        os.Exit(1)
                }</span>
        } else<span class="cov0" title="0"> {
                // Default to English (widely used target language)
                targetLang = language.English
        }</span>

        // Parse source language if specified
        <span class="cov0" title="0">var sourceLang language.Language
        if sourceLanguage != "" </span><span class="cov0" title="0">{
                sourceLang, err = language.ParseLanguage(sourceLanguage)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Invalid source language '%s': %v\n", sourceLanguage, err)
                        os.Exit(1)
                }</span>
        }

        // Load API key from environment if not provided
        <span class="cov0" title="0">if apiKey == "" </span><span class="cov0" title="0">{
                apiKey = getAPIKeyFromEnv(provider)
        }</span>

        // Load configuration if specified
        <span class="cov0" title="0">var appConfig *config.Config
        if configFile != "" </span><span class="cov0" title="0">{
                var err error
                appConfig, err = config.LoadConfig(configFile)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Failed to load configuration: %v\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">fmt.Printf("Loaded configuration from: %s\n", configFile)</span>
        }

        // Create event bus
        <span class="cov0" title="0">eventBus := events.NewEventBus()

        // Subscribe to events for CLI output
        eventBus.SubscribeAll(func(event events.Event) </span><span class="cov0" title="0">{
                fmt.Printf("[%s] %s\n", event.Type, event.Message)
        }</span>)

        // Parse input file
        <span class="cov0" title="0">fmt.Printf("Universal Ebook Translator v%s\n\n", version)
        fmt.Printf("Input file: %s\n", inputFile)

        parser := ebook.NewUniversalParser()
        book, err := parser.Parse(inputFile)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Failed to parse ebook: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Detected format: %s\n", book.Format)
        fmt.Printf("Title: %s\n", book.Metadata.Title)
        fmt.Printf("Chapters: %d\n", book.GetChapterCount())

        // Detect language if requested
        if detectLang </span><span class="cov0" title="0">{
                langDetector := language.NewDetector(nil)
                sample := book.ExtractText()
                if len(sample) &gt; 2000 </span><span class="cov0" title="0">{
                        sample = sample[:2000]
                }</span>

                <span class="cov0" title="0">detectedLang, err := langDetector.Detect(context.Background(), sample)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Language detection failed: %v\n", err)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">fmt.Printf("\nDetected language: %s (%s)\n", detectedLang.Name, detectedLang.Code)
                os.Exit(0)</span>
        }

        <span class="cov0" title="0">fmt.Printf("Target language: %s (%s)\n", targetLang.Name, targetLang.Code)

        // Generate output filename if not provided
        if outputFile == "" </span><span class="cov0" title="0">{
                outputFile = generateOutputFilename(inputFile, targetLang.Code, outputFormat)
        }</span>

        // Run translation
        <span class="cov0" title="0">if err := translateEbook(
                book,
                outputFile,
                outputFormat,
                provider,
                model,
                apiKey,
                baseURL,
                scriptType,
                appConfig,
                sourceLang,
                targetLang,
                eventBus,
                disableLocalLLMs,
                preferDistributed,
        ); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Translation failed: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Printf("\n‚úì Translation completed successfully!\n")
        fmt.Printf("Output file: %s\n", outputFile)
        fmt.Printf("Output format: %s\n", outputFormat)</span>
}

func translateEbook(
        book *ebook.Book,
        outputFile, outputFormat, providerName, model, apiKey, baseURL, scriptType string,
        appConfig *config.Config,
        sourceLang, targetLang language.Language,
        eventBus *events.EventBus,
        disableLocalLLMs, preferDistributed bool,
) error <span class="cov0" title="0">{
        ctx := context.Background()

        // Load configuration if specified
        if appConfig != nil </span><span class="cov0" title="0">{
                fmt.Printf("Using loaded configuration\n")

                // Override CLI parameters with config values if not explicitly set
                if providerName == "openai" &amp;&amp; appConfig.Translation.DefaultProvider != "" </span><span class="cov0" title="0">{
                        providerName = appConfig.Translation.DefaultProvider
                }</span>
                <span class="cov0" title="0">if model == "" &amp;&amp; appConfig.Translation.DefaultModel != "" </span><span class="cov0" title="0">{
                        model = appConfig.Translation.DefaultModel
                }</span>

                // Load provider-specific config
                <span class="cov0" title="0">if providerConfig, ok := appConfig.Translation.Providers[providerName]; ok </span><span class="cov0" title="0">{
                        if apiKey == "" &amp;&amp; providerConfig.APIKey != "" </span><span class="cov0" title="0">{
                                apiKey = providerConfig.APIKey
                        }</span>
                        <span class="cov0" title="0">if baseURL == "" &amp;&amp; providerConfig.BaseURL != "" </span><span class="cov0" title="0">{
                                baseURL = providerConfig.BaseURL
                        }</span>
                        <span class="cov0" title="0">if model == "" &amp;&amp; providerConfig.Model != "" </span><span class="cov0" title="0">{
                                model = providerConfig.Model
                        }</span>
                }
        }

        // Create translator
        <span class="cov0" title="0">config := translator.TranslationConfig{
                SourceLang: sourceLang.Code,
                TargetLang: targetLang.Code,
                Provider:   providerName,
                Model:      model,
                APIKey:     apiKey,
                BaseURL:    baseURL,
                Options:    make(map[string]interface{}),
        }

        var trans translator.Translator
        var err error
        sessionID := "cli-session"

        // Try multi-LLM first if provider is "multi-llm", "distributed" or not specified
        if providerName == "multi-llm" || providerName == "distributed" || providerName == "" </span><span class="cov0" title="0">{
                // For distributed provider, prefer distributed workers if enabled
                if providerName == "distributed" &amp;&amp; appConfig != nil &amp;&amp; appConfig.Distributed.Enabled </span><span class="cov0" title="0">{
                        preferDistributed = true
                        fmt.Printf("Distributed translation enabled, preferring remote workers\n")
                }</span>

                <span class="cov0" title="0">multiTrans, multiErr := coordination.NewMultiLLMTranslatorWrapperWithConfig(config, eventBus, sessionID, disableLocalLLMs, preferDistributed)
                if multiErr == nil </span><span class="cov0" title="0">{
                        trans = multiTrans
                        fmt.Printf("Using translator: multi-llm-coordinator (%d instances)\n\n", multiTrans.Coordinator.GetInstanceCount())
                }</span> else<span class="cov0" title="0"> if providerName == "multi-llm" || providerName == "distributed" </span><span class="cov0" title="0">{
                        // User explicitly requested multi-llm or distributed but it failed
                        return fmt.Errorf("failed to create multi-LLM translator: %w", multiErr)
                }</span>
                // Otherwise fall through to single translator
        }

        // Fall back to single translator
        <span class="cov0" title="0">if trans == nil </span><span class="cov0" title="0">{
                trans, err = llm.NewLLMTranslator(config)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create translator: %w", err)
                }</span>
                <span class="cov0" title="0">fmt.Printf("Using translator: %s\n\n", trans.GetName())</span>
        }

        // Create language detector with LLM support if API key available
        <span class="cov0" title="0">var llmDetector language.LLMDetector
        if apiKey != "" </span><span class="cov0" title="0">{
                llmDetector = language.NewSimpleLLMDetector(providerName, apiKey)
        }</span>
        <span class="cov0" title="0">langDetector := language.NewDetector(llmDetector)

        // Create universal translator
        universalTrans := translator.NewUniversalTranslator(
                trans,
                langDetector,
                sourceLang,
                targetLang,
        )

        // Translate the book
        if err := universalTrans.TranslateBook(ctx, book, eventBus, sessionID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("translation failed: %w", err)
        }</span>

        // Convert script if needed
        <span class="cov0" title="0">if scriptType == "latin" &amp;&amp; targetLang.Code == "sr" </span><span class="cov0" title="0">{
                fmt.Printf("Converting to Latin script...\n")
                converter := script.NewConverter()
                convertBookToLatin(book, converter)
        }</span>

        // Write output in requested format
        <span class="cov0" title="0">fmt.Printf("Writing output file...\n")
        outFormat := format.ParseFormat(outputFormat)

        switch outFormat </span>{
        case format.FormatEPUB:<span class="cov0" title="0">
                writer := ebook.NewEPUBWriter()
                if err := writer.Write(book, outputFile); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write EPUB: %w", err)
                }</span>

        case format.FormatFB2:<span class="cov0" title="0">
                // Convert to FB2 and write
                // For now, we'll use EPUB as primary format
                return fmt.Errorf("FB2 output format not yet implemented")</span>

        case format.FormatTXT:<span class="cov0" title="0">
                // Write as plain text
                if err := writeAsText(book, outputFile); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write TXT: %w", err)
                }</span>

        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported output format: %s", outputFormat)</span>
        }

        // Print statistics
        <span class="cov0" title="0">stats := trans.GetStats()
        fmt.Printf("\nTranslation Statistics:\n")
        fmt.Printf("  Total: %d\n", stats.Total)
        fmt.Printf("  Translated: %d\n", stats.Translated)
        fmt.Printf("  Cached: %d\n", stats.Cached)
        fmt.Printf("  Errors: %d\n", stats.Errors)

        return nil</span>
}

func convertBookToLatin(book *ebook.Book, converter *script.Converter) <span class="cov0" title="0">{
        // Convert metadata
        book.Metadata.Title = converter.ToLatin(book.Metadata.Title)
        book.Metadata.Description = converter.ToLatin(book.Metadata.Description)

        for i := range book.Metadata.Authors </span><span class="cov0" title="0">{
                book.Metadata.Authors[i] = converter.ToLatin(book.Metadata.Authors[i])
        }</span>

        // Convert chapters
        <span class="cov0" title="0">for i := range book.Chapters </span><span class="cov0" title="0">{
                convertChapterToLatin(&amp;book.Chapters[i], converter)
        }</span>
}

func convertChapterToLatin(chapter *ebook.Chapter, converter *script.Converter) <span class="cov0" title="0">{
        chapter.Title = converter.ToLatin(chapter.Title)

        for i := range chapter.Sections </span><span class="cov0" title="0">{
                convertSectionToLatin(&amp;chapter.Sections[i], converter)
        }</span>
}

func convertSectionToLatin(section *ebook.Section, converter *script.Converter) <span class="cov0" title="0">{
        section.Title = converter.ToLatin(section.Title)
        section.Content = converter.ToLatin(section.Content)

        for i := range section.Subsections </span><span class="cov0" title="0">{
                convertSectionToLatin(&amp;section.Subsections[i], converter)
        }</span>
}

func writeAsText(book *ebook.Book, filename string) error <span class="cov0" title="0">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        text := book.ExtractText()
        _, err = file.WriteString(text)
        return err</span>
}

func getAPIKeyFromEnv(provider string) string <span class="cov0" title="0">{
        envMappings := map[string]string{
                "openai":    "OPENAI_API_KEY",
                "anthropic": "ANTHROPIC_API_KEY",
                "zhipu":     "ZHIPU_API_KEY",
                "deepseek":  "DEEPSEEK_API_KEY",
                "qwen":      "QWEN_API_KEY",
        }

        if envVar, ok := envMappings[provider]; ok </span><span class="cov0" title="0">{
                return os.Getenv(envVar)
        }</span>

        <span class="cov0" title="0">return ""</span>
}

func generateOutputFilename(inputFile, targetLang, outputFormat string) string <span class="cov0" title="0">{
        ext := filepath.Ext(inputFile)
        base := strings.TrimSuffix(inputFile, ext)

        // Add target language
        outputExt := "." + outputFormat
        return fmt.Sprintf("%s_%s%s", base, targetLang, outputExt)
}</span>

func createConfigFile(filename string) error <span class="cov0" title="0">{
        config := `{
  "provider": "openai",
  "model": "gpt-4",
  "temperature": 0.3,
  "max_tokens": 4000,
  "target_language": "sr",
  "output_format": "epub",
  "script": "cyrillic"
}
`
        return os.WriteFile(filename, []byte(config), 0644)
}</span>

func getSupportedLanguagesString() string <span class="cov0" title="0">{
        langs := language.GetSupportedLanguages()
        var names []string
        for _, lang := range langs </span><span class="cov0" title="0">{
                names = append(names, fmt.Sprintf("%s (%s)", lang.Name, lang.Code))
        }</span>
        <span class="cov0" title="0">return strings.Join(names, ", ")</span>
}

func printHelp() <span class="cov0" title="0">{
        fmt.Printf(`Universal Ebook Translator v%s

Translate ebooks between any languages with support for multiple formats.

Usage:
  translator [options] -input &lt;file&gt;

Options:
  -i, -input &lt;file&gt;       Input ebook file (any format: FB2, EPUB, TXT, HTML)
  -o, -output &lt;file&gt;      Output file (auto-generated if not specified)
  -f, -format &lt;format&gt;    Output format (epub, fb2, txt) [default: epub]

  -locale &lt;code&gt;          Target language locale (e.g., sr, de, fr, es)
  -language &lt;name&gt;        Target language name (e.g., English, Spanish, French)
                          (case-insensitive, default: English)
  -source &lt;lang&gt;          Source language (optional, auto-detected)
  -detect                 Detect source language and exit

  -p, -provider &lt;name&gt;    Translation provider (openai, anthropic,
                          zhipu, deepseek, qwen, ollama, llamacpp) [default: openai]
  -model &lt;name&gt;           LLM model name (e.g., gpt-4, claude-3-sonnet)
  -api-key &lt;key&gt;          API key for LLM provider
  -base-url &lt;url&gt;         Base URL for LLM provider

  -script &lt;type&gt;          Output script (default, cyrillic, latin, arabic, etc.)
                          [default: default]

   -c, -config &lt;file&gt;      Configuration file path
   -create-config &lt;file&gt;   Create a config file template
   -disable-local-llms     Disable local LLM providers (Ollama), use only API providers
   -prefer-distributed     Prefer distributed workers over local LLMs (when available)
   -v, -version            Show version
   -h, -help               Show this help

Supported Input Formats:
  FB2, EPUB, TXT, HTML

Supported Output Formats:
  EPUB (default), TXT

Supported Languages:
  %s

Environment Variables:
  OPENAI_API_KEY          OpenAI API key
  ANTHROPIC_API_KEY       Anthropic API key
  ZHIPU_API_KEY           Zhipu AI API key
  DEEPSEEK_API_KEY        DeepSeek API key
  QWEN_API_KEY            Qwen (Alibaba Cloud) API key

Examples:
  # Translate any ebook to Serbian (auto-detect source language)
  translator -input book.epub

  # Translate to German
  translator -input book.fb2 -locale de
  translator -input book.epub -language German

  # Translate Russian to French with OpenAI
  export OPENAI_API_KEY="your-key"
  translator -input book_ru.epub -locale fr -provider openai -model gpt-4

  # Detect language only
  translator -input mystery_book.epub -detect

  # Latin script output (for Serbian)
  translator -input book.fb2 -script latin

  # Output as plain text
  translator -input book.epub -locale de -format txt

  # Local Ollama translation
  translator -input book.txt -locale es -provider ollama -model llama3:8b

`, version, getSupportedLanguagesString())
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "encoding/json"
        "flag"
        "fmt"
        "log"
        "os"
        "time"

        "digital.vasic.translator/internal/config"
        "digital.vasic.translator/pkg/deployment"
        "digital.vasic.translator/pkg/events"
)

func main() <span class="cov0" title="0">{
        var (
                configFile = flag.String("config", "config.distributed.json", "Configuration file")
                action     = flag.String("action", "deploy", "Action: deploy, status, stop, cleanup, update, restart, generate-plan")
                service    = flag.String("service", "", "Service name for update/restart actions")
                image      = flag.String("image", "", "New image for update action")
                planFile   = flag.String("plan", "", "Deployment plan JSON file")
                verbose    = flag.Bool("verbose", false, "Enable verbose logging")
        )
        flag.Parse()

        // Load configuration
        cfg, err := config.LoadConfig(*configFile)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load config: %v", err)
        }</span>

        // Setup logging
        <span class="cov0" title="0">if *verbose </span><span class="cov0" title="0">{
                log.SetFlags(log.LstdFlags | log.Lshortfile)
        }</span>

        // Create event bus
        <span class="cov0" title="0">eventBus := events.NewEventBus()

        // Create deployment orchestrator
        orchestrator := deployment.NewDeploymentOrchestrator(cfg, eventBus)
        defer orchestrator.Close()

        // Handle actions
        switch *action </span>{
        case "deploy":<span class="cov0" title="0">
                if *planFile == "" </span><span class="cov0" title="0">{
                        log.Fatal("Deployment plan file is required for deploy action")
                }</span>
                <span class="cov0" title="0">handleDeploy(orchestrator, *planFile)</span>

        case "status":<span class="cov0" title="0">
                handleStatus(orchestrator)</span>

        case "stop":<span class="cov0" title="0">
                handleStop(orchestrator)</span>

        case "cleanup":<span class="cov0" title="0">
                handleCleanup(orchestrator)</span>

        case "update":<span class="cov0" title="0">
                handleUpdate(orchestrator, *service, *image)</span>

        case "restart":<span class="cov0" title="0">
                handleRestart(orchestrator, *service)</span>

        case "generate-plan":<span class="cov0" title="0">
                handleGeneratePlan(cfg)</span>

        default:<span class="cov0" title="0">
                log.Fatalf("Unknown action: %s", *action)</span>
        }
}

func handleDeploy(orchestrator *deployment.DeploymentOrchestrator, planFile string) <span class="cov0" title="0">{
        log.Println("Starting deployment...")

        // Load deployment plan
        plan, err := loadDeploymentPlan(planFile)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load deployment plan: %v", err)
        }</span>

        // Execute deployment
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 30*time.Minute)
        defer cancel()

        if err := orchestrator.DeployDistributedSystem(ctx, plan); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Deployment failed: %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("Deployment completed successfully!")</span>
}

func handleStatus(orchestrator *deployment.DeploymentOrchestrator) <span class="cov0" title="0">{
        instances := orchestrator.GetDeployedInstances()

        fmt.Println("=== Deployment Status ===")
        fmt.Printf("Total instances: %d\n\n", len(instances))

        for id, instance := range instances </span><span class="cov0" title="0">{
                fmt.Printf("Instance: %s\n", id)
                fmt.Printf("  Host: %s:%d\n", instance.Host, instance.Port)
                fmt.Printf("  Container ID: %s\n", instance.ContainerID[:12])
                fmt.Printf("  Status: %s\n", instance.Status)
                fmt.Printf("  Last Seen: %s\n", instance.LastSeen.Format(time.RFC3339))
                fmt.Println()
        }</span>
}

func handleStop(orchestrator *deployment.DeploymentOrchestrator) <span class="cov0" title="0">{
        log.Println("Stopping deployment...")

        // For now, this would need to be implemented in the orchestrator
        // orchestrator.StopDeployment(context.Background())

        log.Println("Deployment stopped")
}</span>

func handleCleanup(orchestrator *deployment.DeploymentOrchestrator) <span class="cov0" title="0">{
        log.Println("Cleaning up deployment...")

        // Cleanup would be implemented in orchestrator
        // orchestrator.Cleanup()

        log.Println("Cleanup completed")
}</span>

func handleUpdate(orchestrator *deployment.DeploymentOrchestrator, service, image string) <span class="cov0" title="0">{
        if service == "" </span><span class="cov0" title="0">{
                log.Fatal("Service name is required for update action")
        }</span>

        <span class="cov0" title="0">log.Printf("Updating service %s...", service)

        ctx, cancel := context.WithTimeout(context.Background(), 15*time.Minute)
        defer cancel()

        if image != "" </span><span class="cov0" title="0">{
                // Update specific service to new image
                if err := orchestrator.UpdateService(ctx, service, image); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Update failed: %v", err)
                }</span>
        } else<span class="cov0" title="0"> {
                // Update all services
                if err := orchestrator.UpdateAllServices(ctx); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Update failed: %v", err)
                }</span>
        }

        <span class="cov0" title="0">log.Println("Update completed successfully!")</span>
}

func handleRestart(orchestrator *deployment.DeploymentOrchestrator, service string) <span class="cov0" title="0">{
        log.Printf("Restarting service %s...", service)

        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Minute)
        defer cancel()

        if service != "" </span><span class="cov0" title="0">{
                // Restart specific service
                if err := orchestrator.RestartService(ctx, service); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Restart failed: %v", err)
                }</span>
        } else<span class="cov0" title="0"> {
                // Restart all services
                if err := orchestrator.RestartAllServices(ctx); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Restart failed: %v", err)
                }</span>
        }

        <span class="cov0" title="0">log.Println("Restart completed successfully!")</span>
}

func handleGeneratePlan(cfg *config.Config) <span class="cov0" title="0">{
        log.Println("Generating deployment plan...")

        plan := generateDeploymentPlan(cfg)

        // Write plan to file
        data, err := json.MarshalIndent(plan, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to marshal plan: %v", err)
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile("deployment-plan.json", data, 0644); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to write plan file: %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("Deployment plan generated: deployment-plan.json")</span>
}

func loadDeploymentPlan(filename string) (*deployment.DeploymentPlan, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var plan deployment.DeploymentPlan
        if err := json.Unmarshal(data, &amp;plan); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;plan, nil</span>
}

func generateDeploymentPlan(cfg *config.Config) *deployment.DeploymentPlan <span class="cov0" title="0">{
        plan := &amp;deployment.DeploymentPlan{
                Workers: []*deployment.DeploymentConfig{},
        }

        // Add workers based on configuration
        workerIndex := 1
        for workerID, worker := range cfg.Distributed.Workers </span><span class="cov0" title="0">{
                workerConfig := &amp;deployment.DeploymentConfig{
                        Host:          worker.Host,
                        User:          worker.User,
                        Password:      worker.Password,
                        SSHKeyPath:    "",
                        DockerImage:   "translator:latest",
                        ContainerName: fmt.Sprintf("translator-worker-%s", workerID),
                        Ports: []deployment.PortMapping{
                                {HostPort: 8443 + workerIndex, ContainerPort: 8443, Protocol: "tcp"},
                        },
                        Environment: map[string]string{
                                "JWT_SECRET":   fmt.Sprintf("worker-%s-secret", workerID),
                                "WORKER_INDEX": fmt.Sprintf("%d", workerIndex),
                        },
                        Volumes: []deployment.VolumeMapping{
                                {HostPath: "./certs", ContainerPath: "/app/certs", ReadOnly: true},
                                {HostPath: "./config.worker.json", ContainerPath: "/app/config.json", ReadOnly: true},
                        },
                        Networks:      []string{"translator-network"},
                        RestartPolicy: "unless-stopped",
                        HealthCheck: &amp;deployment.HealthCheckConfig{
                                Test:     []string{"CMD", "curl", "-f", "https://localhost:8443/health"},
                                Interval: 30 * time.Second,
                                Timeout:  10 * time.Second,
                                Retries:  3,
                        },
                }
                plan.Workers = append(plan.Workers, workerConfig)
                workerIndex++
        }</span>

        <span class="cov0" title="0">return plan</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "context"
        "digital.vasic.translator/pkg/ebook"
        "digital.vasic.translator/pkg/markdown"
        "digital.vasic.translator/pkg/preparation"
        "digital.vasic.translator/pkg/translator"
        "digital.vasic.translator/pkg/translator/llm"
        "encoding/json"
        "flag"
        "fmt"
        "log"
        "os"
        "path/filepath"
        "strings"
)

func main() <span class="cov0" title="0">{
        // Command line flags
        inputFile := flag.String("input", "", "Input file (EPUB or Markdown)")
        outputFile := flag.String("output", "", "Output file (optional, auto-generated if not provided)")
        outputFormat := flag.String("format", "epub", "Output format (epub, md)")
        targetLang := flag.String("lang", "en", "Target language code (default: English)")
        provider := flag.String("provider", "deepseek", "LLM provider (deepseek, openai, anthropic, llamacpp)")
        model := flag.String("model", "", "LLM model (optional, uses provider default)")
        keepMarkdown := flag.Bool("keep-md", true, "Keep intermediate markdown files")
        enablePreparation := flag.Bool("prepare", false, "Enable preparation phase with multi-LLM analysis")
        preparationPasses := flag.Int("prep-passes", 2, "Number of preparation analysis passes")
        flag.Parse()

        if *inputFile == "" </span><span class="cov0" title="0">{
                fmt.Println("Usage: markdown-translator -input &lt;file&gt; [-output &lt;output_file&gt;] [-format &lt;format&gt;] [-lang &lt;language&gt;] [-provider &lt;provider&gt;] [-keep-md]")
                fmt.Println("\nSupported input formats: EPUB (.epub), Markdown (.md)")
                fmt.Println("Supported output formats: EPUB (epub), Markdown (md)")
                flag.PrintDefaults()
                os.Exit(1)
        }</span>

        // Validate input file
        <span class="cov0" title="0">if _, err := os.Stat(*inputFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                log.Fatalf("Input file does not exist: %s", *inputFile)
        }</span>

        // Detect input file type
        <span class="cov0" title="0">inputExt := strings.ToLower(filepath.Ext(*inputFile))
        isMarkdownInput := (inputExt == ".md" || inputExt == ".markdown")

        // Generate output filename if not provided
        if *outputFile == "" </span><span class="cov0" title="0">{
                base := strings.TrimSuffix(filepath.Base(*inputFile), filepath.Ext(*inputFile))
                outputExt := "epub"
                if *outputFormat == "md" </span><span class="cov0" title="0">{
                        outputExt = "md"
                }</span>
                <span class="cov0" title="0">*outputFile = fmt.Sprintf("Books/%s_%s.%s", base, *targetLang, outputExt)</span>
        }

        // Generate intermediate markdown filenames (save to Books directory)
        <span class="cov0" title="0">outputBase := strings.TrimSuffix(filepath.Base(*outputFile), filepath.Ext(*outputFile))
        sourceMD := filepath.Join("Books", outputBase+"_source.md")
        translatedMD := filepath.Join("Books", outputBase+"_translated.md")

        // If input is already markdown, use it directly as source
        if isMarkdownInput </span><span class="cov0" title="0">{
                sourceMD = *inputFile
        }</span>

        // Ensure Books directory exists
        <span class="cov0" title="0">if err := os.MkdirAll("Books", 0755); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create Books directory: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("üöÄ Markdown-Based Translation Pipeline\n\n")
        fmt.Printf("Input:  %s (format: %s)\n", *inputFile, inputExt)
        fmt.Printf("Output: %s (format: %s)\n\n", *outputFile, *outputFormat)

        var stepNum int = 1
        totalSteps := 4
        if *enablePreparation </span><span class="cov0" title="0">{
                totalSteps++ // Add preparation step
        }</span>
        <span class="cov0" title="0">if isMarkdownInput </span><span class="cov0" title="0">{
                totalSteps-- // Skip EPUB‚ÜíMD conversion
        }</span>
        <span class="cov0" title="0">if *outputFormat == "md" </span><span class="cov0" title="0">{
                totalSteps-- // Skip MD‚ÜíEPUB conversion
        }</span>

        // Step 1: EPUB ‚Üí Markdown (skip if input is already markdown)
        <span class="cov0" title="0">if !isMarkdownInput </span><span class="cov0" title="0">{
                fmt.Printf("üìñ Step %d/%d: Converting EPUB to Markdown...\n", stepNum, totalSteps)
                converter := markdown.NewEPUBToMarkdownConverter(false, "")
                if err := converter.ConvertEPUBToMarkdown(*inputFile, sourceMD); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to convert EPUB to Markdown: %v", err)
                }</span>
                <span class="cov0" title="0">fmt.Printf("‚úì Source markdown saved: %s\n\n", sourceMD)
                stepNum++</span>
        } else<span class="cov0" title="0"> {
                fmt.Printf("‚ÑπÔ∏è  Using markdown input directly: %s\n\n", sourceMD)
        }</span>

        // Step 1.5: Preparation Phase (if enabled)
        <span class="cov0" title="0">var prepResult *preparation.PreparationResult
        if *enablePreparation </span><span class="cov0" title="0">{
                fmt.Printf("üîç Step %d/%d: Content Analysis &amp; Preparation...\n", stepNum, totalSteps)
                stepNum++

                // Parse the source book (either EPUB or reconstruct from markdown)
                var book *ebook.Book
                if !isMarkdownInput </span><span class="cov0" title="0">{
                        parser := ebook.NewUniversalParser()
                        var err error
                        book, err = parser.Parse(*inputFile)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatalf("Failed to parse book for preparation: %v", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Create minimal book structure from markdown for preparation
                        book = &amp;ebook.Book{
                                Metadata: ebook.Metadata{
                                        Language: "ru", // Assume Russian source
                                },
                                Chapters: []ebook.Chapter{
                                        {
                                                Title: "Content",
                                                // Would need to read markdown content here
                                        },
                                },
                        }
                }</span>

                // Configure preparation with multi-LLM analysis
                <span class="cov0" title="0">prepConfig := preparation.PreparationConfig{
                        PassCount:          *preparationPasses,
                        Providers:          []string{*provider}, // Use same provider for now
                        AnalyzeContentType: true,
                        AnalyzeCharacters:  true,
                        AnalyzeTerminology: true,
                        AnalyzeCulture:     true,
                        AnalyzeChapters:    true,
                        DetailLevel:        "comprehensive",
                        SourceLanguage:     "ru",
                        TargetLanguage:     *targetLang,
                }

                prepCoordinator, err := preparation.NewPreparationCoordinator(prepConfig)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to create preparation coordinator: %v", err)
                }</span>

                <span class="cov0" title="0">ctx := context.Background()
                prepResult, err = prepCoordinator.PrepareBook(ctx, book)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("‚ö†Ô∏è  Warning: Preparation failed: %v", err)
                        fmt.Println("Continuing without preparation analysis...")
                }</span> else<span class="cov0" title="0"> {
                        // Save preparation results
                        prepJSON := filepath.Join("Books", outputBase+"_preparation.json")
                        prepData, _ := json.MarshalIndent(prepResult, "", "  ")
                        if err := os.WriteFile(prepJSON, prepData, 0644); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Warning: Failed to save preparation results: %v", err)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("‚úì Preparation complete (%d passes, %.2fs)\n",
                                        prepResult.PassCount, prepResult.TotalDuration.Seconds())
                                fmt.Printf("  Analysis saved: %s\n", prepJSON)
                                fmt.Printf("  Content type: %s\n", prepResult.FinalAnalysis.ContentType)
                                fmt.Printf("  Genre: %s\n", prepResult.FinalAnalysis.Genre)
                                fmt.Printf("  Characters: %d identified\n", len(prepResult.FinalAnalysis.Characters))
                                fmt.Printf("  Untranslatable terms: %d identified\n", len(prepResult.FinalAnalysis.UntranslatableTerms))
                                fmt.Printf("  Footnote guidance: %d items\n", len(prepResult.FinalAnalysis.FootnoteGuidance))
                        }</span>
                }
                <span class="cov0" title="0">fmt.Println()</span>
        }

        // Step 2: Create translator
        <span class="cov0" title="0">fmt.Printf("üîß Step %d/%d: Initializing translator...\n", stepNum, totalSteps)
        llmTranslator, err := createTranslator(*provider, *model, *targetLang)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create translator: %v", err)
        }</span>
        <span class="cov0" title="0">fmt.Printf("‚úì Using provider: %s\n\n", *provider)
        stepNum++

        // Step 3: Translate Markdown
        fmt.Printf("üåç Step %d/%d: Translating markdown content...\n", stepNum, totalSteps)
        ctx := context.Background()
        mdTranslator := markdown.NewMarkdownTranslator(func(text string) (string, error) </span><span class="cov0" title="0">{
                return llmTranslator.Translate(ctx, text, "")
        }</span>)

        <span class="cov0" title="0">if err := mdTranslator.TranslateMarkdownFile(sourceMD, translatedMD); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to translate markdown: %v", err)
        }</span>
        <span class="cov0" title="0">fmt.Printf("‚úì Translated markdown saved: %s\n\n", translatedMD)
        stepNum++

        // Step 4: Markdown ‚Üí EPUB (skip if output format is markdown)
        if *outputFormat == "epub" </span><span class="cov0" title="0">{
                fmt.Printf("üìö Step %d/%d: Converting translated markdown to EPUB...\n", stepNum, totalSteps)
                epubConverter := markdown.NewMarkdownToEPUBConverter()
                if err := epubConverter.ConvertMarkdownToEPUB(translatedMD, *outputFile); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to convert markdown to EPUB: %v", err)
                }</span>
                <span class="cov0" title="0">fmt.Printf("‚úì Final EPUB created: %s\n\n", *outputFile)</span>
        } else<span class="cov0" title="0"> if *outputFormat == "md" </span><span class="cov0" title="0">{
                // Copy translated markdown to output file if different
                if translatedMD != *outputFile </span><span class="cov0" title="0">{
                        content, err := os.ReadFile(translatedMD)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatalf("Failed to read translated markdown: %v", err)
                        }</span>
                        <span class="cov0" title="0">if err := os.WriteFile(*outputFile, content, 0644); err != nil </span><span class="cov0" title="0">{
                                log.Fatalf("Failed to write output markdown: %v", err)
                        }</span>
                }
                <span class="cov0" title="0">fmt.Printf("‚úì Final markdown created: %s\n\n", *outputFile)</span>
        }

        // Cleanup markdown files if requested
        <span class="cov0" title="0">if !*keepMarkdown &amp;&amp; *outputFormat == "epub" </span><span class="cov0" title="0">{
                fmt.Println("üßπ Cleaning up intermediate files...")
                if !isMarkdownInput </span><span class="cov0" title="0">{
                        os.Remove(sourceMD)
                }</span>
                <span class="cov0" title="0">os.Remove(translatedMD)
                fmt.Println("‚úì Cleanup complete")</span>
        }

        <span class="cov0" title="0">fmt.Println("‚úÖ Translation complete!")
        fmt.Printf("\nFiles generated:\n")
        if *keepMarkdown || isMarkdownInput </span><span class="cov0" title="0">{
                if !isMarkdownInput </span><span class="cov0" title="0">{
                        fmt.Printf("  - Source MD:      %s\n", sourceMD)
                }</span>
                <span class="cov0" title="0">fmt.Printf("  - Translated MD:  %s\n", translatedMD)</span>
        }
        <span class="cov0" title="0">if *outputFormat == "epub" </span><span class="cov0" title="0">{
                fmt.Printf("  - Final EPUB:     %s\n", *outputFile)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("  - Final Markdown: %s\n", *outputFile)
        }</span>
}

// createTranslator creates an LLM translator based on provider
func createTranslator(provider, model, targetLang string) (translator.Translator, error) <span class="cov0" title="0">{
        // Get API keys from environment
        var apiKey string
        var defaultModel string

        switch provider </span>{
        case "deepseek":<span class="cov0" title="0">
                apiKey = os.Getenv("DEEPSEEK_API_KEY")
                defaultModel = "deepseek-chat"</span>
        case "openai":<span class="cov0" title="0">
                apiKey = os.Getenv("OPENAI_API_KEY")
                defaultModel = "gpt-4"</span>
        case "anthropic":<span class="cov0" title="0">
                apiKey = os.Getenv("ANTHROPIC_API_KEY")
                defaultModel = "claude-3-sonnet-20240229"</span>
        case "zhipu":<span class="cov0" title="0">
                apiKey = os.Getenv("ZHIPU_API_KEY")
                defaultModel = "glm-4"</span>
        case "llamacpp":<span class="cov0" title="0">
                // llamacpp doesn't need API key (local inference)
                apiKey = ""
                defaultModel = ""</span> // Auto-select based on hardware
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported provider: %s", provider)</span>
        }

        // Only require API key for cloud providers (not llamacpp)
        <span class="cov0" title="0">if apiKey == "" &amp;&amp; provider != "llamacpp" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API key not set for provider %s (check environment variables)", provider)
        }</span>

        // Use default model if not specified
        <span class="cov0" title="0">if model == "" </span><span class="cov0" title="0">{
                model = defaultModel
        }</span>

        // Create translator config
        <span class="cov0" title="0">config := translator.TranslationConfig{
                SourceLang: "",
                TargetLang: targetLang,
                Provider:   provider,
                Model:      model,
                APIKey:     apiKey,
        }

        // Create LLM translator (it handles all providers internally)
        return llm.NewLLMTranslator(config)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "context"
        "digital.vasic.translator/pkg/ebook"
        "digital.vasic.translator/pkg/events"
        "digital.vasic.translator/pkg/language"
        "digital.vasic.translator/pkg/preparation"
        "digital.vasic.translator/pkg/translator"
        "digital.vasic.translator/pkg/translator/llm"
        "flag"
        "log"
        "os"
        "time"
)

func main() <span class="cov0" title="0">{
        // Parse command-line flags
        inputPath := flag.String("input", "/tmp/markdown_e2e_source.md", "Input ebook path")
        outputPath := flag.String("output", "/tmp/prepared_translated.epub", "Output EPUB path")
        analysisPath := flag.String("analysis", "/tmp/preparation_analysis.json", "Preparation analysis output path")
        sourceLang := flag.String("source", "English", "Source language")
        targetLang := flag.String("target", "Spanish", "Target language")
        passCount := flag.Int("passes", 2, "Number of preparation passes")
        providers := flag.String("providers", "deepseek,zhipu", "Comma-separated list of LLM providers")
        flag.Parse()

        log.SetFlags(log.LstdFlags | log.Lshortfile)

        // Validate input file exists
        if _, err := os.Stat(*inputPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                log.Fatalf("Input file does not exist: %s", *inputPath)
        }</span>

        <span class="cov0" title="0">log.Printf("=== PREPARATION + TRANSLATION INTEGRATION TEST ===\n")
        log.Printf("Input: %s", *inputPath)
        log.Printf("Output: %s", *outputPath)
        log.Printf("Analysis: %s", *analysisPath)
        log.Printf("Languages: %s ‚Üí %s", *sourceLang, *targetLang)
        log.Printf("Preparation passes: %d", *passCount)
        log.Printf("Providers: %s\n", *providers)

        // Parse ebook
        log.Printf("\n1. Parsing ebook...")
        parser := ebook.NewUniversalParser()
        book, err := parser.Parse(*inputPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to parse ebook: %v", err)
        }</span>
        <span class="cov0" title="0">log.Printf("‚úÖ Parsed ebook: %d chapters, %d words",
                book.GetChapterCount(), book.GetWordCount())

        // Setup languages
        sourceLanguage := language.Language{Code: "ru", Name: *sourceLang}
        targetLanguage := language.Language{Code: "sr", Name: *targetLang}

        // Setup preparation configuration
        log.Printf("\n2. Configuring preparation phase...")
        prepConfig := &amp;preparation.PreparationConfig{
                PassCount:          *passCount,
                Providers:          []string{"deepseek", "zhipu"}, // Fixed for now
                AnalyzeContentType: true,
                AnalyzeCharacters:  true,
                AnalyzeTerminology: true,
                AnalyzeCulture:     true,
                AnalyzeChapters:    true,
                DetailLevel:        "comprehensive",
                SourceLanguage:     *sourceLang,
                TargetLanguage:     *targetLang,
        }

        // Create base translator (for translation phase)
        log.Printf("\n3. Creating translator...")
        translatorConfig := translator.TranslationConfig{
                SourceLang: sourceLanguage.Code,
                TargetLang: targetLanguage.Code,
                Provider:   "deepseek",
                Model:      "deepseek-chat",
        }

        baseTranslator, err := llm.NewLLMTranslator(translatorConfig)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create translator: %v", err)
        }</span>

        // Create preparation-aware translator
        <span class="cov0" title="0">log.Printf("\n4. Creating preparation-aware translator...")
        prepTranslator := preparation.NewPreparationAwareTranslator(
                baseTranslator,
                nil, // No language detector for test
                sourceLanguage,
                targetLanguage,
                prepConfig,
        )

        // Create event bus for progress tracking
        eventBus := events.NewEventBus()
        sessionID := "prep-test-session"

        // Subscribe to events with handler functions
        progressHandler := func(event events.Event) </span><span class="cov0" title="0">{
                log.Printf("üìä Progress: %s", event.Message)
                if data, ok := event.Data["phase"]; ok </span><span class="cov0" title="0">{
                        if phase, ok := data.(string); ok &amp;&amp; phase == "preparation" </span><span class="cov0" title="0">{
                                // Log detailed preparation info
                                if contentType, ok := event.Data["content_type"].(string); ok </span><span class="cov0" title="0">{
                                        log.Printf("   Content Type: %s", contentType)
                                }</span>
                                <span class="cov0" title="0">if genre, ok := event.Data["genre"].(string); ok </span><span class="cov0" title="0">{
                                        log.Printf("   Genre: %s", genre)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">errorHandler := func(event events.Event) </span><span class="cov0" title="0">{
                log.Printf("‚ùå Error: %s", event.Message)
        }</span>

        <span class="cov0" title="0">eventBus.Subscribe(events.EventTranslationProgress, progressHandler)
        eventBus.Subscribe(events.EventTranslationError, errorHandler)

        // Run preparation + translation
        ctx := context.Background()
        startTime := time.Now()

        log.Printf("\n5. Running preparation + translation pipeline...")
        err = prepTranslator.TranslateBook(ctx, book, eventBus, sessionID)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Translation failed: %v", err)
        }</span>

        <span class="cov0" title="0">duration := time.Since(startTime)
        log.Printf("\n‚úÖ Translation complete in %.2f seconds", duration.Seconds())

        // Save preparation analysis
        log.Printf("\n6. Saving preparation analysis...")
        if err := prepTranslator.SavePreparationAnalysis(*analysisPath); err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Failed to save analysis: %v", err)
        }</span> else<span class="cov0" title="0"> {
                log.Printf("‚úÖ Analysis saved to: %s", *analysisPath)
        }</span>

        // Print preparation summary
        <span class="cov0" title="0">if result := prepTranslator.GetPreparationResult(); result != nil </span><span class="cov0" title="0">{
                log.Printf("\n=== PREPARATION SUMMARY ===")
                log.Printf("Content Type: %s", result.FinalAnalysis.ContentType)
                log.Printf("Genre: %s", result.FinalAnalysis.Genre)
                log.Printf("Subgenres: %v", result.FinalAnalysis.Subgenres)
                log.Printf("Tone: %s", result.FinalAnalysis.Tone)
                log.Printf("Untranslatable Terms: %d", len(result.FinalAnalysis.UntranslatableTerms))
                log.Printf("Footnotes Needed: %d", len(result.FinalAnalysis.FootnoteGuidance))
                log.Printf("Characters: %d", len(result.FinalAnalysis.Characters))
                log.Printf("Cultural References: %d", len(result.FinalAnalysis.CulturalReferences))
                log.Printf("Key Themes: %d", len(result.FinalAnalysis.KeyThemes))
                log.Printf("Preparation Duration: %.2f seconds", result.TotalDuration.Seconds())
                log.Printf("Total Passes: %d", result.PassCount)
                log.Printf("Total Tokens: %d", result.TotalTokens)

                // Print some key themes
                if len(result.FinalAnalysis.KeyThemes) &gt; 0 </span><span class="cov0" title="0">{
                        log.Printf("\nKey Themes:")
                        for i, theme := range result.FinalAnalysis.KeyThemes </span><span class="cov0" title="0">{
                                if i &gt;= 5 </span><span class="cov0" title="0">{
                                        log.Printf("  ... and %d more", len(result.FinalAnalysis.KeyThemes)-5)
                                        break</span>
                                }
                                <span class="cov0" title="0">log.Printf("  - %s", theme)</span>
                        }
                }

                // Print some untranslatable terms
                <span class="cov0" title="0">if len(result.FinalAnalysis.UntranslatableTerms) &gt; 0 </span><span class="cov0" title="0">{
                        log.Printf("\nUntranslatable Terms (sample):")
                        for i, term := range result.FinalAnalysis.UntranslatableTerms </span><span class="cov0" title="0">{
                                if i &gt;= 5 </span><span class="cov0" title="0">{
                                        log.Printf("  ... and %d more", len(result.FinalAnalysis.UntranslatableTerms)-5)
                                        break</span>
                                }
                                <span class="cov0" title="0">log.Printf("  - %s: %s", term.Term, term.Reason)</span>
                        }
                }

                // Print characters
                <span class="cov0" title="0">if len(result.FinalAnalysis.Characters) &gt; 0 </span><span class="cov0" title="0">{
                        log.Printf("\nCharacters:")
                        for _, char := range result.FinalAnalysis.Characters </span><span class="cov0" title="0">{
                                log.Printf("  - %s (%s)", char.Name, char.Role)
                                if char.SpeechPattern != "" </span><span class="cov0" title="0">{
                                        log.Printf("    Speech: %s", char.SpeechPattern)
                                }</span>
                        }
                }
        }

        // Save translated book
        <span class="cov0" title="0">log.Printf("\n7. Saving translated book...")
        writer := ebook.NewEPUBWriter()
        if err := writer.Write(book, *outputPath); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to write EPUB: %v", err)
        }</span>
        <span class="cov0" title="0">log.Printf("‚úÖ Translated book saved to: %s", *outputPath)

        // Final statistics
        log.Printf("\n=== FINAL STATISTICS ===")
        log.Printf("Total Duration: %.2f seconds", duration.Seconds())
        log.Printf("Input Chapters: %d", book.GetChapterCount())
        log.Printf("Output File: %s", *outputPath)
        log.Printf("Analysis File: %s", *analysisPath)

        // Check file sizes
        if info, err := os.Stat(*outputPath); err == nil </span><span class="cov0" title="0">{
                log.Printf("Output Size: %d bytes", info.Size())
        }</span>
        <span class="cov0" title="0">if info, err := os.Stat(*analysisPath); err == nil </span><span class="cov0" title="0">{
                log.Printf("Analysis Size: %d bytes", info.Size())
        }</span>

        <span class="cov0" title="0">log.Printf("\n‚úÖ TEST COMPLETE - Preparation + Translation pipeline successful!")</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "context"
        "crypto/tls"
        "digital.vasic.translator/internal/cache"
        "digital.vasic.translator/internal/config"
        "digital.vasic.translator/pkg/api"
        "digital.vasic.translator/pkg/coordination"
        "digital.vasic.translator/pkg/deployment"
        "digital.vasic.translator/pkg/distributed"
        "digital.vasic.translator/pkg/events"
        "digital.vasic.translator/pkg/security"
        "digital.vasic.translator/pkg/websocket"
        "flag"
        "fmt"
        "log"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/quic-go/quic-go/http3"
)

const version = "1.0.0"

func main() <span class="cov0" title="0">{
        // Parse command-line flags
        configFile := flag.String("config", "config.json", "Configuration file path")
        showVersion := flag.Bool("version", false, "Show version")
        generateCerts := flag.Bool("generate-certs", false, "Generate self-signed TLS certificates")
        flag.Parse()

        if *showVersion </span><span class="cov0" title="0">{
                fmt.Printf("Universal Multi-Format Multi-Language Ebook Translation Server v%s\n", version)
                os.Exit(0)
        }</span>

        <span class="cov0" title="0">if *generateCerts </span><span class="cov0" title="0">{
                if err := generateTLSCertificates(); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to generate certificates: %v", err)
                }</span>
                <span class="cov0" title="0">fmt.Println("TLS certificates generated successfully")
                os.Exit(0)</span>
        }

        // Load configuration
        <span class="cov0" title="0">cfg, err := loadOrCreateConfig(*configFile)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load config: %v", err)
        }</span>

        // Validate configuration
        <span class="cov0" title="0">if err := cfg.Validate(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Invalid configuration: %v", err)
        }</span>

        // Initialize components
        <span class="cov0" title="0">eventBus := events.NewEventBus()
        translationCache := cache.NewCache(time.Duration(cfg.Translation.CacheTTL)*time.Second, cfg.Translation.CacheEnabled)
        authService := security.NewAuthService(cfg.Security.JWTSecret, 24*time.Hour)
        rateLimiter := security.NewRateLimiter(cfg.Security.RateLimitRPS, cfg.Security.RateLimitBurst)
        wsHub := websocket.NewHub(eventBus)

        // Initialize local coordinator
        localCoordinator := coordination.NewMultiLLMCoordinator(coordination.CoordinatorConfig{
                EventBus: eventBus,
        })

        // Initialize API communication logger for distributed operations
        var apiLogger *deployment.APICommunicationLogger
        if cfg.Distributed.Enabled </span><span class="cov0" title="0">{
                var err error
                apiLogger, err = deployment.NewAPICommunicationLogger("workers_api_communication.log")
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: failed to initialize API logger: %v", err)
                }</span>
        }

        // Initialize distributed manager if enabled
        <span class="cov0" title="0">var distributedManager interface{}
        if cfg.Distributed.Enabled </span><span class="cov0" title="0">{
                distributedManager = distributed.NewDistributedManager(cfg, eventBus, apiLogger)
                // Initialize with local coordinator
                if dm, ok := distributedManager.(*distributed.DistributedManager); ok </span><span class="cov0" title="0">{
                        if err := dm.Initialize(localCoordinator); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Failed to initialize distributed manager: %v", err)
                                distributedManager = nil
                        }</span>
                }
        }

        // Start WebSocket hub
        <span class="cov0" title="0">go wsHub.Run()

        // Create Gin router
        if cfg.Logging.Level != "debug" </span><span class="cov0" title="0">{
                gin.SetMode(gin.ReleaseMode)
        }</span>

        <span class="cov0" title="0">router := gin.Default()

        // Setup middleware
        router.Use(corsMiddleware(cfg.Security.CORSOrigins))
        router.Use(rateLimitMiddleware(rateLimiter))

        // Create API handler
        apiHandler := api.NewHandler(cfg, eventBus, translationCache, authService, wsHub, distributedManager)
        apiHandler.RegisterRoutes(router)

        // Server configuration
        addr := fmt.Sprintf("%s:%d", cfg.Server.Host, cfg.Server.Port)

        // Create HTTP/3 server if enabled
        if cfg.Server.EnableHTTP3 </span><span class="cov0" title="0">{
                log.Printf("Starting HTTP/3 server on %s", addr)
                if err := startHTTP3Server(addr, cfg, router); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("HTTP/3 server failed: %v", err)
                }</span>
        } else<span class="cov0" title="0"> {
                log.Printf("Starting HTTP/2 server on %s", addr)
                if err := startHTTP2Server(addr, cfg, router); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("HTTP/2 server failed: %v", err)
                }</span>
        }
}

func loadOrCreateConfig(filename string) (*config.Config, error) <span class="cov0" title="0">{
        // Check if config exists
        if _, err := os.Stat(filename); os.IsNotExist(err) </span><span class="cov0" title="0">{
                log.Printf("Config file not found, creating default: %s", filename)
                cfg := config.DefaultConfig()

                if err := config.SaveConfig(filename, cfg); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to save default config: %w", err)
                }</span>

                <span class="cov0" title="0">return cfg, nil</span>
        }

        <span class="cov0" title="0">return config.LoadConfig(filename)</span>
}

func startHTTP3Server(addr string, cfg *config.Config, handler http.Handler) error <span class="cov0" title="0">{
        // Load TLS certificates
        tlsConfig := &amp;tls.Config{
                MinVersion: tls.VersionTLS13,
                NextProtos: []string{"h3"},
        }

        cert, err := tls.LoadX509KeyPair(cfg.Server.TLSCertFile, cfg.Server.TLSKeyFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load TLS certificates: %w", err)
        }</span>
        <span class="cov0" title="0">tlsConfig.Certificates = []tls.Certificate{cert}

        // Create HTTP/3 server
        server := &amp;http3.Server{
                Addr:      addr,
                Handler:   handler,
                TLSConfig: tlsConfig,
        }

        // Create HTTP/2 fallback server
        fallbackServer := &amp;http.Server{
                Addr:         addr,
                Handler:      handler,
                TLSConfig:    tlsConfig,
                ReadTimeout:  time.Duration(cfg.Server.ReadTimeout) * time.Second,
                WriteTimeout: time.Duration(cfg.Server.WriteTimeout) * time.Second,
        }

        // Start HTTP/2 fallback in goroutine
        go func() </span><span class="cov0" title="0">{
                log.Printf("Starting HTTP/2 fallback server on %s", addr)
                if err := fallbackServer.ListenAndServeTLS("", ""); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Printf("HTTP/2 fallback server error: %v", err)
                }</span>
        }()

        // Handle graceful shutdown
        <span class="cov0" title="0">go handleShutdown(server, fallbackServer)

        log.Printf("Server started successfully!")
        log.Printf("HTTP/3 (QUIC): https://%s", addr)
        log.Printf("HTTP/2 (TLS): https://%s", addr)
        log.Printf("WebSocket: wss://%s/ws", addr)

        // Start HTTP/3 server
        return server.ListenAndServeTLS(cfg.Server.TLSCertFile, cfg.Server.TLSKeyFile)</span>
}

func startHTTP2Server(addr string, cfg *config.Config, handler http.Handler) error <span class="cov0" title="0">{
        // Load TLS certificates
        tlsConfig := &amp;tls.Config{
                MinVersion: tls.VersionTLS12,
        }

        cert, err := tls.LoadX509KeyPair(cfg.Server.TLSCertFile, cfg.Server.TLSKeyFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load TLS certificates: %w", err)
        }</span>
        <span class="cov0" title="0">tlsConfig.Certificates = []tls.Certificate{cert}

        server := &amp;http.Server{
                Addr:         addr,
                Handler:      handler,
                ReadTimeout:  time.Duration(cfg.Server.ReadTimeout) * time.Second,
                WriteTimeout: time.Duration(cfg.Server.WriteTimeout) * time.Second,
                TLSConfig:    tlsConfig,
        }

        // Handle graceful shutdown
        go handleShutdown(nil, server)

        log.Printf("Server started successfully!")
        log.Printf("HTTP/2 (TLS): https://%s", addr)

        return server.ListenAndServeTLS("", "")</span>
}

func handleShutdown(http3Server *http3.Server, http2Server *http.Server) <span class="cov0" title="0">{
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)

        &lt;-sigChan
        log.Println("Shutting down gracefully...")

        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        if http3Server != nil </span><span class="cov0" title="0">{
                if err := http3Server.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("HTTP/3 server shutdown error: %v", err)
                }</span>
        }

        <span class="cov0" title="0">if http2Server != nil </span><span class="cov0" title="0">{
                if err := http2Server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        log.Printf("HTTP/2 server shutdown error: %v", err)
                }</span>
        }

        <span class="cov0" title="0">log.Println("Server stopped")
        os.Exit(0)</span>
}

func corsMiddleware(origins []string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                origin := c.Request.Header.Get("Origin")

                // Check if origin is allowed
                allowed := false
                for _, o := range origins </span><span class="cov0" title="0">{
                        if o == "*" || o == origin </span><span class="cov0" title="0">{
                                allowed = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">if allowed </span><span class="cov0" title="0">{
                        c.Writer.Header().Set("Access-Control-Allow-Origin", origin)
                        c.Writer.Header().Set("Access-Control-Allow-Credentials", "true")
                        c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, X-API-Key")
                        c.Writer.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                }</span>

                <span class="cov0" title="0">if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(http.StatusNoContent)
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

func rateLimitMiddleware(limiter *security.RateLimiter) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Use IP address as key
                key := c.ClientIP()

                if !limiter.Allow(key) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusTooManyRequests, gin.H{
                                "error": "Rate limit exceeded",
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

func generateTLSCertificates() error <span class="cov0" title="0">{
        // This is a placeholder - in production, use proper certificate generation
        // or obtain certificates from Let's Encrypt
        fmt.Println("Please generate TLS certificates using:")
        fmt.Println("  openssl req -x509 -newkey rsa:4096 -keyout certs/server.key -out certs/server.crt -days 365 -nodes")
        return nil
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package cache

import (
        "crypto/sha256"
        "encoding/hex"
        "sync"
        "time"
)

// CacheEntry represents a cached translation
type CacheEntry struct {
        Value      string
        Expiration time.Time
}

// Cache implements thread-safe translation caching
type Cache struct {
        mu      sync.RWMutex
        entries map[string]CacheEntry
        ttl     time.Duration
        enabled bool
}

// NewCache creates a new cache
func NewCache(ttl time.Duration, enabled bool) *Cache <span class="cov8" title="1">{
        c := &amp;Cache{
                entries: make(map[string]CacheEntry),
                ttl:     ttl,
                enabled: enabled,
        }

        // Start cleanup goroutine
        if enabled </span><span class="cov8" title="1">{
                go c.cleanup()
        }</span>

        <span class="cov8" title="1">return c</span>
}

// Get retrieves a value from cache
func (c *Cache) Get(key string) (string, bool) <span class="cov8" title="1">{
        if !c.enabled </span><span class="cov8" title="1">{
                return "", false
        }</span>

        <span class="cov8" title="1">c.mu.RLock()
        defer c.mu.RUnlock()

        entry, ok := c.entries[c.hashKey(key)]
        if !ok </span><span class="cov8" title="1">{
                return "", false
        }</span>

        // Check expiration
        <span class="cov8" title="1">if time.Now().After(entry.Expiration) </span><span class="cov8" title="1">{
                return "", false
        }</span>

        <span class="cov8" title="1">return entry.Value, true</span>
}

// Set stores a value in cache
func (c *Cache) Set(key, value string) <span class="cov8" title="1">{
        if !c.enabled </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">c.mu.Lock()
        defer c.mu.Unlock()

        c.entries[c.hashKey(key)] = CacheEntry{
                Value:      value,
                Expiration: time.Now().Add(c.ttl),
        }</span>
}

// Delete removes a value from cache
func (c *Cache) Delete(key string) <span class="cov8" title="1">{
        if !c.enabled </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">c.mu.Lock()
        defer c.mu.Unlock()

        delete(c.entries, c.hashKey(key))</span>
}

// Clear removes all entries from cache
func (c *Cache) Clear() <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.entries = make(map[string]CacheEntry)
}</span>

// Size returns the number of entries in cache
func (c *Cache) Size() int <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        return len(c.entries)
}</span>

// Stats returns cache statistics
func (c *Cache) Stats() CacheStats <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        validCount := 0
        expiredCount := 0
        now := time.Now()

        for _, entry := range c.entries </span><span class="cov8" title="1">{
                if now.After(entry.Expiration) </span><span class="cov8" title="1">{
                        expiredCount++
                }</span> else<span class="cov8" title="1"> {
                        validCount++
                }</span>
        }

        <span class="cov8" title="1">return CacheStats{
                TotalEntries:   len(c.entries),
                ValidEntries:   validCount,
                ExpiredEntries: expiredCount,
                Enabled:        c.enabled,
                TTL:            c.ttl,
        }</span>
}

// CacheStats represents cache statistics
type CacheStats struct {
        TotalEntries   int
        ValidEntries   int
        ExpiredEntries int
        Enabled        bool
        TTL            time.Duration
}

// hashKey creates a hash of the cache key
func (c *Cache) hashKey(key string) string <span class="cov8" title="1">{
        hash := sha256.Sum256([]byte(key))
        return hex.EncodeToString(hash[:])
}</span>

// cleanup periodically removes expired entries
func (c *Cache) cleanup() <span class="cov8" title="1">{
        ticker := time.NewTicker(time.Minute * 5)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                c.removeExpired()
        }</span>
}

// removeExpired removes expired entries from cache
func (c *Cache) removeExpired() <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        now := time.Now()
        for key, entry := range c.entries </span><span class="cov8" title="1">{
                if now.After(entry.Expiration) </span><span class="cov8" title="1">{
                        delete(c.entries, key)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package config

import (
        "encoding/json"
        "fmt"
        "os"
)

// Config represents the application configuration
type Config struct {
        Server      ServerConfig      `json:"server"`
        Security    SecurityConfig    `json:"security"`
        Translation TranslationConfig `json:"translation"`
        Preparation PreparationConfig `json:"preparation"`
        Distributed DistributedConfig `json:"distributed"`
        Logging     LoggingConfig     `json:"logging"`
}

// ServerConfig represents server configuration
type ServerConfig struct {
        Host          string `json:"host"`
        Port          int    `json:"port"`
        EnableHTTP3   bool   `json:"enable_http3"`
        TLSCertFile   string `json:"tls_cert_file"`
        TLSKeyFile    string `json:"tls_key_file"`
        ReadTimeout   int    `json:"read_timeout"`
        WriteTimeout  int    `json:"write_timeout"`
        MaxUploadSize int64  `json:"max_upload_size"`
}

// SecurityConfig represents security configuration
type SecurityConfig struct {
        EnableAuth     bool     `json:"enable_auth"`
        JWTSecret      string   `json:"jwt_secret"`
        APIKeyHeader   string   `json:"api_key_header"`
        RateLimitRPS   int      `json:"rate_limit_rps"`
        RateLimitBurst int      `json:"rate_limit_burst"`
        CORSOrigins    []string `json:"cors_origins"`
}

// TranslationConfig represents translation configuration
type TranslationConfig struct {
        DefaultProvider string                    `json:"default_provider"`
        DefaultModel    string                    `json:"default_model"`
        CacheEnabled    bool                      `json:"cache_enabled"`
        CacheTTL        int                       `json:"cache_ttl"`
        MaxConcurrent   int                       `json:"max_concurrent"`
        Providers       map[string]ProviderConfig `json:"providers"`
}

// ProviderConfig represents LLM provider configuration
type ProviderConfig struct {
        APIKey  string                 `json:"api_key,omitempty"`
        BaseURL string                 `json:"base_url,omitempty"`
        Model   string                 `json:"model"`
        Options map[string]interface{} `json:"options,omitempty"`
}

// DistributedConfig represents distributed work configuration
type DistributedConfig struct {
        Enabled             bool                    `json:"enabled"`
        Workers             map[string]WorkerConfig `json:"workers"`
        SSHTimeout          int                     `json:"ssh_timeout"`
        SSHMaxRetries       int                     `json:"ssh_max_retries"`
        HealthCheckInterval int                     `json:"health_check_interval"`
        MaxRemoteInstances  int                     `json:"max_remote_instances"`
}

// WorkerConfig represents a remote worker configuration
type WorkerConfig struct {
        Name        string   `json:"name"`
        Host        string   `json:"host"`
        Port        int      `json:"port"`
        User        string   `json:"user"`
        KeyFile     string   `json:"key_file,omitempty"`
        Password    string   `json:"password,omitempty"`
        MaxCapacity int      `json:"max_capacity"`
        Tags        []string `json:"tags,omitempty"`
        Enabled     bool     `json:"enabled"`
}

// LoggingConfig represents logging configuration
type LoggingConfig struct {
        Level      string `json:"level"`
        Format     string `json:"format"`
        OutputFile string `json:"output_file"`
}

// PreparationConfig represents preparation phase configuration
type PreparationConfig struct {
        Enabled            bool     `json:"enabled"`
        PassCount          int      `json:"pass_count"`
        Providers          []string `json:"providers"`
        AnalyzeContentType bool     `json:"analyze_content_type"`
        AnalyzeCharacters  bool     `json:"analyze_characters"`
        AnalyzeTerminology bool     `json:"analyze_terminology"`
        AnalyzeCulture     bool     `json:"analyze_culture"`
        AnalyzeChapters    bool     `json:"analyze_chapters"`
        DetailLevel        string   `json:"detail_level"`
}

// DefaultConfig returns default configuration
func DefaultConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                Server: ServerConfig{
                        Host:          "0.0.0.0",
                        Port:          8443,
                        EnableHTTP3:   true,
                        TLSCertFile:   "certs/server.crt",
                        TLSKeyFile:    "certs/server.key",
                        ReadTimeout:   30,
                        WriteTimeout:  30,
                        MaxUploadSize: 100 * 1024 * 1024, // 100MB
                },
                Security: SecurityConfig{
                        EnableAuth:     true,
                        JWTSecret:      "",
                        APIKeyHeader:   "X-API-Key",
                        RateLimitRPS:   10,
                        RateLimitBurst: 20,
                        CORSOrigins:    []string{"*"},
                },
                Translation: TranslationConfig{
                        DefaultProvider: "openai",
                        DefaultModel:    "",
                        CacheEnabled:    true,
                        CacheTTL:        3600,
                        MaxConcurrent:   5,
                        Providers:       make(map[string]ProviderConfig),
                },
                Preparation: PreparationConfig{
                        Enabled:            true,
                        PassCount:          2,
                        Providers:          []string{"deepseek", "anthropic"},
                        AnalyzeContentType: true,
                        AnalyzeCharacters:  true,
                        AnalyzeTerminology: true,
                        AnalyzeCulture:     true,
                        AnalyzeChapters:    true,
                        DetailLevel:        "standard",
                },
                Distributed: DistributedConfig{
                        Enabled:             false,
                        Workers:             make(map[string]WorkerConfig),
                        SSHTimeout:          30,
                        SSHMaxRetries:       3,
                        HealthCheckInterval: 30,
                        MaxRemoteInstances:  20,
                },
                Logging: LoggingConfig{
                        Level:      "info",
                        Format:     "json",
                        OutputFile: "",
                },
        }
}</span>

// LoadConfig loads configuration from file
func LoadConfig(filename string) (*Config, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(filename)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        <span class="cov8" title="1">var config Config
        if err := json.Unmarshal(data, &amp;config); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse config: %w", err)
        }</span>

        // Load API keys from environment variables
        <span class="cov8" title="1">config.loadAPIKeysFromEnv()

        return &amp;config, nil</span>
}

// SaveConfig saves configuration to file
func SaveConfig(filename string, config *Config) error <span class="cov8" title="1">{
        data, err := json.MarshalIndent(config, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal config: %w", err)
        }</span>

        <span class="cov8" title="1">if err := os.WriteFile(filename, data, 0600); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to write config file: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// loadAPIKeysFromEnv loads API keys from environment variables
func (c *Config) loadAPIKeysFromEnv() <span class="cov8" title="1">{
        envMappings := map[string]string{
                "openai":    "OPENAI_API_KEY",
                "anthropic": "ANTHROPIC_API_KEY",
                "zhipu":     "ZHIPU_API_KEY",
                "deepseek":  "DEEPSEEK_API_KEY",
        }

        for provider, envVar := range envMappings </span><span class="cov8" title="1">{
                if key := os.Getenv(envVar); key != "" </span><span class="cov8" title="1">{
                        if providerConfig, ok := c.Translation.Providers[provider]; ok </span><span class="cov8" title="1">{
                                providerConfig.APIKey = key
                                c.Translation.Providers[provider] = providerConfig
                        }</span> else<span class="cov8" title="1"> {
                                c.Translation.Providers[provider] = ProviderConfig{
                                        APIKey: key,
                                }
                        }</span>
                }
        }

        // Load JWT secret
        <span class="cov8" title="1">if jwtSecret := os.Getenv("JWT_SECRET"); jwtSecret != "" </span><span class="cov8" title="1">{
                c.Security.JWTSecret = jwtSecret
        }</span>
}

// Validate validates the configuration
func (c *Config) Validate() error <span class="cov8" title="1">{
        if c.Server.Port &lt; 1 || c.Server.Port &gt; 65535 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid server port: %d", c.Server.Port)
        }</span>

        <span class="cov8" title="1">if c.Server.EnableHTTP3 </span><span class="cov8" title="1">{
                if c.Server.TLSCertFile == "" || c.Server.TLSKeyFile == "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("TLS certificate and key files are required for HTTP/3")
                }</span>
        }

        <span class="cov8" title="1">if c.Security.EnableAuth &amp;&amp; c.Security.JWTSecret == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("JWT secret is required when authentication is enabled")
        }</span>

        // Validate distributed configuration
        <span class="cov8" title="1">if err := c.validateDistributedConfig(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateDistributedConfig validates distributed work configuration
func (c *Config) validateDistributedConfig() error <span class="cov8" title="1">{
        if !c.Distributed.Enabled </span><span class="cov8" title="1">{
                return nil // Skip validation if distributed work is disabled
        }</span>

        // Validate SSH timeout
        <span class="cov0" title="0">if c.Distributed.SSHTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("SSH timeout must be positive")
        }</span>

        // Validate SSH max retries
        <span class="cov0" title="0">if c.Distributed.SSHMaxRetries &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("SSH max retries cannot be negative")
        }</span>

        // Validate workers configuration
        <span class="cov0" title="0">if len(c.Distributed.Workers) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("at least one worker must be configured when distributed work is enabled")
        }</span>

        // Validate each worker
        <span class="cov0" title="0">for workerID, worker := range c.Distributed.Workers </span><span class="cov0" title="0">{
                if err := c.validateWorkerConfig(workerID, worker); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateWorkerConfig validates a single worker configuration
func (c *Config) validateWorkerConfig(workerID string, worker WorkerConfig) error <span class="cov0" title="0">{
        if worker.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("worker %s: name cannot be empty", workerID)
        }</span>

        <span class="cov0" title="0">if worker.Host == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("worker %s: host cannot be empty", workerID)
        }</span>

        <span class="cov0" title="0">if worker.Port &lt;= 0 || worker.Port &gt; 65535 </span><span class="cov0" title="0">{
                return fmt.Errorf("worker %s: invalid port %d", workerID, worker.Port)
        }</span>

        <span class="cov0" title="0">if worker.User == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("worker %s: user cannot be empty", workerID)
        }</span>

        // Validate authentication - at least one method must be provided
        <span class="cov0" title="0">if worker.KeyFile == "" &amp;&amp; worker.Password == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("worker %s: either key file or password must be provided", workerID)
        }</span>

        <span class="cov0" title="0">if worker.MaxCapacity &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("worker %s: max capacity must be positive", workerID)
        }</span>

        // Validate tags (optional but if provided should be reasonable)
        <span class="cov0" title="0">for _, tag := range worker.Tags </span><span class="cov0" title="0">{
                if tag == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("worker %s: empty tag not allowed", workerID)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package api

import (
        "context"
        "fmt"
        "net/http"
        "time"

        "digital.vasic.translator/pkg/batch"
        "digital.vasic.translator/pkg/events"
        "digital.vasic.translator/pkg/language"
        "digital.vasic.translator/pkg/translator"
        "digital.vasic.translator/pkg/translator/llm"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// TranslateStringRequest represents a string translation request
type TranslateStringRequest struct {
        Text           string `json:"text" binding:"required"`
        SourceLanguage string `json:"source_language,omitempty"`
        TargetLanguage string `json:"target_language" binding:"required"`
        Provider       string `json:"provider,omitempty"`
        Model          string `json:"model,omitempty"`
}

// TranslateStringResponse represents a string translation response
type TranslateStringResponse struct {
        TranslatedText string  `json:"translated_text"`
        SourceLanguage string  `json:"source_language"`
        TargetLanguage string  `json:"target_language"`
        Provider       string  `json:"provider"`
        Duration       float64 `json:"duration_seconds"`
        SessionID      string  `json:"session_id"`
}

// TranslateDirectoryRequest represents a directory translation request
type TranslateDirectoryRequest struct {
        InputPath      string `json:"input_path" binding:"required"`
        OutputPath     string `json:"output_path"`
        SourceLanguage string `json:"source_language,omitempty"`
        TargetLanguage string `json:"target_language" binding:"required"`
        Provider       string `json:"provider,omitempty"`
        Model          string `json:"model,omitempty"`
        Recursive      bool   `json:"recursive"`
        Parallel       bool   `json:"parallel"`
        MaxConcurrency int    `json:"max_concurrency,omitempty"`
        OutputFormat   string `json:"output_format,omitempty"`
}

// TranslateDirectoryResponse represents a directory translation response
type TranslateDirectoryResponse struct {
        SessionID  string       `json:"session_id"`
        TotalFiles int          `json:"total_files"`
        Successful int          `json:"successful"`
        Failed     int          `json:"failed"`
        Duration   float64      `json:"duration_seconds"`
        Results    []FileResult `json:"results"`
}

// FileResult represents the result of a single file translation
type FileResult struct {
        InputPath  string `json:"input_path"`
        OutputPath string `json:"output_path"`
        Success    bool   `json:"success"`
        Error      string `json:"error,omitempty"`
}

// HandleTranslateString handles string translation requests
func (h *Handler) HandleTranslateString(c *gin.Context) <span class="cov8" title="1">{
        var req TranslateStringRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Generate session ID
        <span class="cov8" title="1">sessionID := uuid.New().String()

        // Parse target language
        targetLang, err := language.ParseLanguage(req.TargetLanguage)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("invalid target language: %v", err)})
                return
        }</span>

        // Parse source language if provided
        <span class="cov8" title="1">var sourceLang language.Language
        if req.SourceLanguage != "" </span><span class="cov0" title="0">{
                sourceLang, err = language.ParseLanguage(req.SourceLanguage)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("invalid source language: %v", err)})
                        return
                }</span>
        }

        // Create translator
        <span class="cov8" title="1">var trans translator.Translator

        provider := req.Provider
        if provider == "" </span><span class="cov8" title="1">{
                provider = h.config.Translation.DefaultProvider
                if provider == "" </span><span class="cov0" title="0">{
                        provider = "openai"
                }</span>
        }

        <span class="cov8" title="1">model := req.Model
        if model == "" </span><span class="cov8" title="1">{
                model = h.config.Translation.DefaultModel
        }</span>

        <span class="cov8" title="1">translatorConfig := translator.TranslationConfig{
                SourceLang: sourceLang.Code,
                TargetLang: targetLang.Code,
                Provider:   provider,
                Model:      model,
        }

        switch provider </span>{
        case "openai", "anthropic", "zhipu", "deepseek", "ollama", "llamacpp":<span class="cov8" title="1">
                trans, err = llm.NewLLMTranslator(translatorConfig)
                if err != nil </span><span class="cov8" title="1">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("failed to create translator: %v", err)})
                        return
                }</span>
        default:<span class="cov8" title="1">
                c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("unsupported provider: %s", provider)})
                return</span>
        }

        // Emit start event
        <span class="cov0" title="0">h.eventBus.Publish(events.Event{
                Type:      events.EventTranslationStarted,
                SessionID: sessionID,
                Message:   "String translation started",
                Data: map[string]interface{}{
                        "text_length":     len(req.Text),
                        "source_language": req.SourceLanguage,
                        "target_language": req.TargetLanguage,
                        "provider":        provider,
                },
        })

        // Translate
        startTime := time.Now()
        ctx := context.Background()
        translatedText, err := trans.Translate(ctx, req.Text, "")
        duration := time.Since(startTime).Seconds()

        if err != nil </span><span class="cov0" title="0">{
                h.eventBus.Publish(events.Event{
                        Type:      events.EventTranslationError,
                        SessionID: sessionID,
                        Message:   fmt.Sprintf("Translation failed: %v", err),
                })
                c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("translation failed: %v", err)})
                return
        }</span>

        // Emit completion event
        <span class="cov0" title="0">h.eventBus.Publish(events.Event{
                Type:      events.EventTranslationCompleted,
                SessionID: sessionID,
                Message:   "String translation completed",
                Data: map[string]interface{}{
                        "duration": duration,
                },
        })

        // Return response
        c.JSON(http.StatusOK, TranslateStringResponse{
                TranslatedText: translatedText,
                SourceLanguage: sourceLang.Code,
                TargetLanguage: targetLang.Code,
                Provider:       provider,
                Duration:       duration,
                SessionID:      sessionID,
        })</span>
}

// HandleTranslateDirectory handles directory translation requests
func (h *Handler) HandleTranslateDirectory(c *gin.Context) <span class="cov8" title="1">{
        var req TranslateDirectoryRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Generate session ID
        <span class="cov8" title="1">sessionID := uuid.New().String()

        // Parse target language
        targetLang, err := language.ParseLanguage(req.TargetLanguage)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("invalid target language: %v", err)})
                return
        }</span>

        // Parse source language if provided
        <span class="cov8" title="1">var sourceLang language.Language
        if req.SourceLanguage != "" </span><span class="cov0" title="0">{
                sourceLang, err = language.ParseLanguage(req.SourceLanguage)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("invalid source language: %v", err)})
                        return
                }</span>
        }

        // Create translator
        <span class="cov8" title="1">var trans translator.Translator
        provider := req.Provider
        if provider == "" </span><span class="cov0" title="0">{
                provider = h.config.Translation.DefaultProvider
                if provider == "" </span><span class="cov0" title="0">{
                        provider = "openai"
                }</span>
        }

        <span class="cov8" title="1">model := req.Model
        if model == "" </span><span class="cov8" title="1">{
                model = h.config.Translation.DefaultModel
        }</span>

        <span class="cov8" title="1">translatorConfig := translator.TranslationConfig{
                SourceLang: sourceLang.Code,
                TargetLang: targetLang.Code,
                Provider:   provider,
                Model:      model,
        }

        switch provider </span>{
        case "openai", "anthropic", "zhipu", "deepseek", "ollama", "llamacpp":<span class="cov8" title="1">
                trans, err = llm.NewLLMTranslator(translatorConfig)
                if err != nil </span><span class="cov8" title="1">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("failed to create translator: %v", err)})
                        return
                }</span>
        default:<span class="cov0" title="0">
                c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("unsupported provider: %s", provider)})
                return</span>
        }

        // Create batch processor
        <span class="cov0" title="0">options := &amp;batch.ProcessingOptions{
                InputType:      batch.InputTypeDirectory,
                InputPath:      req.InputPath,
                OutputPath:     req.OutputPath,
                OutputFormat:   req.OutputFormat,
                SourceLanguage: sourceLang,
                TargetLanguage: targetLang,
                Provider:       provider,
                Model:          req.Model,
                Translator:     trans,
                Recursive:      req.Recursive,
                Parallel:       req.Parallel,
                MaxConcurrency: req.MaxConcurrency,
                EventBus:       h.eventBus,
                SessionID:      sessionID,
        }

        processor := batch.NewBatchProcessor(options)

        // Emit start event
        h.eventBus.Publish(events.Event{
                Type:      events.EventTranslationStarted,
                SessionID: sessionID,
                Message:   "Directory translation started",
                Data: map[string]interface{}{
                        "input_path":      req.InputPath,
                        "output_path":     req.OutputPath,
                        "target_language": req.TargetLanguage,
                        "provider":        provider,
                        "recursive":       req.Recursive,
                        "parallel":        req.Parallel,
                },
        })

        // Process directory
        startTime := time.Now()
        ctx := context.Background()
        results, err := processor.Process(ctx)
        duration := time.Since(startTime).Seconds()

        if err != nil </span><span class="cov0" title="0">{
                h.eventBus.Publish(events.Event{
                        Type:      events.EventTranslationError,
                        SessionID: sessionID,
                        Message:   fmt.Sprintf("Directory translation failed: %v", err),
                })
                c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("directory translation failed: %v", err)})
                return
        }</span>

        // Count successes and failures
        <span class="cov0" title="0">successful := 0
        failed := 0
        fileResults := make([]FileResult, len(results))
        for i, result := range results </span><span class="cov0" title="0">{
                if result.Success </span><span class="cov0" title="0">{
                        successful++
                }</span> else<span class="cov0" title="0"> {
                        failed++
                }</span>

                <span class="cov0" title="0">errMsg := ""
                if result.Error != nil </span><span class="cov0" title="0">{
                        errMsg = result.Error.Error()
                }</span>

                <span class="cov0" title="0">fileResults[i] = FileResult{
                        InputPath:  result.InputPath,
                        OutputPath: result.OutputPath,
                        Success:    result.Success,
                        Error:      errMsg,
                }</span>
        }

        // Emit completion event
        <span class="cov0" title="0">h.eventBus.Publish(events.Event{
                Type:      events.EventTranslationCompleted,
                SessionID: sessionID,
                Message:   fmt.Sprintf("Directory translation completed: %d successful, %d failed", successful, failed),
                Data: map[string]interface{}{
                        "total":      len(results),
                        "successful": successful,
                        "failed":     failed,
                        "duration":   duration,
                },
        })

        // Return response
        c.JSON(http.StatusOK, TranslateDirectoryResponse{
                SessionID:  sessionID,
                TotalFiles: len(results),
                Successful: successful,
                Failed:     failed,
                Duration:   duration,
                Results:    fileResults,
        })</span>
}

// RegisterBatchRoutes registers batch translation routes
func (h *Handler) RegisterBatchRoutes(router *gin.RouterGroup) <span class="cov8" title="1">{
        router.POST("/translate/string", h.HandleTranslateString)
        router.POST("/translate/directory", h.HandleTranslateDirectory)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package api

import (
        "context"
        "digital.vasic.translator/internal/cache"
        "digital.vasic.translator/internal/config"
        "digital.vasic.translator/pkg/distributed"
        "digital.vasic.translator/pkg/ebook"
        "digital.vasic.translator/pkg/events"
        "digital.vasic.translator/pkg/language"
        "digital.vasic.translator/pkg/preparation"
        "digital.vasic.translator/pkg/script"
        "digital.vasic.translator/pkg/security"
        "digital.vasic.translator/pkg/translator"
        "digital.vasic.translator/pkg/translator/llm"
        "digital.vasic.translator/pkg/websocket"
        "fmt"
        "io"
        "log"
        "net/http"
        "os"
        "os/exec"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        gorillaws "github.com/gorilla/websocket"
)

// Handler handles API requests
type Handler struct {
        config             *config.Config
        eventBus           *events.EventBus
        cache              *cache.Cache
        authService        *security.AuthService
        wsHub              *websocket.Hub
        distributedManager interface{} // Will be *distributed.DistributedManager
}

// NewHandler creates a new API handler
func NewHandler(
        cfg *config.Config,
        eventBus *events.EventBus,
        cache *cache.Cache,
        authService *security.AuthService,
        wsHub *websocket.Hub,
        distributedManager interface{},
) *Handler <span class="cov8" title="1">{
        return &amp;Handler{
                config:             cfg,
                eventBus:           eventBus,
                cache:              cache,
                authService:        authService,
                wsHub:              wsHub,
                distributedManager: distributedManager,
        }
}</span>

// RegisterRoutes registers all API routes
func (h *Handler) RegisterRoutes(router *gin.Engine) <span class="cov8" title="1">{
        // Health check
        router.GET("/health", h.healthCheck)
        router.GET("/", h.apiInfo)

        // WebSocket endpoint
        router.GET("/ws", h.websocketHandler)

        // API v1 routes
        v1 := router.Group("/api/v1")
        </span><span class="cov8" title="1">{
                // Translation endpoints
                v1.POST("/translate", h.translateText)
                v1.POST("/translate/fb2", h.translateFB2)
                v1.POST("/translate/batch", h.batchTranslate)

                // Script conversion
                v1.POST("/convert/script", h.convertScript)

                // Status and info
                v1.GET("/status/:session_id", h.getStatus)
                v1.GET("/version", h.getVersion)
                v1.GET("/providers", h.listProviders)
                v1.GET("/stats", h.getStats)
                v1.GET("/languages", h.listLanguages)

                // Translation validation
                v1.POST("/translate/validate", h.validateTranslationRequest)

                // Preparation endpoints
                v1.POST("/preparation/analyze", h.preparationAnalysis)
                v1.GET("/preparation/result/:session_id", h.getPreparationResult)

                // Additional translation endpoints
                v1.POST("/translate/ebook", h.translateEbook)
                v1.POST("/translate/cancel/:session_id", h.cancelTranslation)

                // Distributed work endpoints
                if true </span><span class="cov8" title="1">{ // h.config.Distributed.Enabled
                        v1.GET("/distributed/status", h.getDistributedStatus)
                        v1.POST("/distributed/workers/discover", h.discoverWorkers)
                        v1.POST("/distributed/workers/:worker_id/pair", h.pairWorker)
                        v1.DELETE("/distributed/workers/:worker_id/pair", h.unpairWorker)
                        v1.POST("/distributed/translate", h.translateDistributed)

                        // Update endpoints for workers
                        v1.POST("/update/upload", h.uploadUpdate)
                        v1.POST("/update/apply", h.applyUpdate)
                        v1.POST("/update/rollback", h.rollbackUpdate)

                        // Version management monitoring endpoints
                        v1.GET("/monitoring/version/metrics", h.getVersionMetrics)
                        v1.GET("/monitoring/version/alerts", h.getVersionAlerts)
                        v1.GET("/monitoring/version/health", h.getVersionHealth)
                        v1.GET("/monitoring/version/dashboard", h.getVersionDashboard)
                        v1.POST("/monitoring/version/drift-check", h.triggerVersionDriftCheck)
                        v1.GET("/monitoring/version/alerts/history", h.getAlertHistory)
                        v1.POST("/monitoring/version/alerts/:alert_id/acknowledge", h.acknowledgeAlert)
                        v1.POST("/monitoring/version/alerts/channels/email", h.addEmailAlertChannel)
                        v1.POST("/monitoring/version/alerts/channels/webhook", h.addWebhookAlertChannel)
                        v1.POST("/monitoring/version/alerts/channels/slack", h.addSlackAlertChannel)
                        v1.GET("/monitoring/version/dashboard.html", h.serveDashboard)
                }</span>

                // Register batch processing routes
                <span class="cov8" title="1">h.RegisterBatchRoutes(v1)

                // Authentication (if enabled)
                if h.config.Security.EnableAuth </span><span class="cov0" title="0">{
                        v1.POST("/auth/login", h.login)
                        v1.POST("/auth/token", h.generateToken)

                        // Protected routes
                        protected := v1.Group("/")
                        protected.Use(h.authMiddleware())
                        </span><span class="cov0" title="0">{
                                protected.GET("/profile", h.getProfile)
                        }</span>
                }
        }
}

// healthCheck handles health check requests
func (h *Handler) healthCheck(c *gin.Context) <span class="cov8" title="1">{
        c.JSON(http.StatusOK, gin.H{
                "status":  "healthy",
                "version": "1.0.0",
                "time":    time.Now().UTC(),
        })
}</span>

// apiInfo provides API information
func (h *Handler) apiInfo(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "name":        "Universal Multi-Format Multi-Language Ebook Translation API",
                "version":     "1.0.0",
                "description": "High-quality universal ebook translation service supporting 100+ languages and multiple formats",
                "endpoints": gin.H{
                        "health":       "GET /health",
                        "websocket":    "GET /ws",
                        "translate":    "POST /api/v1/translate",
                        "translateFB2": "POST /api/v1/translate/fb2",
                        "providers":    "GET /api/v1/providers",
                },
                "documentation": "/api/docs",
        })
}</span>

// translateText handles text translation requests
func (h *Handler) translateText(c *gin.Context) <span class="cov0" title="0">{
        var req struct {
                Text     string `json:"text" binding:"required"`
                Provider string `json:"provider"`
                Model    string `json:"model"`
                Context  string `json:"context"`
                Script   string `json:"script"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Create translator
        <span class="cov0" title="0">trans, err := h.createTranslator(req.Provider, req.Model)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Generate session ID
        <span class="cov0" title="0">sessionID := uuid.New().String()

        // Translate - use distributed coordinator if available
        ctx := context.Background()
        var translated string

        if h.distributedManager != nil </span><span class="cov0" title="0">{
                // Try distributed translation first
                if dm, ok := h.distributedManager.(*distributed.DistributedManager); ok </span><span class="cov0" title="0">{
                        distributedResult, distributedErr := dm.TranslateDistributed(ctx, req.Text, req.Context)
                        if distributedErr == nil </span><span class="cov0" title="0">{
                                translated = distributedResult
                        }</span> else<span class="cov0" title="0"> {
                                // Fallback to local translation
                                h.eventBus.Publish(events.Event{
                                        Type:      "distributed_fallback",
                                        SessionID: sessionID,
                                        Message:   "Distributed translation failed, using local translator",
                                        Data: map[string]interface{}{
                                                "error": distributedErr.Error(),
                                        },
                                })
                                localResult, localErr := trans.TranslateWithProgress(ctx, req.Text, req.Context, h.eventBus, sessionID)
                                if localErr != nil </span><span class="cov0" title="0">{
                                        c.JSON(http.StatusInternalServerError, gin.H{"error": localErr.Error()})
                                        return
                                }</span>
                                <span class="cov0" title="0">translated = localResult</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Type assertion failed, use local translator
                        localResult, localErr := trans.TranslateWithProgress(ctx, req.Text, req.Context, h.eventBus, sessionID)
                        if localErr != nil </span><span class="cov0" title="0">{
                                c.JSON(http.StatusInternalServerError, gin.H{"error": localErr.Error()})
                                return
                        }</span>
                        <span class="cov0" title="0">translated = localResult</span>
                }
        } else<span class="cov0" title="0"> {
                // Use local translator
                localResult, localErr := trans.TranslateWithProgress(ctx, req.Text, req.Context, h.eventBus, sessionID)
                if localErr != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": localErr.Error()})
                        return
                }</span>
                <span class="cov0" title="0">translated = localResult</span>
        }

        // Convert script if requested
        <span class="cov0" title="0">if req.Script == "latin" </span><span class="cov0" title="0">{
                converter := script.NewConverter()
                translated = converter.ToLatin(translated)
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "original":   req.Text,
                "translated": translated,
                "provider":   trans.GetName(),
                "session_id": sessionID,
                "stats":      trans.GetStats(),
        })</span>
}

// translateFB2 handles FB2 file translation
func (h *Handler) translateFB2(c *gin.Context) <span class="cov0" title="0">{
        // Parse multipart form
        file, header, err := c.Request.FormFile("file")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "No file provided"})
                return
        }</span>
        <span class="cov0" title="0">defer file.Close()

        provider := c.PostForm("provider")
        if provider == "" </span><span class="cov0" title="0">{
                provider = "openai"
        }</span>

        <span class="cov0" title="0">model := c.PostForm("model")
        scriptType := c.PostForm("script")
        if scriptType == "" </span><span class="cov0" title="0">{
                scriptType = "cyrillic"
        }</span>

        // Generate session ID
        <span class="cov0" title="0">sessionID := uuid.New().String()

        // Emit start event
        startEvent := events.NewEvent(
                events.EventTranslationStarted,
                "FB2 translation started",
                map[string]interface{}{
                        "filename": header.Filename,
                        "provider": provider,
                },
        )
        startEvent.SessionID = sessionID
        h.eventBus.Publish(startEvent)

        // Save file to temp location for parsing
        tempFile, err := os.CreateTemp("", "ebook-*")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("Failed to create temp file: %v", err)})
                return
        }</span>
        <span class="cov0" title="0">defer os.Remove(tempFile.Name())
        defer tempFile.Close()

        _, err = io.Copy(tempFile, file)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("Failed to save temp file: %v", err)})
                return
        }</span>
        <span class="cov0" title="0">tempFile.Close()

        // Parse ebook
        parser := ebook.NewUniversalParser()
        book, err := parser.Parse(tempFile.Name())
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("Failed to parse ebook: %v", err)})
                return
        }</span>

        // Create translator
        <span class="cov0" title="0">baseTrans, err := h.createTranslator(provider, model)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Translate
        <span class="cov0" title="0">ctx := context.Background()

        if h.config.Preparation.Enabled </span><span class="cov0" title="0">{
                // Use preparation-aware translation
                langDetector := language.NewDetector(nil) // Use heuristic detection

                // Create preparation config
                prepConfig := preparation.PreparationConfig{
                        PassCount:          h.config.Preparation.PassCount,
                        Providers:          h.config.Preparation.Providers,
                        AnalyzeContentType: h.config.Preparation.AnalyzeContentType,
                        AnalyzeCharacters:  h.config.Preparation.AnalyzeCharacters,
                        AnalyzeTerminology: h.config.Preparation.AnalyzeTerminology,
                        AnalyzeCulture:     h.config.Preparation.AnalyzeCulture,
                        AnalyzeChapters:    h.config.Preparation.AnalyzeChapters,
                        DetailLevel:        h.config.Preparation.DetailLevel,
                        SourceLanguage:     "auto", // Auto-detect source language
                        TargetLanguage:     "en",   // Default target language (configurable)
                }

                // Create preparation-aware translator
                sourceLang := language.Language{Code: "ru", Name: "Russian"}
                targetLang := language.Language{Code: "sr", Name: "Serbian"}
                prepTrans := preparation.NewPreparationAwareTranslator(
                        baseTrans,
                        langDetector,
                        sourceLang,
                        targetLang,
                        &amp;prepConfig,
                )

                if err := prepTrans.TranslateBook(ctx, book, h.eventBus, sessionID); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                        return
                }</span>

                // Save preparation analysis
                <span class="cov0" title="0">bookBasename := strings.TrimSuffix(header.Filename, filepath.Ext(header.Filename))
                prepAnalysisPath := filepath.Join(filepath.Dir(tempFile.Name()), bookBasename+"_preparation.json")
                if err := prepTrans.SavePreparationAnalysis(prepAnalysisPath); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Failed to save preparation analysis: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("Preparation analysis saved to: %s", prepAnalysisPath)
                }</span>
        } else<span class="cov0" title="0"> {
                // Use standard translation
                if err := h.translateBook(ctx, book, baseTrans, sessionID); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                        return
                }</span>
        }

        // Convert script if needed
        // if scriptType == "latin" {
        //         converter := script.NewConverter()
        //         h.convertBookToLatin(book, converter)
        // }

        // Update metadata
        <span class="cov0" title="0">book.Language = "sr"

        // Generate output filename
        outputFilename := generateOutputFilename(header.Filename, provider)

        // Create temp file for output
        tempOutput, err := os.CreateTemp("", "output-*")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("Failed to create temp output: %v", err)})
                return
        }</span>
        <span class="cov0" title="0">defer os.Remove(tempOutput.Name())
        defer tempOutput.Close()

        // Write ebook to temp file
        writer := ebook.NewEPUBWriter()
        if err := writer.Write(book, tempOutput.Name()); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("Failed to write ebook: %v", err)})
                return
        }</span>

        // Read the temp file
        <span class="cov0" title="0">tempOutput.Seek(0, 0)
        data, err := io.ReadAll(tempOutput)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("Failed to read output: %v", err)})
                return
        }</span>

        // Set headers for file download
        <span class="cov0" title="0">c.Header("Content-Description", "File Transfer")
        c.Header("Content-Disposition", fmt.Sprintf("attachment; filename=%s", outputFilename))
        c.Header("Content-Type", "application/epub+zip")

        // Write data to response
        c.Data(http.StatusOK, "application/epub+zip", data)

        // Emit completion event
        completeEvent := events.NewEvent(
                events.EventTranslationCompleted,
                "FB2 translation completed",
                map[string]interface{}{
                        "filename": outputFilename,
                        "stats":    baseTrans.GetStats(),
                },
        )
        completeEvent.SessionID = sessionID
        h.eventBus.Publish(completeEvent)</span>
}

// batchTranslate handles batch translation requests
func (h *Handler) batchTranslate(c *gin.Context) <span class="cov8" title="1">{
        var req struct {
                Texts    []string `json:"texts" binding:"required"`
                Provider string   `json:"provider"`
                Model    string   `json:"model"`
                Context  string   `json:"context"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Create translator
        <span class="cov8" title="1">trans, err := h.createTranslator(req.Provider, req.Model)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Generate session ID
        <span class="cov0" title="0">sessionID := uuid.New().String()

        // Translate all texts
        ctx := context.Background()
        results := make([]string, len(req.Texts))

        for i, text := range req.Texts </span><span class="cov0" title="0">{
                translated, err := trans.TranslateWithProgress(ctx, text, req.Context, h.eventBus, sessionID)
                if err != nil </span><span class="cov0" title="0">{
                        results[i] = fmt.Sprintf("[ERROR: %v]", err)
                }</span> else<span class="cov0" title="0"> {
                        results[i] = translated
                }</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "originals":  req.Texts,
                "translated": results,
                "provider":   trans.GetName(),
                "session_id": sessionID,
                "stats":      trans.GetStats(),
        })</span>
}

// convertScript handles script conversion
func (h *Handler) convertScript(c *gin.Context) <span class="cov0" title="0">{
        var req struct {
                Text   string `json:"text" binding:"required"`
                Target string `json:"target" binding:"required"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">converter := script.NewConverter()
        var result string

        switch req.Target </span>{
        case "latin":<span class="cov0" title="0">
                result = converter.ToLatin(req.Text)</span>
        case "cyrillic":<span class="cov0" title="0">
                result = converter.ToCyrillic(req.Text)</span>
        default:<span class="cov0" title="0">
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid target script"})
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "original":  req.Text,
                "converted": result,
                "target":    req.Target,
        })</span>
}

// getStatus returns translation status for a session
func (h *Handler) getStatus(c *gin.Context) <span class="cov8" title="1">{
        sessionID := c.Param("session_id")

        c.JSON(http.StatusOK, gin.H{
                "session_id": sessionID,
                "status":     "completed", // In a real implementation, track session status
        })
}</span>

// listProviders lists available translation providers
func (h *Handler) listProviders(c *gin.Context) <span class="cov8" title="1">{
        providers := []gin.H{
                {
                        "name":             "openai",
                        "description":      "OpenAI GPT models",
                        "requires_api_key": true,
                        "models":           []string{"gpt-4", "gpt-3.5-turbo"},
                },
                {
                        "name":             "anthropic",
                        "description":      "Anthropic Claude models",
                        "requires_api_key": true,
                        "models":           []string{"claude-3-sonnet-20240229", "claude-3-opus-20240229"},
                },
                {
                        "name":             "zhipu",
                        "description":      "Zhipu AI GLM models",
                        "requires_api_key": true,
                        "models":           []string{"glm-4"},
                },
                {
                        "name":             "deepseek",
                        "description":      "DeepSeek Chat models",
                        "requires_api_key": true,
                        "models":           []string{"deepseek-chat"},
                },
                {
                        "name":             "ollama",
                        "description":      "Local Ollama models",
                        "requires_api_key": false,
                        "models":           []string{"llama3:8b", "llama2:13b"},
                },
                {
                        "name":             "llamacpp",
                        "description":      "Local Llama.cpp models",
                        "requires_api_key": false,
                        "models":           []string{"llama-3.2-3b-instruct"},
                },
        }

        c.JSON(http.StatusOK, gin.H{
                "providers": providers,
        })
}</span>

// getVersion returns version information
func (h *Handler) getVersion(c *gin.Context) <span class="cov0" title="0">{
        version := distributed.VersionInfo{
                CodebaseVersion: getCodebaseVersion(),
                BuildTime:       getBuildTime(),
                GitCommit:       getGitCommit(),
                GoVersion:       getGoVersion(),
                Components:      make(map[string]string),
                LastUpdated:     time.Now(),
        }

        // Add component versions
        version.Components["translator"] = version.CodebaseVersion
        version.Components["api"] = "1.0.0"
        version.Components["distributed"] = "1.0.0"
        version.Components["deployment"] = "1.0.0"

        c.JSON(http.StatusOK, version)
}</span>

// Helper functions for version information

// getCodebaseVersion returns the current codebase version
func getCodebaseVersion() string <span class="cov0" title="0">{
        // Try to read from version file first
        if version, err := readVersionFile("VERSION"); err == nil </span><span class="cov0" title="0">{
                return strings.TrimSpace(version)
        }</span>

        // Try git describe
        <span class="cov0" title="0">if version, err := runCommand("git", "describe", "--tags", "--abbrev=0"); err == nil </span><span class="cov0" title="0">{
                return strings.TrimSpace(version)
        }</span>

        // Try git rev-parse
        <span class="cov0" title="0">if commit, err := runCommand("git", "rev-parse", "--short", "HEAD"); err == nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("dev-%s", strings.TrimSpace(commit))
        }</span>

        <span class="cov0" title="0">return "unknown"</span>
}

// getBuildTime returns the build timestamp
func getBuildTime() string <span class="cov0" title="0">{
        if buildTime, err := runCommand("date", "-u", "+%Y-%m-%dT%H:%M:%SZ"); err == nil </span><span class="cov0" title="0">{
                return strings.TrimSpace(buildTime)
        }</span>
        <span class="cov0" title="0">return time.Now().UTC().Format(time.RFC3339)</span>
}

// getGitCommit returns the current git commit hash
func getGitCommit() string <span class="cov0" title="0">{
        if commit, err := runCommand("git", "rev-parse", "HEAD"); err == nil </span><span class="cov0" title="0">{
                return strings.TrimSpace(commit)
        }</span>
        <span class="cov0" title="0">return "unknown"</span>
}

// getGoVersion returns the Go version used to build
func getGoVersion() string <span class="cov0" title="0">{
        if version, err := runCommand("go", "version"); err == nil </span><span class="cov0" title="0">{
                parts := strings.Split(version, " ")
                if len(parts) &gt;= 3 </span><span class="cov0" title="0">{
                        return parts[2]
                }</span>
        }
        <span class="cov0" title="0">return "unknown"</span>
}

// readVersionFile reads version from a file
func readVersionFile(filename string) (string, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return string(data), nil</span>
}

// runCommand executes a shell command and returns its output
func runCommand(name string, args ...string) (string, error) <span class="cov0" title="0">{
        cmd := exec.Command(name, args...)
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return string(output), nil</span>
}

// getStats returns API statistics
func (h *Handler) getStats(c *gin.Context) <span class="cov0" title="0">{
        cacheStats := h.cache.Stats()

        c.JSON(http.StatusOK, gin.H{
                "cache": cacheStats,
                "websocket": gin.H{
                        "connected_clients": h.wsHub.GetClientCount(),
                },
        })
}</span>

// websocketHandler handles WebSocket connections
func (h *Handler) websocketHandler(c *gin.Context) <span class="cov8" title="1">{
        upgrader := gorillaws.Upgrader{
                CheckOrigin: func(r *http.Request) bool </span><span class="cov8" title="1">{
                        return true // Configure properly in production
                }</span>,
        }

        <span class="cov8" title="1">conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov0" title="0">sessionID := c.Query("session_id")
        client := &amp;websocket.Client{
                ID:        uuid.New().String(),
                SessionID: sessionID,
                Conn:      conn,
                Send:      make(chan []byte, 256),
                Hub:       h.wsHub,
        }

        h.wsHub.Register(client)

        go client.WritePump()
        go client.ReadPump()</span>
}

// Helper methods

func (h *Handler) createTranslator(providerName, model string) (translator.Translator, error) <span class="cov8" title="1">{
        if providerName == "" </span><span class="cov0" title="0">{
                providerName = h.config.Translation.DefaultProvider
        }</span>

        // Handle distributed provider specially
        <span class="cov8" title="1">if providerName == "distributed" </span><span class="cov0" title="0">{
                if h.distributedManager == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("distributed translation not available")
                }</span>
                // Return a special distributed translator wrapper
                <span class="cov0" title="0">return &amp;distributedTranslator{dm: h.distributedManager.(*distributed.DistributedManager)}, nil</span>
        }

        <span class="cov8" title="1">config := translator.TranslationConfig{
                SourceLang: "ru",
                TargetLang: "sr",
                Provider:   providerName,
                Model:      model,
                Options:    make(map[string]interface{}),
        }

        // Load provider config
        if providerCfg, ok := h.config.Translation.Providers[providerName]; ok </span><span class="cov0" title="0">{
                config.APIKey = providerCfg.APIKey
                config.BaseURL = providerCfg.BaseURL
                if model == "" </span><span class="cov0" title="0">{
                        config.Model = providerCfg.Model
                }</span>
                <span class="cov0" title="0">config.Options = providerCfg.Options</span>
        }

        <span class="cov8" title="1">return llm.NewLLMTranslator(config)</span>
}

// distributedTranslator wraps the distributed manager to implement translator.Translator interface
type distributedTranslator struct {
        dm *distributed.DistributedManager
}

func (dt *distributedTranslator) Translate(ctx context.Context, text, contextHint string) (string, error) <span class="cov0" title="0">{
        return dt.dm.TranslateDistributed(ctx, text, contextHint)
}</span>

func (dt *distributedTranslator) TranslateWithProgress(ctx context.Context, text, contextHint string, eventBus *events.EventBus, sessionID string) (string, error) <span class="cov0" title="0">{
        // For now, just call Translate - progress events could be added later
        return dt.Translate(ctx, text, contextHint)
}</span>

func (dt *distributedTranslator) GetStats() translator.TranslationStats <span class="cov0" title="0">{
        // Return empty stats for now
        return translator.TranslationStats{}
}</span>

func (dt *distributedTranslator) GetName() string <span class="cov0" title="0">{
        return "distributed"
}</span>

func (h *Handler) translateBook(ctx context.Context, book *ebook.Book, trans translator.Translator, sessionID string) error <span class="cov0" title="0">{
        // Translate title
        if book.Metadata.Title != "" </span><span class="cov0" title="0">{
                translated, err := trans.TranslateWithProgress(
                        ctx,
                        book.Metadata.Title,
                        "Book title",
                        h.eventBus,
                        sessionID,
                )
                if err == nil </span><span class="cov0" title="0">{
                        book.Metadata.Title = translated
                }</span>
        }

        // Translate chapters
        <span class="cov0" title="0">for i := range book.Chapters </span><span class="cov0" title="0">{
                // Translate chapter title
                if book.Chapters[i].Title != "" </span><span class="cov0" title="0">{
                        translated, err := trans.TranslateWithProgress(
                                ctx,
                                book.Chapters[i].Title,
                                "Chapter title",
                                h.eventBus,
                                sessionID,
                        )
                        if err == nil </span><span class="cov0" title="0">{
                                book.Chapters[i].Title = translated
                        }</span>
                }

                // Translate sections
                <span class="cov0" title="0">for j := range book.Chapters[i].Sections </span><span class="cov0" title="0">{
                        if err := h.translateEbookSection(ctx, &amp;book.Chapters[i].Sections[j], trans, sessionID); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (h *Handler) translateEbookSection(ctx context.Context, section *ebook.Section, trans translator.Translator, sessionID string) error <span class="cov0" title="0">{
        // Translate title
        if section.Title != "" </span><span class="cov0" title="0">{
                translated, err := trans.TranslateWithProgress(
                        ctx,
                        section.Title,
                        "Section title",
                        h.eventBus,
                        sessionID,
                )
                if err == nil </span><span class="cov0" title="0">{
                        section.Title = translated
                }</span>
        }

        // Translate content
        <span class="cov0" title="0">if section.Content != "" </span><span class="cov0" title="0">{
                translated, err := trans.TranslateWithProgress(
                        ctx,
                        section.Content,
                        "Section content",
                        h.eventBus,
                        sessionID,
                )
                if err == nil </span><span class="cov0" title="0">{
                        section.Content = translated
                }</span>
        }

        // Translate subsections recursively
        <span class="cov0" title="0">for i := range section.Subsections </span><span class="cov0" title="0">{
                if err := h.translateEbookSection(ctx, &amp;section.Subsections[i], trans, sessionID); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func generateOutputFilename(inputFilename, provider string) string <span class="cov8" title="1">{
        ext := filepath.Ext(inputFilename)
        base := inputFilename[:len(inputFilename)-len(ext)]
        return fmt.Sprintf("%s_sr_%s%s", base, provider, ext)
}</span>

// Authentication middleware
func (h *Handler) authMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                authHeader := c.GetHeader("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "No authorization header"})
                        c.Abort()
                        return
                }</span>

                // Extract token
                <span class="cov0" title="0">token := authHeader
                if len(authHeader) &gt; 7 &amp;&amp; authHeader[:7] == "Bearer " </span><span class="cov0" title="0">{
                        token = authHeader[7:]
                }</span>

                // Validate token
                <span class="cov0" title="0">claims, err := h.authService.ValidateToken(token)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token"})
                        c.Abort()
                        return
                }</span>

                // Set user info in context
                <span class="cov0" title="0">c.Set("user_id", claims.UserID)
                c.Set("username", claims.Username)
                c.Set("roles", claims.Roles)

                c.Next()</span>
        }
}

// Authentication handlers
func (h *Handler) login(c *gin.Context) <span class="cov0" title="0">{
        var req struct {
                Username string `json:"username" binding:"required"`
                Password string `json:"password" binding:"required"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // In a real implementation, validate credentials against database
        // This is a placeholder
        <span class="cov0" title="0">userID := uuid.New().String()

        token, err := h.authService.GenerateToken(userID, req.Username, []string{"user"})
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to generate token"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "token":    token,
                "user_id":  userID,
                "username": req.Username,
        })</span>
}

func (h *Handler) generateToken(c *gin.Context) <span class="cov0" title="0">{
        var req struct {
                UserID   string   `json:"user_id" binding:"required"`
                Username string   `json:"username" binding:"required"`
                Roles    []string `json:"roles"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">token, err := h.authService.GenerateToken(req.UserID, req.Username, req.Roles)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to generate token"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "token": token,
        })</span>
}

func (h *Handler) getProfile(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("user_id")
        username := c.GetString("username")
        roles, _ := c.Get("roles")

        c.JSON(http.StatusOK, gin.H{
                "user_id":  userID,
                "username": username,
                "roles":    roles,
        })
}</span>

// Distributed work handlers

func (h *Handler) getDistributedStatus(c *gin.Context) <span class="cov0" title="0">{
        if h.distributedManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, gin.H{"error": "Distributed work not available"})
                return
        }</span>

        // Type assertion to access methods
        <span class="cov0" title="0">dm, ok := h.distributedManager.(*distributed.DistributedManager)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid distributed manager"})
                return
        }</span>

        <span class="cov0" title="0">status := dm.GetStatus()
        c.JSON(http.StatusOK, status)</span>
}

func (h *Handler) discoverWorkers(c *gin.Context) <span class="cov0" title="0">{
        if h.distributedManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, gin.H{"error": "Distributed work not available"})
                return
        }</span>

        <span class="cov0" title="0">dm, ok := h.distributedManager.(*distributed.DistributedManager)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid distributed manager"})
                return
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
        defer cancel()

        if err := dm.DiscoverAndPairWorkers(ctx); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Worker discovery completed"})</span>
}

func (h *Handler) pairWorker(c *gin.Context) <span class="cov0" title="0">{
        if h.distributedManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, gin.H{"error": "Distributed work not available"})
                return
        }</span>

        <span class="cov0" title="0">workerID := c.Param("worker_id")
        if workerID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Worker ID is required"})
                return
        }</span>

        <span class="cov0" title="0">dm, ok := h.distributedManager.(*distributed.DistributedManager)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid distributed manager"})
                return
        }</span>

        <span class="cov0" title="0">if err := dm.PairWorker(workerID); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": fmt.Sprintf("Successfully paired with worker %s", workerID)})</span>
}

func (h *Handler) unpairWorker(c *gin.Context) <span class="cov0" title="0">{
        if h.distributedManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, gin.H{"error": "Distributed work not available"})
                return
        }</span>

        <span class="cov0" title="0">workerID := c.Param("worker_id")
        if workerID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Worker ID is required"})
                return
        }</span>

        <span class="cov0" title="0">dm, ok := h.distributedManager.(*distributed.DistributedManager)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid distributed manager"})
                return
        }</span>

        <span class="cov0" title="0">if err := dm.UnpairWorker(workerID); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": fmt.Sprintf("Successfully unpaired from worker %s", workerID)})</span>
}

func (h *Handler) translateDistributed(c *gin.Context) <span class="cov0" title="0">{
        if h.distributedManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, gin.H{"error": "Distributed work not available"})
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                Text        string `json:"text" binding:"required"`
                ContextHint string `json:"context_hint,omitempty"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">dm, ok := h.distributedManager.(*distributed.DistributedManager)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid distributed manager"})
                return
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
        defer cancel()

        sessionID := c.GetHeader("X-Session-ID")
        if sessionID == "" </span><span class="cov0" title="0">{
                sessionID = uuid.New().String()
        }</span>

        <span class="cov0" title="0">translated, err := dm.TranslateDistributed(ctx, req.Text, req.ContextHint)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "translated_text": translated,
                "session_id":      sessionID,
        })</span>
}

// uploadUpdate handles update package uploads
func (h *Handler) uploadUpdate(c *gin.Context) <span class="cov0" title="0">{
        // Get the uploaded file
        file, err := c.FormFile("update_package")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "No update package provided"})
                return
        }</span>

        // Get version from header
        <span class="cov0" title="0">version := c.GetHeader("X-Update-Version")
        if version == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Update version not specified"})
                return
        }</span>

        // Save the update package
        <span class="cov0" title="0">updateDir := "/tmp/translator-updates"
        if err := os.MkdirAll(updateDir, 0755); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create update directory"})
                return
        }</span>

        <span class="cov0" title="0">updatePath := filepath.Join(updateDir, fmt.Sprintf("update-%s.tar.gz", version))
        if err := c.SaveUploadedFile(file, updatePath); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to save update package"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "message": "Update package uploaded successfully",
                "version": version,
                "path":    updatePath,
        })</span>
}

// applyUpdate applies a previously uploaded update
func (h *Handler) applyUpdate(c *gin.Context) <span class="cov0" title="0">{
        // Get version from header
        version := c.GetHeader("X-Update-Version")
        if version == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Update version not specified"})
                return
        }</span>

        // For security, this should be a very controlled process
        // In a real implementation, you'd want extensive validation

        <span class="cov0" title="0">updatePath := filepath.Join("/tmp/translator-updates", fmt.Sprintf("update-%s.tar.gz", version))

        // Check if update package exists
        if _, err := os.Stat(updatePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Update package not found"})
                return
        }</span>

        // Extract and apply the update
        // This is a simplified version - in production you'd want rollback capabilities
        <span class="cov0" title="0">if err := applyUpdatePackage(updatePath); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("Failed to apply update: %v", err)})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "message": "Update applied successfully",
                "version": version,
        })</span>
}

// applyUpdatePackage extracts and applies an update package
func applyUpdatePackage(updatePath string) error <span class="cov0" title="0">{
        // Create backup of current binary
        backupPath := "/tmp/translator-server.backup"
        if _, err := runCommand("cp", "/usr/local/bin/translator-server", backupPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create backup: %v", err)
        }</span>

        // Extract update package
        <span class="cov0" title="0">extractDir := "/tmp/translator-update-extract"
        if err := os.MkdirAll(extractDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create extract directory: %v", err)
        }</span>

        <span class="cov0" title="0">if _, err := runCommand("tar", "-xzf", updatePath, "-C", extractDir); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to extract update package: %v", err)
        }</span>

        // Find and install new binary
        <span class="cov0" title="0">newBinary := filepath.Join(extractDir, "translator-server")
        if _, err := os.Stat(newBinary); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("new binary not found in update package")
        }</span>

        // Install new binary
        <span class="cov0" title="0">if _, err := runCommand("cp", newBinary, "/usr/local/bin/translator-server"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to install new binary: %v", err)
        }</span>

        // Make sure it's executable
        <span class="cov0" title="0">if _, err := runCommand("chmod", "+x", "/usr/local/bin/translator-server"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to make binary executable: %v", err)
        }</span>

        // Clean up
        <span class="cov0" title="0">os.RemoveAll(extractDir)

        return nil</span>
}

// rollbackUpdate handles manual rollback requests
func (h *Handler) rollbackUpdate(c *gin.Context) <span class="cov0" title="0">{
        if h.distributedManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, gin.H{"error": "Distributed work not available"})
                return
        }</span>

        <span class="cov0" title="0">dm, ok := h.distributedManager.(*distributed.DistributedManager)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid distributed manager"})
                return
        }</span>

        // Get worker ID from header or query param
        <span class="cov0" title="0">workerID := c.GetHeader("X-Worker-ID")
        if workerID == "" </span><span class="cov0" title="0">{
                workerID = c.Query("worker_id")
        }</span>
        <span class="cov0" title="0">if workerID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Worker ID is required"})
                return
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
        defer cancel()

        // Get the worker service
        worker := dm.GetWorkerByID(workerID)
        if worker == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Worker not found"})
                return
        }</span>

        // Perform rollback
        <span class="cov0" title="0">if err := dm.RollbackWorker(ctx, worker); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "message":   "Worker rollback completed successfully",
                "worker_id": workerID,
        })</span>
}

// Version Management Monitoring Handlers

// getVersionMetrics returns comprehensive version management metrics
func (h *Handler) getVersionMetrics(c *gin.Context) <span class="cov0" title="0">{
        if h.distributedManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, gin.H{"error": "Distributed work not available"})
                return
        }</span>

        <span class="cov0" title="0">dm, ok := h.distributedManager.(*distributed.DistributedManager)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid distributed manager"})
                return
        }</span>

        <span class="cov0" title="0">metrics := dm.GetVersionMetrics()
        c.JSON(http.StatusOK, metrics)</span>
}

// getVersionAlerts returns current version drift alerts
func (h *Handler) getVersionAlerts(c *gin.Context) <span class="cov0" title="0">{
        if h.distributedManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, gin.H{"error": "Distributed work not available"})
                return
        }</span>

        <span class="cov0" title="0">dm, ok := h.distributedManager.(*distributed.DistributedManager)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid distributed manager"})
                return
        }</span>

        <span class="cov0" title="0">alerts := dm.GetVersionAlerts()

        // Filter alerts by severity if requested
        severity := c.Query("severity")
        if severity != "" </span><span class="cov0" title="0">{
                filtered := make([]*distributed.DriftAlert, 0)
                for _, alert := range alerts </span><span class="cov0" title="0">{
                        if alert.Severity == severity </span><span class="cov0" title="0">{
                                filtered = append(filtered, alert)
                        }</span>
                }
                <span class="cov0" title="0">alerts = filtered</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "alerts": alerts,
                "count":  len(alerts),
        })</span>
}

// getVersionHealth returns overall version management health status
func (h *Handler) getVersionHealth(c *gin.Context) <span class="cov0" title="0">{
        if h.distributedManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, gin.H{"error": "Distributed work not available"})
                return
        }</span>

        <span class="cov0" title="0">dm, ok := h.distributedManager.(*distributed.DistributedManager)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid distributed manager"})
                return
        }</span>

        <span class="cov0" title="0">health := dm.GetVersionHealth()
        c.JSON(http.StatusOK, health)</span>
}

// getVersionDashboard returns dashboard data for version management visualization
func (h *Handler) getVersionDashboard(c *gin.Context) <span class="cov0" title="0">{
        if h.distributedManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, gin.H{"error": "Distributed work not available"})
                return
        }</span>

        <span class="cov0" title="0">dm, ok := h.distributedManager.(*distributed.DistributedManager)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid distributed manager"})
                return
        }</span>

        // Get all dashboard data
        <span class="cov0" title="0">metrics := dm.GetVersionMetrics()
        alerts := dm.GetVersionAlerts()
        health := dm.GetVersionHealth()
        status := dm.GetStatus()

        // Get worker version details
        workers := make([]gin.H, 0)
        if pairedServices := dm.GetPairedServices(); pairedServices != nil </span><span class="cov0" title="0">{
                for workerID, service := range pairedServices </span><span class="cov0" title="0">{
                        workers = append(workers, gin.H{
                                "worker_id":      workerID,
                                "host":           service.Host,
                                "port":           service.Port,
                                "protocol":       service.Protocol,
                                "status":         service.Status,
                                "version":        service.Version.CodebaseVersion,
                                "last_seen":      service.LastSeen,
                                "last_updated":   service.Version.LastUpdated,
                                "drift_duration": time.Since(service.Version.LastUpdated),
                        })
                }</span>
        }

        // Calculate summary statistics
        <span class="cov0" title="0">totalWorkers := len(workers)
        upToDateWorkers := 0
        outdatedWorkers := 0
        unhealthyWorkers := 0

        for _, worker := range workers </span><span class="cov0" title="0">{
                status := worker["status"].(string)
                switch status </span>{
                case "paired":<span class="cov0" title="0">
                        upToDateWorkers++</span>
                case "outdated":<span class="cov0" title="0">
                        outdatedWorkers++</span>
                default:<span class="cov0" title="0">
                        unhealthyWorkers++</span>
                }
        }

        <span class="cov0" title="0">dashboard := gin.H{
                "summary": gin.H{
                        "total_workers":      totalWorkers,
                        "up_to_date_workers": upToDateWorkers,
                        "outdated_workers":   outdatedWorkers,
                        "unhealthy_workers":  unhealthyWorkers,
                        "active_alerts":      len(alerts),
                        "health_score":       health["health_score"],
                        "last_drift_check":   metrics.LastDriftCheck,
                },
                "metrics":   metrics,
                "alerts":    alerts,
                "health":    health,
                "workers":   workers,
                "status":    status,
                "timestamp": time.Now().UTC(),
        }

        c.JSON(http.StatusOK, dashboard)</span>
}

// triggerVersionDriftCheck manually triggers a version drift check
func (h *Handler) triggerVersionDriftCheck(c *gin.Context) <span class="cov0" title="0">{
        if h.distributedManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, gin.H{"error": "Distributed work not available"})
                return
        }</span>

        <span class="cov0" title="0">dm, ok := h.distributedManager.(*distributed.DistributedManager)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid distributed manager"})
                return
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
        defer cancel()

        alerts := dm.CheckVersionDrift(ctx)

        c.JSON(http.StatusOK, gin.H{
                "message":          "Version drift check completed",
                "alerts_generated": len(alerts),
                "alerts":           alerts,
        })</span>
}

// getAlertHistory returns alert history
func (h *Handler) getAlertHistory(c *gin.Context) <span class="cov0" title="0">{
        if h.distributedManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, gin.H{"error": "Distributed work not available"})
                return
        }</span>

        <span class="cov0" title="0">dm, ok := h.distributedManager.(*distributed.DistributedManager)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid distributed manager"})
                return
        }</span>

        <span class="cov0" title="0">limitStr := c.Query("limit")
        limit := 50 // default limit
        if limitStr != "" </span><span class="cov0" title="0">{
                if l, err := strconv.Atoi(limitStr); err == nil &amp;&amp; l &gt; 0 </span><span class="cov0" title="0">{
                        limit = l
                }</span>
        }

        <span class="cov0" title="0">alerts := dm.GetAlertHistory(limit)

        c.JSON(http.StatusOK, gin.H{
                "alerts": alerts,
                "count":  len(alerts),
                "limit":  limit,
        })</span>
}

// acknowledgeAlert marks an alert as acknowledged
func (h *Handler) acknowledgeAlert(c *gin.Context) <span class="cov0" title="0">{
        if h.distributedManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, gin.H{"error": "Distributed work not available"})
                return
        }</span>

        <span class="cov0" title="0">alertID := c.Param("alert_id")
        if alertID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Alert ID is required"})
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                AcknowledgedBy string `json:"acknowledged_by" binding:"required"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">dm, ok := h.distributedManager.(*distributed.DistributedManager)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid distributed manager"})
                return
        }</span>

        <span class="cov0" title="0">if acknowledged := dm.AcknowledgeAlert(alertID, req.AcknowledgedBy); !acknowledged </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Alert not found or already acknowledged"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "message":  "Alert acknowledged successfully",
                "alert_id": alertID,
        })</span>
}

// addEmailAlertChannel adds an email alert channel
func (h *Handler) addEmailAlertChannel(c *gin.Context) <span class="cov0" title="0">{
        if h.distributedManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, gin.H{"error": "Distributed work not available"})
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                SMTPHost    string   `json:"smtp_host" binding:"required"`
                SMTPPort    int      `json:"smtp_port" binding:"required"`
                Username    string   `json:"username" binding:"required"`
                Password    string   `json:"password" binding:"required"`
                FromAddress string   `json:"from_address" binding:"required"`
                ToAddresses []string `json:"to_addresses" binding:"required,min=1"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">channel := &amp;distributed.EmailAlertChannel{
                SMTPHost:    req.SMTPHost,
                SMTPPort:    req.SMTPPort,
                Username:    req.Username,
                Password:    req.Password,
                FromAddress: req.FromAddress,
                ToAddresses: req.ToAddresses,
        }

        dm, ok := h.distributedManager.(*distributed.DistributedManager)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid distributed manager"})
                return
        }</span>

        <span class="cov0" title="0">dm.AddAlertChannel(channel)

        c.JSON(http.StatusOK, gin.H{
                "message":      "Email alert channel added successfully",
                "channel_type": "email",
                "recipients":   len(req.ToAddresses),
        })</span>
}

// addWebhookAlertChannel adds a webhook alert channel
func (h *Handler) addWebhookAlertChannel(c *gin.Context) <span class="cov0" title="0">{
        if h.distributedManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, gin.H{"error": "Distributed work not available"})
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                URL     string            `json:"url" binding:"required"`
                Method  string            `json:"method"`
                Headers map[string]string `json:"headers"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">if req.Method == "" </span><span class="cov0" title="0">{
                req.Method = "POST"
        }</span>

        <span class="cov0" title="0">channel := &amp;distributed.WebhookAlertChannel{
                URL:     req.URL,
                Method:  req.Method,
                Headers: req.Headers,
        }

        dm, ok := h.distributedManager.(*distributed.DistributedManager)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid distributed manager"})
                return
        }</span>

        <span class="cov0" title="0">dm.AddAlertChannel(channel)

        c.JSON(http.StatusOK, gin.H{
                "message":      "Webhook alert channel added successfully",
                "channel_type": "webhook",
                "url":          req.URL,
                "method":       req.Method,
        })</span>
}

// addSlackAlertChannel adds a Slack alert channel
func (h *Handler) addSlackAlertChannel(c *gin.Context) <span class="cov0" title="0">{
        if h.distributedManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, gin.H{"error": "Distributed work not available"})
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                WebhookURL string `json:"webhook_url" binding:"required"`
                Channel    string `json:"channel"`
                Username   string `json:"username"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">if req.Username == "" </span><span class="cov0" title="0">{
                req.Username = "Version Monitor"
        }</span>

        <span class="cov0" title="0">channel := &amp;distributed.SlackAlertChannel{
                WebhookURL: req.WebhookURL,
                Channel:    req.Channel,
                Username:   req.Username,
        }

        dm, ok := h.distributedManager.(*distributed.DistributedManager)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid distributed manager"})
                return
        }</span>

        <span class="cov0" title="0">dm.AddAlertChannel(channel)

        c.JSON(http.StatusOK, gin.H{
                "message":      "Slack alert channel added successfully",
                "channel_type": "slack",
                "channel":      req.Channel,
                "username":     req.Username,
        })</span>
}

// serveDashboard serves the HTML dashboard
func (h *Handler) serveDashboard(c *gin.Context) <span class="cov0" title="0">{
        dashboardPath := "pkg/api/dashboard.html"

        // Read the dashboard HTML file
        htmlContent, err := os.ReadFile(dashboardPath)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback: serve embedded dashboard if file not found
                htmlContent = []byte(h.getEmbeddedDashboardHTML())
        }</span>

        <span class="cov0" title="0">c.Header("Content-Type", "text/html; charset=utf-8")
        c.String(http.StatusOK, string(htmlContent))</span>
}

// getEmbeddedDashboardHTML returns the embedded dashboard HTML
func (h *Handler) getEmbeddedDashboardHTML() string <span class="cov0" title="0">{
        return `&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Version Management Dashboard&lt;/title&gt;
    &lt;script src="https://cdn.jsdelivr.net/npm/chart.js"&gt;&lt;/script&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; margin: 40px; background: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; }
        .header { background: #007bff; color: white; padding: 20px; border-radius: 8px; text-align: center; margin-bottom: 20px; }
        .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 20px; }
        .stat-card { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); text-align: center; }
        .stat-value { font-size: 2em; font-weight: bold; }
        .stat-label { color: #666; margin-top: 5px; }
        .alert { background: #fff3cd; border: 1px solid #ffeaa7; color: #856404; padding: 15px; border-radius: 4px; margin: 10px 0; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="header"&gt;
            &lt;h1&gt;üîÑ Version Management Dashboard&lt;/h1&gt;
            &lt;p&gt;Dashboard file not found. This is a fallback version.&lt;/p&gt;
        &lt;/div&gt;

        &lt;div class="alert"&gt;
            &lt;strong&gt;Note:&lt;/strong&gt; The full dashboard HTML file was not found. Please ensure the dashboard.html file is properly deployed.
        &lt;/div&gt;

        &lt;div class="stats"&gt;
            &lt;div class="stat-card"&gt;
                &lt;div class="stat-value" id="total-workers"&gt;-&lt;/div&gt;
                &lt;div class="stat-label"&gt;Total Workers&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="stat-card"&gt;
                &lt;div class="stat-value" id="up-to-date"&gt;-&lt;/div&gt;
                &lt;div class="stat-label"&gt;Up to Date&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="stat-card"&gt;
                &lt;div class="stat-value" id="outdated"&gt;-&lt;/div&gt;
                &lt;div class="stat-label"&gt;Outdated&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="stat-card"&gt;
                &lt;div class="stat-value" id="health-score"&gt;-&lt;/div&gt;
                &lt;div class="stat-label"&gt;Health Score&lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;button onclick="loadData()" style="padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;"&gt;Load Data&lt;/button&gt;

        &lt;div id="data" style="margin-top: 20px; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"&gt;&lt;/div&gt;
    &lt;/div&gt;

    &lt;script&gt;
        async function loadData() {
            try {
                const response = await fetch('/api/v1/monitoring/version/dashboard');
                const data = await response.json();

                document.getElementById('total-workers').textContent = data.summary.total_workers;
                document.getElementById('up-to-date').textContent = data.summary.up_to_date_workers;
                document.getElementById('outdated').textContent = data.summary.outdated_workers;
                document.getElementById('health-score').textContent = Math.round(data.summary.health_score);

                document.getElementById('data').innerHTML = '&lt;pre&gt;' + JSON.stringify(data, null, 2) + '&lt;/pre&gt;';
            } catch (error) {
                document.getElementById('data').innerHTML = '&lt;p style="color: red;"&gt;Error loading data: ' + error.message + '&lt;/p&gt;';
            }
        }
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;`
}</span>

// listLanguages returns list of supported languages
func (h *Handler) listLanguages(c *gin.Context) <span class="cov8" title="1">{
        languages := []map[string]interface{}{
                {"code": "en", "name": "English", "native": "English"},
                {"code": "es", "name": "Spanish", "native": "Espa√±ol"},
                {"code": "fr", "name": "French", "native": "Fran√ßais"},
                {"code": "de", "name": "German", "native": "Deutsch"},
                {"code": "it", "name": "Italian", "native": "Italiano"},
                {"code": "pt", "name": "Portuguese", "native": "Portugu√™s"},
                {"code": "ru", "name": "Russian", "native": "–†—É—Å—Å–∫–∏–π"},
                {"code": "zh", "name": "Chinese", "native": "‰∏≠Êñá"},
                {"code": "ja", "name": "Japanese", "native": "Êó•Êú¨Ë™û"},
                {"code": "ko", "name": "Korean", "native": "ÌïúÍµ≠Ïñ¥"},
                {"code": "ar", "name": "Arabic", "native": "ÿßŸÑÿπÿ±ÿ®Ÿäÿ©"},
                {"code": "hi", "name": "Hindi", "native": "‡§π‡§ø‡§®‡•ç‡§¶‡•Ä"},
                {"code": "tr", "name": "Turkish", "native": "T√ºrk√ße"},
                {"code": "pl", "name": "Polish", "native": "Polski"},
                {"code": "nl", "name": "Dutch", "native": "Nederlands"},
                {"code": "sv", "name": "Swedish", "native": "Svenska"},
                {"code": "da", "name": "Danish", "native": "Dansk"},
                {"code": "no", "name": "Norwegian", "native": "Norsk"},
                {"code": "fi", "name": "Finnish", "native": "Suomi"},
                {"code": "cs", "name": "Czech", "native": "ƒåe≈°tina"},
                {"code": "hu", "name": "Hungarian", "native": "Magyar"},
                {"code": "ro", "name": "Romanian", "native": "Rom√¢nƒÉ"},
                {"code": "bg", "name": "Bulgarian", "native": "–ë—ä–ª–≥–∞—Ä—Å–∫–∏"},
                {"code": "hr", "name": "Croatian", "native": "Hrvatski"},
                {"code": "sr", "name": "Serbian", "native": "–°—Ä–ø—Å–∫–∏"},
                {"code": "sk", "name": "Slovak", "native": "Slovenƒçina"},
                {"code": "sl", "name": "Slovenian", "native": "Sloven≈°ƒçina"},
                {"code": "et", "name": "Estonian", "native": "Eesti"},
                {"code": "lv", "name": "Latvian", "native": "Latvie≈°u"},
                {"code": "lt", "name": "Lithuanian", "native": "Lietuvi≈≥"},
                {"code": "el", "name": "Greek", "native": "ŒïŒªŒªŒ∑ŒΩŒπŒ∫Œ¨"},
                {"code": "he", "name": "Hebrew", "native": "◊¢◊ë◊®◊ô◊™"},
                {"code": "th", "name": "Thai", "native": "‡πÑ‡∏ó‡∏¢"},
                {"code": "vi", "name": "Vietnamese", "native": "Ti·∫øng Vi·ªát"},
                {"code": "id", "name": "Indonesian", "native": "Bahasa Indonesia"},
                {"code": "ms", "name": "Malay", "native": "Bahasa Melayu"},
                {"code": "tl", "name": "Filipino", "native": "Filipino"},
                {"code": "sw", "name": "Swahili", "native": "Kiswahili"},
                {"code": "af", "name": "Afrikaans", "native": "Afrikaans"},
                {"code": "is", "name": "Icelandic", "native": "√çslenska"},
                {"code": "mt", "name": "Maltese", "native": "Malti"},
                {"code": "cy", "name": "Welsh", "native": "Cymraeg"},
                {"code": "ga", "name": "Irish", "native": "Gaeilge"},
                {"code": "gd", "name": "Scottish Gaelic", "native": "G√†idhlig"},
                {"code": "eu", "name": "Basque", "native": "Euskara"},
                {"code": "ca", "name": "Catalan", "native": "Catal√†"},
        }

        c.JSON(http.StatusOK, gin.H{
                "languages": languages,
                "total":     len(languages),
        })
}</span>

// validateTranslationRequest validates a translation request without executing it
func (h *Handler) validateTranslationRequest(c *gin.Context) <span class="cov8" title="1">{
        var req struct {
                Text           string `json:"text" binding:"required"`
                SourceLanguage string `json:"source_language,omitempty"`
                TargetLanguage string `json:"target_language" binding:"required"`
                Provider       string `json:"provider,omitempty"`
                Model          string `json:"model,omitempty"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">validationErrors := []string{}

        // Validate target language
        _, err := language.ParseLanguage(req.TargetLanguage)
        if err != nil </span><span class="cov0" title="0">{
                validationErrors = append(validationErrors, fmt.Sprintf("invalid target language: %v", err))
        }</span>

        // Validate source language if provided
        <span class="cov8" title="1">if req.SourceLanguage != "" </span><span class="cov0" title="0">{
                _, err := language.ParseLanguage(req.SourceLanguage)
                if err != nil </span><span class="cov0" title="0">{
                        validationErrors = append(validationErrors, fmt.Sprintf("invalid source language: %v", err))
                }</span>
        }

        // Validate provider
        <span class="cov8" title="1">provider := req.Provider
        if provider == "" </span><span class="cov0" title="0">{
                provider = h.config.Translation.DefaultProvider
                if provider == "" </span><span class="cov0" title="0">{
                        provider = "openai"
                }</span>
        }

        <span class="cov8" title="1">validProviders := []string{"openai", "anthropic", "zhipu", "deepseek", "ollama", "llamacpp"}
        isValidProvider := false
        for _, p := range validProviders </span><span class="cov8" title="1">{
                if p == provider </span><span class="cov8" title="1">{
                        isValidProvider = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if !isValidProvider </span><span class="cov8" title="1">{
                validationErrors = append(validationErrors, fmt.Sprintf("unsupported provider: %s", provider))
        }</span>

        // Validate text length
        <span class="cov8" title="1">if len(req.Text) == 0 </span><span class="cov0" title="0">{
                validationErrors = append(validationErrors, "text cannot be empty")
        }</span> else<span class="cov8" title="1"> if len(req.Text) &gt; 100000 </span><span class="cov0" title="0">{
                validationErrors = append(validationErrors, "text too long (max 100,000 characters)")
        }</span>

        // Return validation result
        <span class="cov8" title="1">if len(validationErrors) &gt; 0 </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "valid":  false,
                        "errors": validationErrors,
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "valid":    true,
                "provider": provider,
                "message":  "Request is valid and ready for translation",
        })</span>
}

// preparationAnalysis analyzes content for preparation
func (h *Handler) preparationAnalysis(c *gin.Context) <span class="cov8" title="1">{
        var req struct {
                InputPath      string `json:"input_path" binding:"required"`
                SourceLanguage string `json:"source_language,omitempty"`
                TargetLanguage string `json:"target_language" binding:"required"`
                Format         string `json:"format,omitempty"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Generate session ID
        <span class="cov8" title="1">sessionID := uuid.New().String()

        // Validate target language
        targetLang, err := language.ParseLanguage(req.TargetLanguage)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("invalid target language: %v", err)})
                return
        }</span>

        // Check if input path exists
        <span class="cov8" title="1">if _, err := os.Stat(req.InputPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "input path does not exist"})
                return
        }</span>

        // Analyze the input
        <span class="cov8" title="1">analysis := map[string]interface{}{
                "input_path":      req.InputPath,
                "target_language": targetLang.Code,
                "format":          req.Format,
                "status":          "analyzing",
                "session_id":      sessionID,
        }

        // Emit analysis started event
        startData := make(map[string]interface{})
        for k, v := range analysis </span><span class="cov8" title="1">{
                startData[k] = v
        }</span>
        <span class="cov8" title="1">h.eventBus.Publish(events.Event{
                Type:      events.EventTranslationStarted,
                SessionID: sessionID,
                Message:   "Content preparation analysis started",
                Data:      startData,
        })

        // Perform basic analysis
        fileInfo, err := os.Stat(req.InputPath)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("failed to analyze input: %v", err)})
                return
        }</span>

        <span class="cov8" title="1">analysis["file_size"] = fileInfo.Size()
        analysis["file_modified"] = fileInfo.ModTime()
        analysis["is_directory"] = fileInfo.IsDir()

        if fileInfo.IsDir() </span><span class="cov8" title="1">{
                // Count files in directory
                fileCount := 0
                filepath.Walk(req.InputPath, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                        if err == nil &amp;&amp; !info.IsDir() </span><span class="cov0" title="0">{
                                fileCount++
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                })
                <span class="cov8" title="1">analysis["file_count"] = fileCount</span>
        }

        <span class="cov8" title="1">analysis["status"] = "completed"

        // Emit completion event
        completionData := make(map[string]interface{})
        for k, v := range analysis </span><span class="cov8" title="1">{
                completionData[k] = v
        }</span>
        <span class="cov8" title="1">h.eventBus.Publish(events.Event{
                Type:      events.EventTranslationCompleted,
                SessionID: sessionID,
                Message:   "Content preparation analysis completed",
                Data:      completionData,
        })

        c.JSON(http.StatusOK, gin.H{
                "session_id": sessionID,
                "analysis":   analysis,
                "status":     "completed",
        })</span>
}

// getPreparationResult gets preparation result by session ID
func (h *Handler) getPreparationResult(c *gin.Context) <span class="cov8" title="1">{
        sessionID := c.Param("session_id")

        if sessionID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "session_id is required"})
                return
        }</span>

        // For now, return a mock result
        // In a real implementation, this would query the preparation service
        <span class="cov8" title="1">result := map[string]interface{}{
                "session_id": sessionID,
                "status":     "completed",
                "analysis": map[string]interface{}{
                        "input_path":      "/tmp/test",
                        "target_language": "es",
                        "file_count":      10,
                        "file_size":       1024000,
                        "status":          "completed",
                },
                "completed_at": time.Now().Format(time.RFC3339),
        }

        c.JSON(http.StatusOK, result)</span>
}

// translateEbook handles ebook translation requests
func (h *Handler) translateEbook(c *gin.Context) <span class="cov8" title="1">{
        var req struct {
                InputPath      string `json:"input_path" binding:"required"`
                OutputPath     string `json:"output_path,omitempty"`
                SourceLanguage string `json:"source_language,omitempty"`
                TargetLanguage string `json:"target_language" binding:"required"`
                Provider       string `json:"provider,omitempty"`
                Model          string `json:"model,omitempty"`
                Format         string `json:"format,omitempty"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Generate session ID
        <span class="cov8" title="1">sessionID := uuid.New().String()

        // Validate target language
        targetLang, err := language.ParseLanguage(req.TargetLanguage)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("invalid target language: %v", err)})
                return
        }</span>

        // Check if input path exists
        <span class="cov8" title="1">if _, err := os.Stat(req.InputPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "input file does not exist"})
                return
        }</span>

        // Determine format if not provided
        <span class="cov8" title="1">if req.Format == "" </span><span class="cov8" title="1">{
                ext := strings.ToLower(filepath.Ext(req.InputPath))
                switch ext </span>{
                case ".epub":<span class="cov8" title="1">
                        req.Format = "epub"</span>
                case ".fb2":<span class="cov0" title="0">
                        req.Format = "fb2"</span>
                case ".mobi":<span class="cov0" title="0">
                        req.Format = "mobi"</span>
                case ".azw":<span class="cov0" title="0">
                        req.Format = "azw"</span>
                case ".azw3":<span class="cov0" title="0">
                        req.Format = "azw3"</span>
                default:<span class="cov0" title="0">
                        c.JSON(http.StatusBadRequest, gin.H{"error": "unsupported ebook format"})
                        return</span>
                }
        }

        // Set default output path if not provided
        <span class="cov8" title="1">if req.OutputPath == "" </span><span class="cov8" title="1">{
                dir := filepath.Dir(req.InputPath)
                name := strings.TrimSuffix(filepath.Base(req.InputPath), filepath.Ext(req.InputPath))
                req.OutputPath = filepath.Join(dir, name+"_translated."+req.Format)
        }</span>

        // Emit start event
        <span class="cov8" title="1">h.eventBus.Publish(events.Event{
                Type:      events.EventTranslationStarted,
                SessionID: sessionID,
                Message:   "Ebook translation started",
                Data: map[string]interface{}{
                        "input_path":      req.InputPath,
                        "output_path":     req.OutputPath,
                        "target_language": targetLang.Code,
                        "format":          req.Format,
                },
        })

        // For now, return a mock response
        // In a real implementation, this would use the ebook package
        c.JSON(http.StatusOK, gin.H{
                "session_id":  sessionID,
                "status":      "started",
                "input_path":  req.InputPath,
                "output_path": req.OutputPath,
                "format":      req.Format,
                "message":     "Ebook translation started successfully",
        })</span>
}

// cancelTranslation cancels a translation session
func (h *Handler) cancelTranslation(c *gin.Context) <span class="cov8" title="1">{
        sessionID := c.Param("session_id")

        if sessionID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "session_id is required"})
                return
        }</span>

        // Emit cancellation event
        <span class="cov8" title="1">h.eventBus.Publish(events.Event{
                Type:      events.EventTranslationError,
                SessionID: sessionID,
                Message:   "Translation cancelled by user",
                Data: map[string]interface{}{
                        "cancelled_at": time.Now().Format(time.RFC3339),
                },
        })

        c.JSON(http.StatusOK, gin.H{
                "session_id":   sessionID,
                "status":       "cancelled",
                "message":      "Translation cancelled successfully",
                "cancelled_at": time.Now().Format(time.RFC3339),
        })</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package batch

import (
        "context"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
        "sync"

        "digital.vasic.translator/pkg/ebook"
        "digital.vasic.translator/pkg/events"
        "digital.vasic.translator/pkg/format"
        "digital.vasic.translator/pkg/language"
        "digital.vasic.translator/pkg/translator"
)

// InputType represents the type of input
type InputType int

const (
        InputTypeFile InputType = iota
        InputTypeString
        InputTypeStdin
        InputTypeDirectory
)

// ProcessingOptions contains options for batch processing
type ProcessingOptions struct {
        // Input
        InputType   InputType
        InputPath   string
        InputString string
        InputReader io.Reader

        // Output
        OutputPath   string
        OutputFormat string

        // Translation
        SourceLanguage language.Language
        TargetLanguage language.Language
        Provider       string
        Model          string
        Translator     translator.Translator

        // Behavior
        Recursive      bool
        Parallel       bool
        MaxConcurrency int

        // Events
        EventBus  *events.EventBus
        SessionID string
}

// ProcessingResult contains the result of a single file processing
type ProcessingResult struct {
        InputPath  string
        OutputPath string
        Success    bool
        Error      error
}

// BatchProcessor handles batch translation operations
type BatchProcessor struct {
        options *ProcessingOptions
}

// NewBatchProcessor creates a new batch processor
func NewBatchProcessor(options *ProcessingOptions) *BatchProcessor <span class="cov8" title="1">{
        return &amp;BatchProcessor{
                options: options,
        }
}</span>

// Process processes the input based on type
func (bp *BatchProcessor) Process(ctx context.Context) ([]ProcessingResult, error) <span class="cov8" title="1">{
        switch bp.options.InputType </span>{
        case InputTypeString:<span class="cov8" title="1">
                return bp.processString(ctx)</span>
        case InputTypeStdin:<span class="cov8" title="1">
                return bp.processStdin(ctx)</span>
        case InputTypeDirectory:<span class="cov8" title="1">
                return bp.processDirectory(ctx)</span>
        case InputTypeFile:<span class="cov8" title="1">
                result, err := bp.processFile(ctx, bp.options.InputPath, bp.options.OutputPath)
                if err != nil </span><span class="cov0" title="0">{
                        return []ProcessingResult{{
                                InputPath:  bp.options.InputPath,
                                OutputPath: bp.options.OutputPath,
                                Success:    false,
                                Error:      err,
                        }}, err
                }</span>
                <span class="cov8" title="1">return []ProcessingResult{*result}, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported input type: %v", bp.options.InputType)</span>
        }
}

// processString translates a string input
func (bp *BatchProcessor) processString(ctx context.Context) ([]ProcessingResult, error) <span class="cov8" title="1">{
        if bp.options.InputString == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("input string is empty")
        }</span>

        // Translate the string directly
        <span class="cov8" title="1">translated, err := bp.options.Translator.Translate(ctx, bp.options.InputString, "")
        if err != nil </span><span class="cov0" title="0">{
                return []ProcessingResult{{
                        InputPath:  "&lt;string&gt;",
                        OutputPath: "&lt;string&gt;",
                        Success:    false,
                        Error:      err,
                }}, err
        }</span>

        // Write to output if specified
        <span class="cov8" title="1">if bp.options.OutputPath != "" </span><span class="cov8" title="1">{
                err = os.WriteFile(bp.options.OutputPath, []byte(translated), 0644)
                if err != nil </span><span class="cov0" title="0">{
                        return []ProcessingResult{{
                                InputPath:  "&lt;string&gt;",
                                OutputPath: bp.options.OutputPath,
                                Success:    false,
                                Error:      err,
                        }}, err
                }</span>
        } else<span class="cov8" title="1"> {
                // Print to stdout
                fmt.Println(translated)
        }</span>

        <span class="cov8" title="1">return []ProcessingResult{{
                InputPath:  "&lt;string&gt;",
                OutputPath: bp.options.OutputPath,
                Success:    true,
                Error:      nil,
        }}, nil</span>
}

// processStdin reads from stdin and translates
func (bp *BatchProcessor) processStdin(ctx context.Context) ([]ProcessingResult, error) <span class="cov8" title="1">{
        reader := bp.options.InputReader
        if reader == nil </span><span class="cov0" title="0">{
                reader = os.Stdin
        }</span>

        // Read all input
        <span class="cov8" title="1">data, err := io.ReadAll(reader)
        if err != nil </span><span class="cov0" title="0">{
                return []ProcessingResult{{
                        InputPath:  "&lt;stdin&gt;",
                        OutputPath: bp.options.OutputPath,
                        Success:    false,
                        Error:      err,
                }}, err
        }</span>

        // Translate
        <span class="cov8" title="1">translated, err := bp.options.Translator.Translate(ctx, string(data), "")
        if err != nil </span><span class="cov0" title="0">{
                return []ProcessingResult{{
                        InputPath:  "&lt;stdin&gt;",
                        OutputPath: bp.options.OutputPath,
                        Success:    false,
                        Error:      err,
                }}, err
        }</span>

        // Write to output if specified, otherwise stdout
        <span class="cov8" title="1">if bp.options.OutputPath != "" </span><span class="cov8" title="1">{
                err = os.WriteFile(bp.options.OutputPath, []byte(translated), 0644)
                if err != nil </span><span class="cov0" title="0">{
                        return []ProcessingResult{{
                                InputPath:  "&lt;stdin&gt;",
                                OutputPath: bp.options.OutputPath,
                                Success:    false,
                                Error:      err,
                        }}, err
                }</span>
        } else<span class="cov8" title="1"> {
                fmt.Println(translated)
        }</span>

        <span class="cov8" title="1">return []ProcessingResult{{
                InputPath:  "&lt;stdin&gt;",
                OutputPath: bp.options.OutputPath,
                Success:    true,
                Error:      nil,
        }}, nil</span>
}

// processDirectory recursively processes a directory
func (bp *BatchProcessor) processDirectory(ctx context.Context) ([]ProcessingResult, error) <span class="cov8" title="1">{
        if bp.options.InputPath == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("input directory path is empty")
        }</span>

        // Check if directory exists
        <span class="cov8" title="1">info, err := os.Stat(bp.options.InputPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to access directory: %w", err)
        }</span>
        <span class="cov8" title="1">if !info.IsDir() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("input path is not a directory: %s", bp.options.InputPath)
        }</span>

        // Find all supported files
        <span class="cov8" title="1">files, err := bp.findSupportedFiles(bp.options.InputPath, bp.options.Recursive)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find files: %w", err)
        }</span>

        <span class="cov8" title="1">if len(files) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no supported files found in directory: %s", bp.options.InputPath)
        }</span>

        // Emit event
        <span class="cov8" title="1">if bp.options.EventBus != nil </span><span class="cov0" title="0">{
                bp.options.EventBus.Publish(events.Event{
                        Type:      events.EventTranslationStarted,
                        SessionID: bp.options.SessionID,
                        Message:   fmt.Sprintf("Processing %d files from directory", len(files)),
                        Data: map[string]interface{}{
                                "total_files": len(files),
                                "input_dir":   bp.options.InputPath,
                                "output_dir":  bp.options.OutputPath,
                        },
                })
        }</span>

        // Process files
        <span class="cov8" title="1">if bp.options.Parallel </span><span class="cov8" title="1">{
                return bp.processFilesParallel(ctx, files)
        }</span>
        <span class="cov8" title="1">return bp.processFilesSequential(ctx, files)</span>
}

// findSupportedFiles finds all supported ebook files in a directory
func (bp *BatchProcessor) findSupportedFiles(dir string, recursive bool) ([]string, error) <span class="cov8" title="1">{
        var files []string
        detector := format.NewDetector()

        walkFn := func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Skip directories (unless recursive)
                <span class="cov8" title="1">if info.IsDir() </span><span class="cov8" title="1">{
                        if path != dir &amp;&amp; !recursive </span><span class="cov8" title="1">{
                                return filepath.SkipDir
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                }

                // Detect format by content first, then by extension
                <span class="cov8" title="1">detectedFormat, err := detector.DetectFile(path)
                if err == nil &amp;&amp; detector.IsSupported(detectedFormat) </span><span class="cov8" title="1">{
                        files = append(files, path)
                }</span>

                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">err := filepath.Walk(dir, walkFn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return files, nil</span>
}

// processFilesSequential processes files one by one
func (bp *BatchProcessor) processFilesSequential(ctx context.Context, files []string) ([]ProcessingResult, error) <span class="cov8" title="1">{
        results := make([]ProcessingResult, 0, len(files))

        for i, file := range files </span><span class="cov8" title="1">{
                // Compute output path
                outputPath, err := bp.computeOutputPath(file)
                if err != nil </span><span class="cov0" title="0">{
                        results = append(results, ProcessingResult{
                                InputPath:  file,
                                OutputPath: "",
                                Success:    false,
                                Error:      err,
                        })
                        continue</span>
                }

                // Emit progress
                <span class="cov8" title="1">if bp.options.EventBus != nil </span><span class="cov0" title="0">{
                        bp.options.EventBus.Publish(events.Event{
                                Type:      events.EventTranslationProgress,
                                SessionID: bp.options.SessionID,
                                Message:   fmt.Sprintf("Processing file %d/%d: %s", i+1, len(files), filepath.Base(file)),
                                Data: map[string]interface{}{
                                        "current_file": i + 1,
                                        "total_files":  len(files),
                                        "file_name":    filepath.Base(file),
                                        "file_path":    file,
                                },
                        })
                }</span>

                // Process file
                <span class="cov8" title="1">result, err := bp.processFile(ctx, file, outputPath)
                if err != nil </span><span class="cov0" title="0">{
                        results = append(results, ProcessingResult{
                                InputPath:  file,
                                OutputPath: outputPath,
                                Success:    false,
                                Error:      err,
                        })
                        continue</span>
                }

                <span class="cov8" title="1">results = append(results, *result)</span>
        }

        <span class="cov8" title="1">return results, nil</span>
}

// processFilesParallel processes files in parallel
func (bp *BatchProcessor) processFilesParallel(ctx context.Context, files []string) ([]ProcessingResult, error) <span class="cov8" title="1">{
        maxWorkers := bp.options.MaxConcurrency
        if maxWorkers &lt;= 0 </span><span class="cov0" title="0">{
                maxWorkers = 4 // Default
        }</span>

        <span class="cov8" title="1">results := make([]ProcessingResult, len(files))
        var wg sync.WaitGroup
        semaphore := make(chan struct{}, maxWorkers)

        for i, file := range files </span><span class="cov8" title="1">{
                wg.Add(1)
                go func(idx int, filePath string) </span><span class="cov8" title="1">{
                        defer wg.Done()

                        // Acquire semaphore
                        semaphore &lt;- struct{}{}
                        defer func() </span><span class="cov8" title="1">{ &lt;-semaphore }</span>()

                        // Compute output path
                        <span class="cov8" title="1">outputPath, err := bp.computeOutputPath(filePath)
                        if err != nil </span><span class="cov0" title="0">{
                                results[idx] = ProcessingResult{
                                        InputPath:  filePath,
                                        OutputPath: "",
                                        Success:    false,
                                        Error:      err,
                                }
                                return
                        }</span>

                        // Emit progress
                        <span class="cov8" title="1">if bp.options.EventBus != nil </span><span class="cov0" title="0">{
                                bp.options.EventBus.Publish(events.Event{
                                        Type:      events.EventTranslationProgress,
                                        SessionID: bp.options.SessionID,
                                        Message:   fmt.Sprintf("Processing file: %s", filepath.Base(filePath)),
                                        Data: map[string]interface{}{
                                                "file_name": filepath.Base(filePath),
                                                "file_path": filePath,
                                        },
                                })
                        }</span>

                        // Process file
                        <span class="cov8" title="1">result, err := bp.processFile(ctx, filePath, outputPath)
                        if err != nil </span><span class="cov0" title="0">{
                                results[idx] = ProcessingResult{
                                        InputPath:  filePath,
                                        OutputPath: outputPath,
                                        Success:    false,
                                        Error:      err,
                                }
                                return
                        }</span>

                        <span class="cov8" title="1">results[idx] = *result</span>
                }(i, file)
        }

        <span class="cov8" title="1">wg.Wait()

        return results, nil</span>
}

// processFile processes a single file
func (bp *BatchProcessor) processFile(ctx context.Context, inputPath, outputPath string) (*ProcessingResult, error) <span class="cov8" title="1">{
        // Parse the ebook
        parser := ebook.NewUniversalParser()
        book, err := parser.Parse(inputPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse file: %w", err)
        }</span>

        // Translate the book using the provided translator
        // NOTE: Actual translation integration is handled by the ProcessorWithTranslator method
        // This method currently serves as a template for batch processing structure
        // For production use, instantiate BatchProcessor with a translator in options.Translator

        // Write output
        <span class="cov8" title="1">writer := ebook.NewEPUBWriter()
        err = writer.Write(book, outputPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to write output: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;ProcessingResult{
                InputPath:  inputPath,
                OutputPath: outputPath,
                Success:    true,
                Error:      nil,
        }, nil</span>
}

// computeOutputPath computes the output path preserving directory structure
func (bp *BatchProcessor) computeOutputPath(inputPath string) (string, error) <span class="cov8" title="1">{
        if bp.options.OutputPath == "" </span><span class="cov8" title="1">{
                // Generate output path in same directory
                ext := filepath.Ext(inputPath)
                base := strings.TrimSuffix(inputPath, ext)
                lang := bp.options.TargetLanguage.Code
                outputFormat := bp.options.OutputFormat
                if outputFormat == "" </span><span class="cov0" title="0">{
                        outputFormat = "epub"
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%s_%s.%s", base, lang, outputFormat), nil</span>
        }

        // Check if output is a directory
        <span class="cov8" title="1">outputInfo, err := os.Stat(bp.options.OutputPath)
        if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">isOutputDir := err == nil &amp;&amp; outputInfo.IsDir()

        if !isOutputDir </span><span class="cov8" title="1">{
                // Output is a file path
                return bp.options.OutputPath, nil
        }</span>

        // Preserve directory structure
        // Get relative path from input dir
        <span class="cov8" title="1">relPath, err := filepath.Rel(bp.options.InputPath, inputPath)
        if err != nil </span><span class="cov0" title="0">{
                relPath = filepath.Base(inputPath)
        }</span>

        // Change extension and add language suffix
        <span class="cov8" title="1">ext := filepath.Ext(relPath)
        base := strings.TrimSuffix(relPath, ext)
        lang := bp.options.TargetLanguage.Code
        outputFormat := bp.options.OutputFormat
        if outputFormat == "" </span><span class="cov0" title="0">{
                outputFormat = "epub"
        }</span>

        <span class="cov8" title="1">outputFile := fmt.Sprintf("%s_%s.%s", base, lang, outputFormat)
        outputPath := filepath.Join(bp.options.OutputPath, outputFile)

        // Create output directory if needed
        outputDir := filepath.Dir(outputPath)
        err = os.MkdirAll(outputDir, 0755)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create output directory: %w", err)
        }</span>

        <span class="cov8" title="1">return outputPath, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package coordination

import (
        "context"
        "fmt"
        "os"
        "strings"
        "sync"
        "time"

        "digital.vasic.translator/pkg/events"
        "digital.vasic.translator/pkg/translator"
        "digital.vasic.translator/pkg/translator/llm"
)

// LLMInstance represents a single LLM translator instance
type LLMInstance struct {
        ID         string
        Translator translator.Translator
        Provider   string
        Model      string
        Priority   int // Higher priority = more instances (10=API key, 5=OAuth, 1=free)
        Available  bool
        LastUsed   time.Time
        mu         sync.Mutex
}

// MultiLLMCoordinator manages multiple LLM instances for coordinated translation
type MultiLLMCoordinator struct {
        instances         []*LLMInstance
        currentIndex      int
        mu                sync.RWMutex
        maxRetries        int
        retryDelay        time.Duration
        eventBus          *events.EventBus
        sessionID         string
        disableLocalLLMs  bool
        preferDistributed bool
        distributedCoord  interface{} // *distributed.DistributedCoordinator
}

// CoordinatorConfig holds configuration for the coordinator
type CoordinatorConfig struct {
        MaxRetries        int
        RetryDelay        time.Duration
        EventBus          *events.EventBus
        SessionID         string
        DisableLocalLLMs  bool        // When true, only use distributed workers, no local LLM providers
        PreferDistributed bool        // When true, prefer distributed workers over local LLMs
        DistributedCoord  interface{} // Optional distributed coordinator for remote instances
}

// NewMultiLLMCoordinator creates a new multi-LLM coordinator
func NewMultiLLMCoordinator(config CoordinatorConfig) *MultiLLMCoordinator <span class="cov8" title="1">{
        if config.MaxRetries == 0 </span><span class="cov8" title="1">{
                config.MaxRetries = 3
        }</span>
        <span class="cov8" title="1">if config.RetryDelay == 0 </span><span class="cov8" title="1">{
                config.RetryDelay = 2 * time.Second
        }</span>

        <span class="cov8" title="1">coordinator := &amp;MultiLLMCoordinator{
                instances:         make([]*LLMInstance, 0),
                currentIndex:      0,
                maxRetries:        config.MaxRetries,
                retryDelay:        config.RetryDelay,
                eventBus:          config.EventBus,
                sessionID:         config.SessionID,
                disableLocalLLMs:  config.DisableLocalLLMs,
                preferDistributed: config.PreferDistributed,
                distributedCoord:  config.DistributedCoord,
        }

        // Auto-discover and initialize LLM instances
        coordinator.initializeLLMInstances()

        return coordinator</span>
}

// initializeLLMInstances discovers and initializes available LLM instances
func (c *MultiLLMCoordinator) initializeLLMInstances() <span class="cov8" title="1">{
        // Check for available LLM providers based on API keys
        providers := c.discoverProviders()

        if len(providers) == 0 </span><span class="cov8" title="1">{
                if c.disableLocalLLMs </span><span class="cov0" title="0">{
                        c.emitWarning("No LLM providers configured with API keys and local LLMs are disabled - distributed workers expected")
                }</span> else<span class="cov8" title="1"> {
                        c.emitWarning("No LLM providers configured with API keys")
                }</span>
                <span class="cov8" title="1">return</span>
        }

        // Calculate total instances based on priority
        // API key (priority 10) gets 3 instances, OAuth (priority 5) gets 2, free (priority 1) gets 1
        <span class="cov8" title="1">getInstanceCount := func(priority int) int </span><span class="cov8" title="1">{
                switch </span>{
                case priority &gt;= 10:<span class="cov8" title="1">
                        return 3</span> // API key providers
                case priority &gt;= 5:<span class="cov8" title="1">
                        return 2</span> // OAuth providers
                default:<span class="cov0" title="0">
                        return 1</span> // Free/local providers
                }
        }

        <span class="cov8" title="1">totalInstances := 0
        for _, config := range providers </span><span class="cov8" title="1">{
                priority := config["priority"].(int)
                totalInstances += getInstanceCount(priority)
        }</span>

        <span class="cov8" title="1">initMessage := fmt.Sprintf("Initializing %d LLM instances across %d providers", totalInstances, len(providers))
        if c.disableLocalLLMs </span><span class="cov8" title="1">{
                initMessage += " (local LLMs disabled)"
        }</span>
        <span class="cov8" title="1">if c.preferDistributed </span><span class="cov0" title="0">{
                initMessage += " (preferring distributed workers)"
        }</span>

        <span class="cov8" title="1">c.emitEvent(events.Event{
                Type:      "multi_llm_init",
                SessionID: c.sessionID,
                Message:   initMessage,
                Data: map[string]interface{}{
                        "providers":          providers,
                        "disable_local":      c.disableLocalLLMs,
                        "prefer_distributed": c.preferDistributed,
                },
        })

        // Create multiple instances per provider based on priority
        // API-key providers get 3x instances, OAuth 2x, free/local 1x
        instanceID := 1
        for provider, config := range providers </span><span class="cov8" title="1">{
                priority := config["priority"].(int)
                instanceCount := getInstanceCount(priority)

                for i := 0; i &lt; instanceCount; i++ </span><span class="cov8" title="1">{
                        translatorConfig := translator.TranslationConfig{
                                Provider: provider,
                                Model:    config["model"].(string),
                                APIKey:   config["api_key"].(string),
                        }

                        trans, err := llm.NewLLMTranslator(translatorConfig)
                        if err != nil </span><span class="cov0" title="0">{
                                c.emitWarning(fmt.Sprintf("Failed to initialize %s instance %d: %v", provider, i+1, err))
                                continue</span>
                        }

                        <span class="cov8" title="1">instance := &amp;LLMInstance{
                                ID:         fmt.Sprintf("%s-%d", provider, instanceID),
                                Translator: trans,
                                Provider:   provider,
                                Model:      config["model"].(string),
                                Priority:   priority,
                                Available:  true,
                                LastUsed:   time.Time{},
                        }

                        c.instances = append(c.instances, instance)
                        instanceID++</span>
                }
        }

        <span class="cov8" title="1">if len(c.instances) == 0 </span><span class="cov0" title="0">{
                c.emitWarning("No LLM instances could be initialized")
                return
        }</span>

        <span class="cov8" title="1">c.emitEvent(events.Event{
                Type:      "multi_llm_ready",
                SessionID: c.sessionID,
                Message:   fmt.Sprintf("Multi-LLM coordinator ready with %d instances", len(c.instances)),
                Data: map[string]interface{}{
                        "instance_count": len(c.instances),
                        "providers":      c.getProviderList(),
                },
        })</span>
}

// discoverProviders checks environment for available LLM API keys
// Priority levels: 10=API key (paid), 5=OAuth, 1=free/local
func (c *MultiLLMCoordinator) discoverProviders() map[string]map[string]interface{} <span class="cov8" title="1">{
        providers := make(map[string]map[string]interface{})

        // Check OpenAI (API key - high priority)
        if apiKey := os.Getenv("OPENAI_API_KEY"); apiKey != "" </span><span class="cov8" title="1">{
                providers["openai"] = map[string]interface{}{
                        "api_key":  apiKey,
                        "model":    getEnvOrDefault("OPENAI_MODEL", "gpt-4"),
                        "priority": 10, // API key = high priority
                }
        }</span>

        // Check Anthropic (API key - high priority)
        <span class="cov8" title="1">if apiKey := os.Getenv("ANTHROPIC_API_KEY"); apiKey != "" </span><span class="cov0" title="0">{
                providers["anthropic"] = map[string]interface{}{
                        "api_key":  apiKey,
                        "model":    getEnvOrDefault("ANTHROPIC_MODEL", "claude-3-sonnet-20240229"),
                        "priority": 10, // API key = high priority
                }
        }</span>

        // Check Zhipu AI (API key - high priority)
        <span class="cov8" title="1">if apiKey := os.Getenv("ZHIPU_API_KEY"); apiKey != "" </span><span class="cov0" title="0">{
                providers["zhipu"] = map[string]interface{}{
                        "api_key":  apiKey,
                        "model":    getEnvOrDefault("ZHIPU_MODEL", "glm-4"),
                        "priority": 10, // API key = high priority
                }
        }</span>

        // Check DeepSeek (API key - high priority)
        <span class="cov8" title="1">if apiKey := os.Getenv("DEEPSEEK_API_KEY"); apiKey != "" </span><span class="cov8" title="1">{
                providers["deepseek"] = map[string]interface{}{
                        "api_key":  apiKey,
                        "model":    getEnvOrDefault("DEEPSEEK_MODEL", "deepseek-chat"),
                        "priority": 10, // API key = high priority
                }
        }</span>

        // Check Qwen (Alibaba Cloud)
        // Priority depends on authentication method
        <span class="cov8" title="1">if apiKey := os.Getenv("QWEN_API_KEY"); apiKey != "" </span><span class="cov0" title="0">{
                providers["qwen"] = map[string]interface{}{
                        "api_key":  apiKey,
                        "model":    getEnvOrDefault("QWEN_MODEL", "qwen-plus"),
                        "priority": 10, // API key = high priority
                }
        }</span> else<span class="cov8" title="1"> if os.Getenv("SKIP_QWEN_OAUTH") == "" </span><span class="cov8" title="1">{
                // Check for OAuth credentials (skip in test environments)
                homeDir := os.Getenv("HOME")
                if homeDir != "" </span><span class="cov8" title="1">{
                        qwenOAuthPaths := []string{
                                homeDir + "/.translator/qwen_credentials.json",
                                homeDir + "/.qwen/oauth_creds.json",
                        }
                        for _, path := range qwenOAuthPaths </span><span class="cov8" title="1">{
                                if _, err := os.Stat(path); err == nil </span><span class="cov8" title="1">{
                                        providers["qwen"] = map[string]interface{}{
                                                "api_key":  "", // OAuth will be used
                                                "model":    getEnvOrDefault("QWEN_MODEL", "qwen-plus"),
                                                "priority": 5, // OAuth = medium priority
                                        }
                                        break</span>
                                }
                        }
                }
        }

        // Check Ollama (local, no API key needed - lowest priority)
        // Skip local LLMs if disabled
        <span class="cov8" title="1">if !c.disableLocalLLMs &amp;&amp; os.Getenv("OLLAMA_ENABLED") == "true" </span><span class="cov0" title="0">{
                providers["ollama"] = map[string]interface{}{
                        "api_key":  "",
                        "model":    getEnvOrDefault("OLLAMA_MODEL", "llama3:8b"),
                        "priority": 1, // Free/local = low priority
                }
        }</span>

        <span class="cov8" title="1">return providers</span>
}

// TranslateWithRetry translates text with automatic retry and instance rotation
func (c *MultiLLMCoordinator) TranslateWithRetry(
        ctx context.Context,
        text string,
        contextHint string,
) (string, error) <span class="cov8" title="1">{
        if len(c.instances) == 0 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("no LLM instances available")
        }</span>

        <span class="cov0" title="0">var lastErr error
        triedInstances := make(map[string]bool)

        for attempt := 0; attempt &lt; c.maxRetries*len(c.instances); attempt++ </span><span class="cov0" title="0">{
                // Get next available instance
                instance := c.getNextInstance()
                if instance == nil </span><span class="cov0" title="0">{
                        c.emitWarning("All LLM instances exhausted")
                        break</span>
                }

                // Skip if already tried this instance
                <span class="cov0" title="0">if triedInstances[instance.ID] </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">triedInstances[instance.ID] = true

                c.emitEvent(events.Event{
                        Type:      "translation_attempt",
                        SessionID: c.sessionID,
                        Message:   fmt.Sprintf("Attempting translation with %s (Attempt %d)", instance.ID, attempt+1),
                        Data: map[string]interface{}{
                                "instance_id": instance.ID,
                                "provider":    instance.Provider,
                                "attempt":     attempt + 1,
                        },
                })

                // Attempt translation
                translated, err := instance.Translator.Translate(ctx, text, contextHint)
                if err == nil &amp;&amp; translated != "" </span><span class="cov0" title="0">{
                        // Success!
                        instance.LastUsed = time.Now()
                        c.emitEvent(events.Event{
                                Type:      "translation_success",
                                SessionID: c.sessionID,
                                Message:   fmt.Sprintf("Translation successful with %s", instance.ID),
                                Data: map[string]interface{}{
                                        "instance_id": instance.ID,
                                        "text_length": len(text),
                                },
                        })
                        return translated, nil
                }</span>

                <span class="cov0" title="0">lastErr = err
                c.emitWarning(fmt.Sprintf("Translation failed with %s: %v", instance.ID, err))

                // Mark instance as temporarily unavailable if rate limited
                if strings.Contains(err.Error(), "rate limit") || strings.Contains(err.Error(), "429") </span><span class="cov0" title="0">{
                        instance.Available = false
                        go c.reenableInstanceAfterDelay(instance, 30*time.Second)
                }</span>

                // Wait before retry
                <span class="cov0" title="0">if attempt &lt; c.maxRetries*len(c.instances)-1 </span><span class="cov0" title="0">{
                        time.Sleep(c.retryDelay)
                }</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("translation failed after %d attempts with %d instances: %w",
                c.maxRetries, len(c.instances), lastErr)</span>
}

// TranslateWithConsensus uses multiple instances to translate and picks best result
func (c *MultiLLMCoordinator) TranslateWithConsensus(
        ctx context.Context,
        text string,
        contextHint string,
        requiredAgreement int,
) (string, error) <span class="cov0" title="0">{
        if len(c.instances) &lt; requiredAgreement </span><span class="cov0" title="0">{
                requiredAgreement = len(c.instances)
        }</span>

        <span class="cov0" title="0">if requiredAgreement == 0 </span><span class="cov0" title="0">{
                return c.TranslateWithRetry(ctx, text, contextHint)
        }</span>

        // Collect translations from multiple instances
        <span class="cov0" title="0">type result struct {
                translation string
                instance    string
                err         error
        }

        resultsChan := make(chan result, requiredAgreement)
        instancesUsed := 0

        for i := 0; i &lt; requiredAgreement &amp;&amp; i &lt; len(c.instances); i++ </span><span class="cov0" title="0">{
                instance := c.instances[i]
                if !instance.Available </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">instancesUsed++
                go func(inst *LLMInstance) </span><span class="cov0" title="0">{
                        translated, err := inst.Translator.Translate(ctx, text, contextHint)
                        resultsChan &lt;- result{
                                translation: translated,
                                instance:    inst.ID,
                                err:         err,
                        }
                }</span>(instance)
        }

        // Collect results
        <span class="cov0" title="0">translations := make(map[string]int)
        var firstSuccess string

        for i := 0; i &lt; instancesUsed; i++ </span><span class="cov0" title="0">{
                res := &lt;-resultsChan
                if res.err == nil &amp;&amp; res.translation != "" </span><span class="cov0" title="0">{
                        if firstSuccess == "" </span><span class="cov0" title="0">{
                                firstSuccess = res.translation
                        }</span>
                        <span class="cov0" title="0">translations[res.translation]++</span>
                }
        }

        // Find consensus
        <span class="cov0" title="0">maxCount := 0
        bestTranslation := firstSuccess

        for translation, count := range translations </span><span class="cov0" title="0">{
                if count &gt; maxCount </span><span class="cov0" title="0">{
                        maxCount = count
                        bestTranslation = translation
                }</span>
        }

        <span class="cov0" title="0">if bestTranslation != "" </span><span class="cov0" title="0">{
                c.emitEvent(events.Event{
                        Type:      "consensus_reached",
                        SessionID: c.sessionID,
                        Message:   fmt.Sprintf("Consensus reached with %d/%d agreement", maxCount, instancesUsed),
                        Data: map[string]interface{}{
                                "agreement_count": maxCount,
                                "total_instances": instancesUsed,
                        },
                })
                return bestTranslation, nil
        }</span>

        // Fallback to retry mechanism
        <span class="cov0" title="0">return c.TranslateWithRetry(ctx, text, contextHint)</span>
}

// getNextInstance gets the next available instance (round-robin)
func (c *MultiLLMCoordinator) getNextInstance() *LLMInstance <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if len(c.instances) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Try to find available instance
        <span class="cov8" title="1">startIndex := c.currentIndex
        for </span><span class="cov8" title="1">{
                instance := c.instances[c.currentIndex]
                c.currentIndex = (c.currentIndex + 1) % len(c.instances)

                if instance.Available </span><span class="cov8" title="1">{
                        return instance
                }</span>

                // If we've checked all instances, return nil
                <span class="cov8" title="1">if c.currentIndex == startIndex </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }
}

// reenableInstanceAfterDelay re-enables an instance after a delay
func (c *MultiLLMCoordinator) reenableInstanceAfterDelay(instance *LLMInstance, delay time.Duration) <span class="cov0" title="0">{
        time.Sleep(delay)
        instance.mu.Lock()
        instance.Available = true
        instance.mu.Unlock()

        c.emitEvent(events.Event{
                Type:      "instance_reenabled",
                SessionID: c.sessionID,
                Message:   fmt.Sprintf("Instance %s re-enabled after cooldown", instance.ID),
                Data: map[string]interface{}{
                        "instance_id": instance.ID,
                },
        })
}</span>

// GetInstanceCount returns the number of active instances
func (c *MultiLLMCoordinator) GetInstanceCount() int <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return len(c.instances)
}</span>

// getProviderList returns list of unique providers
func (c *MultiLLMCoordinator) getProviderList() []string <span class="cov8" title="1">{
        providers := make(map[string]bool)
        for _, instance := range c.instances </span><span class="cov8" title="1">{
                providers[instance.Provider] = true
        }</span>

        <span class="cov8" title="1">list := make([]string, 0, len(providers))
        for provider := range providers </span><span class="cov8" title="1">{
                list = append(list, provider)
        }</span>
        <span class="cov8" title="1">return list</span>
}

// emitEvent emits an event if event bus is available
func (c *MultiLLMCoordinator) emitEvent(event events.Event) <span class="cov8" title="1">{
        if c.eventBus != nil </span><span class="cov8" title="1">{
                c.eventBus.Publish(event)
        }</span>
}

// emitWarning emits a warning event
func (c *MultiLLMCoordinator) emitWarning(message string) <span class="cov8" title="1">{
        if c.eventBus != nil </span><span class="cov0" title="0">{
                c.eventBus.Publish(events.Event{
                        Type:      "multi_llm_warning",
                        SessionID: c.sessionID,
                        Message:   message,
                })
        }</span>
}

// getEnvOrDefault gets environment variable or returns default
func getEnvOrDefault(key, defaultValue string) string <span class="cov8" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov8" title="1">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package coordination

import (
        "context"
        "digital.vasic.translator/pkg/events"
        "digital.vasic.translator/pkg/translator"
)

// MultiLLMTranslatorWrapper wraps MultiLLMCoordinator to implement the Translator interface
type MultiLLMTranslatorWrapper struct {
        Coordinator *MultiLLMCoordinator // Exported so CLI can access instance count
        config      translator.TranslationConfig
}

// NewMultiLLMTranslatorWrapper creates a new wrapper
func NewMultiLLMTranslatorWrapper(config translator.TranslationConfig, eventBus *events.EventBus, sessionID string) (*MultiLLMTranslatorWrapper, error) <span class="cov8" title="1">{
        return NewMultiLLMTranslatorWrapperWithConfig(config, eventBus, sessionID, false, false)
}</span>

// NewMultiLLMTranslatorWrapperWithConfig creates a new wrapper with configuration options
func NewMultiLLMTranslatorWrapperWithConfig(config translator.TranslationConfig, eventBus *events.EventBus, sessionID string, disableLocalLLMs bool, preferDistributed bool) (*MultiLLMTranslatorWrapper, error) <span class="cov8" title="1">{
        coordinator := NewMultiLLMCoordinator(CoordinatorConfig{
                MaxRetries:        3,
                RetryDelay:        0, // No delay between retries with different instances
                EventBus:          eventBus,
                SessionID:         sessionID,
                DisableLocalLLMs:  disableLocalLLMs,
                PreferDistributed: preferDistributed,
                DistributedCoord:  nil, // CLI doesn't use distributed coordinator
        })

        if coordinator.GetInstanceCount() == 0 </span><span class="cov0" title="0">{
                // Fall back to single translator if no instances available
                return nil, translator.ErrNoLLMInstances
        }</span>

        <span class="cov8" title="1">return &amp;MultiLLMTranslatorWrapper{
                Coordinator: coordinator,
                config:      config,
        }, nil</span>
}

// Translate implements translator.Translator
func (w *MultiLLMTranslatorWrapper) Translate(ctx context.Context, text string, context string) (string, error) <span class="cov0" title="0">{
        return w.Coordinator.TranslateWithRetry(ctx, text, context)
}</span>

// TranslateWithProgress implements translator.Translator
func (w *MultiLLMTranslatorWrapper) TranslateWithProgress(
        ctx context.Context,
        text string,
        contextHint string,
        eventBus *events.EventBus,
        sessionID string,
) (string, error) <span class="cov0" title="0">{
        return w.Coordinator.TranslateWithRetry(ctx, text, contextHint)
}</span>

// GetName implements translator.Translator
func (w *MultiLLMTranslatorWrapper) GetName() string <span class="cov8" title="1">{
        return "multi-llm-coordinator"
}</span>

// GetStats implements translator.Translator
func (w *MultiLLMTranslatorWrapper) GetStats() translator.TranslationStats <span class="cov8" title="1">{
        // Multi-LLM coordinator doesn't track individual stats the same way
        // Return zero stats for now - proper stats tracking can be added later
        return translator.TranslationStats{
                Total:      0,
                Translated: 0,
                Cached:     0,
                Errors:     0,
        }
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package deployment

import (
        "fmt"
        "log"
        "os"
        "sync"
        "time"
)

// APICommunicationLogger logs all REST API communications between distributed nodes
type APICommunicationLogger struct {
        logFile *os.File
        logger  *log.Logger
        mu      sync.Mutex
}

// NewAPICommunicationLogger creates a new API communication logger
func NewAPICommunicationLogger(logPath string) (*APICommunicationLogger, error) <span class="cov8" title="1">{
        file, err := os.OpenFile(logPath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to open log file: %w", err)
        }</span>

        <span class="cov8" title="1">logger := log.New(file, "", 0) // No prefix, we'll format ourselves

        return &amp;APICommunicationLogger{
                logFile: file,
                logger:  logger,
        }, nil</span>
}

// LogCommunication logs an API communication event
func (acl *APICommunicationLogger) LogCommunication(logEntry *APICommunicationLog) error <span class="cov8" title="1">{
        acl.mu.Lock()
        defer acl.mu.Unlock()

        // Format like Retrofit library (Android) for impeccable readability
        var logLine string

        if logEntry.StatusCode == 0 </span><span class="cov8" title="1">{
                // Outgoing request
                timestamp := logEntry.Timestamp.Format("2006/01/02 15:04:05.000")
                sizeInfo := ""
                if logEntry.RequestSize &gt; 0 </span><span class="cov8" title="1">{
                        sizeInfo = fmt.Sprintf(" (%d-byte body)", logEntry.RequestSize)
                }</span>
                <span class="cov8" title="1">logLine = fmt.Sprintf("%s --&gt; %s %s://%s:%d%s%s",
                        timestamp,
                        logEntry.Method,
                        acl.getProtocol(logEntry.TargetPort),
                        logEntry.TargetHost,
                        logEntry.TargetPort,
                        logEntry.URL,
                        sizeInfo)</span>
        } else<span class="cov8" title="1"> {
                // Incoming response
                timestamp := logEntry.Timestamp.Format("2006/01/02 15:04:05.000")
                duration := acl.formatDuration(logEntry.Duration)
                sizeInfo := ""
                if logEntry.ResponseSize &gt; 0 </span><span class="cov8" title="1">{
                        sizeInfo = fmt.Sprintf(", %d-byte body", logEntry.ResponseSize)
                }</span>
                <span class="cov8" title="1">statusText := acl.getStatusText(logEntry.StatusCode)

                logLine = fmt.Sprintf("%s &lt;-- %d %s %s://%s:%d%s (%s%s)",
                        timestamp,
                        logEntry.StatusCode,
                        statusText,
                        acl.getProtocol(logEntry.TargetPort),
                        logEntry.TargetHost,
                        logEntry.TargetPort,
                        logEntry.URL,
                        duration,
                        sizeInfo)

                // Add error information if present
                if logEntry.Error != "" </span><span class="cov0" title="0">{
                        logLine += fmt.Sprintf("\n%s &lt;-- HTTP FAILED: %s", timestamp, logEntry.Error)
                }</span>
        }

        <span class="cov8" title="1">acl.logger.Println(logLine)
        return nil</span>
}

// LogRequest logs an outgoing API request
func (acl *APICommunicationLogger) LogRequest(sourceHost string, sourcePort int, targetHost string, targetPort int, method, url string, requestSize int64) *APICommunicationLog <span class="cov8" title="1">{
        entry := &amp;APICommunicationLog{
                Timestamp:   time.Now(),
                SourceHost:  sourceHost,
                SourcePort:  sourcePort,
                TargetHost:  targetHost,
                TargetPort:  targetPort,
                Method:      method,
                URL:         url,
                RequestSize: requestSize,
        }

        // Log asynchronously to avoid blocking
        go func() </span><span class="cov8" title="1">{
                if err := acl.LogCommunication(entry); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to log API request: %v", err)
                }</span>
        }()

        <span class="cov8" title="1">return entry</span>
}

// LogResponse logs the response for a previously logged request
func (acl *APICommunicationLogger) LogResponse(entry *APICommunicationLog, statusCode int, responseSize int64, duration time.Duration, err error) <span class="cov8" title="1">{
        entry.StatusCode = statusCode
        entry.ResponseSize = responseSize
        entry.Duration = duration
        entry.Timestamp = time.Now() // Update timestamp for response logging

        if err != nil </span><span class="cov0" title="0">{
                entry.Error = err.Error()
        }</span>

        // Update the existing log entry
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                if logErr := acl.LogCommunication(entry); logErr != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to log API response: %v", logErr)
                }</span>
        }()
}

// GetLogs retrieves recent log entries
func (acl *APICommunicationLogger) GetLogs(limit int) ([]*APICommunicationLog, error) <span class="cov0" title="0">{
        acl.mu.Lock()
        defer acl.mu.Unlock()

        // This is a simplified implementation
        // In a real system, you'd want to read from the log file and parse recent entries
        return []*APICommunicationLog{}, nil
}</span>

// Close closes the logger
func (acl *APICommunicationLogger) Close() error <span class="cov8" title="1">{
        acl.mu.Lock()
        defer acl.mu.Unlock()

        if acl.logFile != nil </span><span class="cov8" title="1">{
                return acl.logFile.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetStats returns communication statistics
func (acl *APICommunicationLogger) GetStats() map[string]interface{} <span class="cov8" title="1">{
        // This would parse the log file to generate statistics
        // For now, return empty stats
        return map[string]interface{}{
                "total_requests":  0,
                "total_responses": 0,
                "error_count":     0,
                "avg_duration":    "0s",
        }
}</span>

// Helper methods for Retrofit-style formatting

// getProtocol returns the protocol (http/https) based on port
func (acl *APICommunicationLogger) getProtocol(port int) string <span class="cov8" title="1">{
        if port == 443 || port == 8443 </span><span class="cov0" title="0">{
                return "https"
        }</span>
        <span class="cov8" title="1">return "http"</span>
}

// formatDuration formats duration in Retrofit style (e.g., "150ms", "2.5s")
func (acl *APICommunicationLogger) formatDuration(d time.Duration) string <span class="cov8" title="1">{
        if d &lt; time.Second </span><span class="cov8" title="1">{
                return fmt.Sprintf("%dms", d.Milliseconds())
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%.1fs", d.Seconds())</span>
}

// getStatusText returns the HTTP status text for common status codes
func (acl *APICommunicationLogger) getStatusText(statusCode int) string <span class="cov8" title="1">{
        switch statusCode </span>{
        case 200:<span class="cov8" title="1">
                return "OK"</span>
        case 201:<span class="cov0" title="0">
                return "Created"</span>
        case 204:<span class="cov0" title="0">
                return "No Content"</span>
        case 400:<span class="cov0" title="0">
                return "Bad Request"</span>
        case 401:<span class="cov0" title="0">
                return "Unauthorized"</span>
        case 403:<span class="cov0" title="0">
                return "Forbidden"</span>
        case 404:<span class="cov0" title="0">
                return "Not Found"</span>
        case 405:<span class="cov0" title="0">
                return "Method Not Allowed"</span>
        case 409:<span class="cov0" title="0">
                return "Conflict"</span>
        case 422:<span class="cov0" title="0">
                return "Unprocessable Entity"</span>
        case 429:<span class="cov0" title="0">
                return "Too Many Requests"</span>
        case 500:<span class="cov0" title="0">
                return "Internal Server Error"</span>
        case 502:<span class="cov0" title="0">
                return "Bad Gateway"</span>
        case 503:<span class="cov0" title="0">
                return "Service Unavailable"</span>
        case 504:<span class="cov0" title="0">
                return "Gateway Timeout"</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package deployment

import (
        "context"
        "fmt"
        "log"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "time"

        "digital.vasic.translator/internal/config"
        "digital.vasic.translator/pkg/events"
        "gopkg.in/yaml.v3"
)

// DockerOrchestrator manages Docker-based deployment using docker-compose
type DockerOrchestrator struct {
        config     *config.Config
        eventBus   *events.EventBus
        logger     *log.Logger
        composeDir string
}

// DockerComposeConfig represents a docker-compose configuration
type DockerComposeConfig struct {
        Version  string                          `yaml:"version"`
        Services map[string]*DockerServiceConfig `yaml:"services"`
        Networks map[string]*DockerNetworkConfig `yaml:"networks,omitempty"`
        Volumes  map[string]*DockerVolumeConfig  `yaml:"volumes,omitempty"`
}

// DockerServiceConfig represents a Docker service configuration
type DockerServiceConfig struct {
        Image         string             `yaml:"image"`
        ContainerName string             `yaml:"container_name,omitempty"`
        Ports         []string           `yaml:"ports,omitempty"`
        Environment   map[string]string  `yaml:"environment,omitempty"`
        Volumes       []string           `yaml:"volumes,omitempty"`
        Networks      []string           `yaml:"networks,omitempty"`
        Restart       string             `yaml:"restart,omitempty"`
        DependsOn     []string           `yaml:"depends_on,omitempty"`
        HealthCheck   *DockerHealthCheck `yaml:"healthcheck,omitempty"`
        Command       []string           `yaml:"command,omitempty"`
}

// DockerHealthCheck represents a Docker health check configuration
type DockerHealthCheck struct {
        Test        []string `yaml:"test"`
        Interval    string   `yaml:"interval,omitempty"`
        Timeout     string   `yaml:"timeout,omitempty"`
        Retries     int      `yaml:"retries,omitempty"`
        StartPeriod string   `yaml:"start_period,omitempty"`
}

// DockerNetworkConfig represents a Docker network configuration
type DockerNetworkConfig struct {
        Driver string `yaml:"driver,omitempty"`
}

// DockerVolumeConfig represents a Docker volume configuration
type DockerVolumeConfig struct {
        Driver string `yaml:"driver,omitempty"`
}

// NewDockerOrchestrator creates a new Docker orchestrator
func NewDockerOrchestrator(cfg *config.Config, eventBus *events.EventBus) *DockerOrchestrator <span class="cov0" title="0">{
        logger := log.New(os.Stdout, "[DOCKER] ", log.LstdFlags)

        // Create compose directory
        composeDir := filepath.Join(os.TempDir(), "translator-compose")
        _ = os.MkdirAll(composeDir, 0755)

        return &amp;DockerOrchestrator{
                config:     cfg,
                eventBus:   eventBus,
                logger:     logger,
                composeDir: composeDir,
        }
}</span>

// GenerateComposeFile generates a docker-compose.yml file for the deployment plan
func (do *DockerOrchestrator) GenerateComposeFile(plan *DeploymentPlan) (string, error) <span class="cov0" title="0">{
        do.logger.Printf("Generating docker-compose.yml for %d services", len(plan.Workers)+1)

        composeConfig := &amp;DockerComposeConfig{
                Version:  "3.8",
                Services: make(map[string]*DockerServiceConfig),
                Networks: map[string]*DockerNetworkConfig{
                        "translator-network": {Driver: "bridge"},
                },
                Volumes: make(map[string]*DockerVolumeConfig),
        }

        // Add main service
        if err := do.addServiceToCompose(composeConfig, plan.Main, "main"); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to add main service: %w", err)
        }</span>

        // Add worker services
        <span class="cov0" title="0">for i, worker := range plan.Workers </span><span class="cov0" title="0">{
                serviceName := fmt.Sprintf("worker-%d", i+1)
                if err := do.addServiceToCompose(composeConfig, worker, serviceName); err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to add worker service %d: %w", i+1, err)
                }</span>
        }

        // Add supporting services (database, etc.)
        <span class="cov0" title="0">do.addSupportingServices(composeConfig)

        // Generate YAML
        composePath := filepath.Join(do.composeDir, "docker-compose.yml")
        if err := do.writeComposeFile(composeConfig, composePath); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to write compose file: %w", err)
        }</span>

        <span class="cov0" title="0">do.logger.Printf("Generated docker-compose.yml at %s", composePath)
        return composePath, nil</span>
}

// addServiceToCompose adds a service to the docker-compose configuration
func (do *DockerOrchestrator) addServiceToCompose(composeConfig *DockerComposeConfig, cfg *DeploymentConfig, serviceName string) error <span class="cov0" title="0">{
        service := &amp;DockerServiceConfig{
                Image:         cfg.DockerImage,
                ContainerName: cfg.ContainerName,
                Ports:         make([]string, 0),
                Environment:   cfg.Environment,
                Volumes:       make([]string, 0),
                Networks:      cfg.Networks,
                Restart:       cfg.RestartPolicy,
        }

        // Add ports
        for _, port := range cfg.Ports </span><span class="cov0" title="0">{
                portStr := fmt.Sprintf("%d:%d", port.HostPort, port.ContainerPort)
                if port.Protocol != "" &amp;&amp; port.Protocol != "tcp" </span><span class="cov0" title="0">{
                        portStr += "/" + port.Protocol
                }</span>
                <span class="cov0" title="0">service.Ports = append(service.Ports, portStr)</span>
        }

        // Add volumes
        <span class="cov0" title="0">for _, volume := range cfg.Volumes </span><span class="cov0" title="0">{
                volumeStr := fmt.Sprintf("%s:%s", volume.HostPath, volume.ContainerPath)
                if volume.ReadOnly </span><span class="cov0" title="0">{
                        volumeStr += ":ro"
                }</span>
                <span class="cov0" title="0">service.Volumes = append(service.Volumes, volumeStr)</span>
        }

        // Add health check
        <span class="cov0" title="0">if cfg.HealthCheck != nil </span><span class="cov0" title="0">{
                service.HealthCheck = &amp;DockerHealthCheck{
                        Test:        cfg.HealthCheck.Test,
                        Interval:    formatDuration(cfg.HealthCheck.Interval),
                        Timeout:     formatDuration(cfg.HealthCheck.Timeout),
                        Retries:     cfg.HealthCheck.Retries,
                        StartPeriod: formatDuration(cfg.HealthCheck.StartPeriod),
                }
        }</span>

        <span class="cov0" title="0">composeConfig.Services[serviceName] = service
        return nil</span>
}

// addSupportingServices adds database and other supporting services
func (do *DockerOrchestrator) addSupportingServices(composeConfig *DockerComposeConfig) <span class="cov0" title="0">{
        // PostgreSQL database
        composeConfig.Services["postgres"] = &amp;DockerServiceConfig{
                Image: "postgres:15-alpine",
                Environment: map[string]string{
                        "POSTGRES_USER":     "translator",
                        "POSTGRES_PASSWORD": "secure_password",
                        "POSTGRES_DB":       "translator",
                },
                Volumes:  []string{"postgres-data:/var/lib/postgresql/data"},
                Networks: []string{"translator-network"},
                Ports:    []string{"5432:5432"},
                HealthCheck: &amp;DockerHealthCheck{
                        Test:     []string{"CMD-SHELL", "pg_isready -U translator -d translator"},
                        Interval: "30s",
                        Timeout:  "10s",
                        Retries:  3,
                },
        }

        // Redis cache
        composeConfig.Services["redis"] = &amp;DockerServiceConfig{
                Image:    "redis:7-alpine",
                Command:  []string{"redis-server", "--requirepass", "redis_secure_password"},
                Volumes:  []string{"redis-data:/data"},
                Networks: []string{"translator-network"},
                Ports:    []string{"6379:6379"},
                HealthCheck: &amp;DockerHealthCheck{
                        Test:     []string{"CMD", "redis-cli", "--raw", "incr", "ping"},
                        Interval: "30s",
                        Timeout:  "10s",
                        Retries:  3,
                },
        }

        // Add volumes
        composeConfig.Volumes["postgres-data"] = &amp;DockerVolumeConfig{}
        composeConfig.Volumes["redis-data"] = &amp;DockerVolumeConfig{}
}</span>

// formatDuration formats a time.Duration to docker-compose format
func formatDuration(d time.Duration) string <span class="cov0" title="0">{
        if d == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return d.String()</span>
}

// writeComposeFile writes the docker-compose configuration to a file
func (do *DockerOrchestrator) writeComposeFile(config *DockerComposeConfig, path string) error <span class="cov0" title="0">{
        file, err := os.Create(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        encoder := yaml.NewEncoder(file)
        encoder.SetIndent(2)
        return encoder.Encode(config)</span>
}

// DeployWithCompose deploys using docker-compose
func (do *DockerOrchestrator) DeployWithCompose(ctx context.Context, composePath string) error <span class="cov0" title="0">{
        do.logger.Println("Starting docker-compose deployment...")

        // Change to compose directory
        composeDir := filepath.Dir(composePath)
        oldDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = os.Chdir(oldDir) }</span>()

        <span class="cov0" title="0">if err := os.Chdir(composeDir); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to change to compose directory: %w", err)
        }</span>

        // Pull images
        <span class="cov0" title="0">if err := do.runComposeCommand(ctx, "pull"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to pull images: %w", err)
        }</span>

        // Start services
        <span class="cov0" title="0">if err := do.runComposeCommand(ctx, "up", "-d"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start services: %w", err)
        }</span>

        // Wait for services to be healthy
        <span class="cov0" title="0">if err := do.waitForServicesHealthy(ctx, composeDir); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("services failed health checks: %w", err)
        }</span>

        <span class="cov0" title="0">do.emitEvent(events.Event{
                Type:      "docker_deployment_completed",
                SessionID: "system",
                Message:   "Docker-compose deployment completed successfully",
                Data: map[string]interface{}{
                        "compose_file": composePath,
                },
        })

        return nil</span>
}

// runComposeCommand runs a docker-compose command
func (do *DockerOrchestrator) runComposeCommand(ctx context.Context, args ...string) error <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, "docker-compose", args...)
        cmd.Dir = do.composeDir

        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("docker-compose command failed: %w\nOutput: %s", err, string(output))
        }</span>

        <span class="cov0" title="0">do.logger.Printf("docker-compose command succeeded: %s", strings.Join(args, " "))
        return nil</span>
}

// waitForServicesHealthy waits for all services to pass health checks
func (do *DockerOrchestrator) waitForServicesHealthy(ctx context.Context, composeDir string) error <span class="cov0" title="0">{
        do.logger.Println("Waiting for services to become healthy...")

        timeout := time.After(10 * time.Minute)
        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                case &lt;-timeout:<span class="cov0" title="0">
                        return fmt.Errorf("timeout waiting for services to become healthy")</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if healthy, err := do.checkServicesHealth(ctx, composeDir); err != nil </span><span class="cov0" title="0">{
                                do.logger.Printf("Health check error: %v", err)
                        }</span> else<span class="cov0" title="0"> if healthy </span><span class="cov0" title="0">{
                                do.logger.Println("All services are healthy!")
                                return nil
                        }</span>
                }
        }
}

// checkServicesHealth checks if all services are healthy
func (do *DockerOrchestrator) checkServicesHealth(ctx context.Context, composeDir string) (bool, error) <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, "docker-compose", "ps", "--format", "json")
        cmd.Dir = composeDir

        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // Parse the JSON output to check service states
        // This is a simplified check - in production you'd parse the JSON properly
        <span class="cov0" title="0">outputStr := string(output)
        if strings.Contains(outputStr, "healthy") || strings.Contains(outputStr, "running") </span><span class="cov0" title="0">{
                return true, nil
        }</span>

        <span class="cov0" title="0">return false, nil</span>
}

// ScaleService scales a service to the specified number of replicas
func (do *DockerOrchestrator) ScaleService(ctx context.Context, serviceName string, replicas int) error <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, "docker-compose", "up", "-d", "--scale", fmt.Sprintf("%s=%d", serviceName, replicas))
        cmd.Dir = do.composeDir

        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to scale service: %w\nOutput: %s", err, string(output))
        }</span>

        <span class="cov0" title="0">do.logger.Printf("Scaled service %s to %d replicas", serviceName, replicas)
        return nil</span>
}

// GetServiceLogs retrieves logs from a specific service
func (do *DockerOrchestrator) GetServiceLogs(ctx context.Context, serviceName string, lines int) (string, error) <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, "docker-compose", "logs", "--tail", fmt.Sprintf("%d", lines), serviceName)
        cmd.Dir = do.composeDir

        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get service logs: %w", err)
        }</span>

        <span class="cov0" title="0">return string(output), nil</span>
}

// StopDeployment stops the entire deployment
func (do *DockerOrchestrator) StopDeployment(ctx context.Context) error <span class="cov0" title="0">{
        do.logger.Println("Stopping docker-compose deployment...")

        cmd := exec.CommandContext(ctx, "docker-compose", "down")
        cmd.Dir = do.composeDir

        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stop deployment: %w\nOutput: %s", err, string(output))
        }</span>

        <span class="cov0" title="0">do.logger.Println("Deployment stopped successfully")
        return nil</span>
}

// UpdateService updates a service to a new image version
func (do *DockerOrchestrator) UpdateService(ctx context.Context, serviceName, newImage string) error <span class="cov0" title="0">{
        do.logger.Printf("Updating service %s to image %s...", serviceName, newImage)

        // Pull the new image
        if err := do.runComposeCommand(ctx, "pull", serviceName); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to pull new image for service %s: %w", serviceName, err)
        }</span>

        // Update the service
        <span class="cov0" title="0">if err := do.runComposeCommand(ctx, "up", "-d", serviceName); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update service %s: %w", serviceName, err)
        }</span>

        // Wait for the service to be healthy
        <span class="cov0" title="0">if err := do.waitForServiceHealthy(ctx, serviceName); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("service %s failed health check after update: %w", serviceName, err)
        }</span>

        <span class="cov0" title="0">do.emitEvent(events.Event{
                Type:      "service_updated",
                SessionID: "system",
                Message:   fmt.Sprintf("Service %s updated to %s", serviceName, newImage),
                Data: map[string]interface{}{
                        "service": serviceName,
                        "image":   newImage,
                },
        })

        do.logger.Printf("Service %s updated successfully", serviceName)
        return nil</span>
}

// RestartService restarts a specific service
func (do *DockerOrchestrator) RestartService(ctx context.Context, serviceName string) error <span class="cov0" title="0">{
        do.logger.Printf("Restarting service %s...", serviceName)

        if err := do.runComposeCommand(ctx, "restart", serviceName); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to restart service %s: %w", serviceName, err)
        }</span>

        // Wait for the service to be healthy
        <span class="cov0" title="0">if err := do.waitForServiceHealthy(ctx, serviceName); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("service %s failed health check after restart: %w", serviceName, err)
        }</span>

        <span class="cov0" title="0">do.emitEvent(events.Event{
                Type:      "service_restarted",
                SessionID: "system",
                Message:   fmt.Sprintf("Service %s restarted", serviceName),
                Data: map[string]interface{}{
                        "service": serviceName,
                },
        })

        do.logger.Printf("Service %s restarted successfully", serviceName)
        return nil</span>
}

// UpdateAllServices updates all services to their latest images
func (do *DockerOrchestrator) UpdateAllServices(ctx context.Context) error <span class="cov0" title="0">{
        do.logger.Println("Updating all services...")

        // Pull all images
        if err := do.runComposeCommand(ctx, "pull"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to pull all images: %w", err)
        }</span>

        // Restart all services
        <span class="cov0" title="0">if err := do.runComposeCommand(ctx, "up", "-d"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to restart all services: %w", err)
        }</span>

        // Wait for all services to be healthy
        <span class="cov0" title="0">if err := do.waitForServicesHealthy(ctx, do.composeDir); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("services failed health checks after update: %w", err)
        }</span>

        <span class="cov0" title="0">do.emitEvent(events.Event{
                Type:      "all_services_updated",
                SessionID: "system",
                Message:   "All services updated successfully",
        })

        do.logger.Println("All services updated successfully")
        return nil</span>
}

// RestartAllServices restarts all services
func (do *DockerOrchestrator) RestartAllServices(ctx context.Context) error <span class="cov0" title="0">{
        do.logger.Println("Restarting all services...")

        if err := do.runComposeCommand(ctx, "restart"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to restart all services: %w", err)
        }</span>

        // Wait for all services to be healthy
        <span class="cov0" title="0">if err := do.waitForServicesHealthy(ctx, do.composeDir); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("services failed health checks after restart: %w", err)
        }</span>

        <span class="cov0" title="0">do.emitEvent(events.Event{
                Type:      "all_services_restarted",
                SessionID: "system",
                Message:   "All services restarted successfully",
        })

        do.logger.Println("All services restarted successfully")
        return nil</span>
}

// waitForServiceHealthy waits for a specific service to become healthy
func (do *DockerOrchestrator) waitForServiceHealthy(ctx context.Context, serviceName string) error <span class="cov0" title="0">{
        do.logger.Printf("Waiting for service %s to become healthy...", serviceName)

        timeout := time.After(5 * time.Minute)
        ticker := time.NewTicker(10 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                case &lt;-timeout:<span class="cov0" title="0">
                        return fmt.Errorf("timeout waiting for service %s to become healthy", serviceName)</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if healthy, err := do.checkServiceHealth(ctx, serviceName); err != nil </span><span class="cov0" title="0">{
                                do.logger.Printf("Health check error for %s: %v", serviceName, err)
                        }</span> else<span class="cov0" title="0"> if healthy </span><span class="cov0" title="0">{
                                do.logger.Printf("Service %s is healthy!", serviceName)
                                return nil
                        }</span>
                }
        }
}

// checkServiceHealth checks if a specific service is healthy
func (do *DockerOrchestrator) checkServiceHealth(ctx context.Context, serviceName string) (bool, error) <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, "docker-compose", "ps", serviceName, "--format", "json")
        cmd.Dir = do.composeDir

        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // Parse the JSON output to check service state
        <span class="cov0" title="0">outputStr := string(output)
        if strings.Contains(outputStr, "healthy") || strings.Contains(outputStr, "running") </span><span class="cov0" title="0">{
                return true, nil
        }</span>

        <span class="cov0" title="0">return false, nil</span>
}

// GetServiceStatus returns the status of a specific service
func (do *DockerOrchestrator) GetServiceStatus(ctx context.Context, serviceName string) (string, error) <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, "docker-compose", "ps", serviceName, "--format", "{{.State}}")
        cmd.Dir = do.composeDir

        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get service status: %w", err)
        }</span>

        <span class="cov0" title="0">return strings.TrimSpace(string(output)), nil</span>
}

// Cleanup removes the generated compose files and temporary data
func (do *DockerOrchestrator) Cleanup() error <span class="cov0" title="0">{
        do.logger.Println("Cleaning up deployment files...")

        if err := os.RemoveAll(do.composeDir); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cleanup compose directory: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// emitEvent emits an event if event bus is available
func (do *DockerOrchestrator) emitEvent(event events.Event) <span class="cov0" title="0">{
        if do.eventBus != nil </span><span class="cov0" title="0">{
                do.eventBus.Publish(event)
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package deployment

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "net"
        "sync"
        "time"

        "digital.vasic.translator/internal/config"
)

// NetworkDiscoverer handles network discovery and service broadcasting
type NetworkDiscoverer struct {
        config        *config.Config
        logger        *log.Logger
        broadcastAddr string
        discoveryPort int
        services      map[string]*NetworkService
        broadcastConn *net.UDPConn
        discoveryConn *net.UDPConn
        mu            sync.RWMutex
        ctx           context.Context
        cancel        context.CancelFunc
        wg            sync.WaitGroup
}

// NewNetworkDiscoverer creates a new network discoverer
func NewNetworkDiscoverer(cfg *config.Config, logger *log.Logger) *NetworkDiscoverer <span class="cov8" title="1">{
        ctx, cancel := context.WithCancel(context.Background())

        return &amp;NetworkDiscoverer{
                config:        cfg,
                logger:        logger,
                broadcastAddr: "255.255.255.255",
                discoveryPort: 9999,
                services:      make(map[string]*NetworkService),
                ctx:           ctx,
                cancel:        cancel,
        }
}</span>

// StartBroadcasting starts broadcasting service configurations
func (nd *NetworkDiscoverer) StartBroadcasting(ctx context.Context, instances map[string]*DeployedInstance) error <span class="cov8" title="1">{
        nd.logger.Println("Starting service broadcasting...")

        // Create UDP broadcast connection
        conn, err := nd.createBroadcastConnection()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create broadcast connection: %w", err)
        }</span>
        <span class="cov8" title="1">nd.broadcastConn = conn

        nd.wg.Add(1)
        go nd.broadcastLoop(ctx, instances)

        nd.logger.Println("Service broadcasting started successfully")
        return nil</span>
}

// StartDiscovery starts listening for service discovery broadcasts
func (nd *NetworkDiscoverer) StartDiscovery(ctx context.Context) error <span class="cov8" title="1">{
        nd.logger.Println("Starting service discovery...")

        // Create UDP discovery connection
        conn, err := nd.createDiscoveryConnection()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create discovery connection: %w", err)
        }</span>
        <span class="cov8" title="1">nd.discoveryConn = conn

        nd.wg.Add(1)
        go nd.discoveryLoop(ctx)

        nd.logger.Println("Service discovery started successfully")
        return nil</span>
}

// createBroadcastConnection creates a UDP connection for broadcasting
func (nd *NetworkDiscoverer) createBroadcastConnection() (*net.UDPConn, error) <span class="cov8" title="1">{
        addr, err := net.ResolveUDPAddr("udp", fmt.Sprintf("%s:%d", nd.broadcastAddr, nd.discoveryPort))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">conn, err := net.DialUDP("udp", nil, addr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return conn, nil</span>
}

// createDiscoveryConnection creates a UDP connection for discovery listening
func (nd *NetworkDiscoverer) createDiscoveryConnection() (*net.UDPConn, error) <span class="cov8" title="1">{
        addr, err := net.ResolveUDPAddr("udp", fmt.Sprintf(":%d", nd.discoveryPort))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">conn, err := net.ListenUDP("udp", addr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return conn, nil</span>
}

// broadcastLoop continuously broadcasts service information
func (nd *NetworkDiscoverer) broadcastLoop(ctx context.Context, instances map[string]*DeployedInstance) <span class="cov8" title="1">{
        defer nd.wg.Done()
        ticker := time.NewTicker(30 * time.Second) // Broadcast every 30 seconds
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-nd.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        nd.broadcastServices(instances)</span>
                }
        }
}

// broadcastServices broadcasts all known services
func (nd *NetworkDiscoverer) broadcastServices(instances map[string]*DeployedInstance) <span class="cov0" title="0">{
        for _, instance := range instances </span><span class="cov0" title="0">{
                message := BroadcastMessage{
                        ServiceID: instance.ID,
                        Type:      nd.determineServiceType(instance.ID),
                        Host:      instance.Host,
                        Port:      instance.Port,
                        Protocol:  "https",
                        Capabilities: map[string]interface{}{
                                "container_id": instance.ContainerID,
                                "status":       instance.Status,
                        },
                        Timestamp: time.Now(),
                }

                if err := nd.sendBroadcastMessage(message); err != nil </span><span class="cov0" title="0">{
                        nd.logger.Printf("Failed to broadcast service %s: %v", instance.ID, err)
                }</span>
        }
}

// sendBroadcastMessage sends a single broadcast message
func (nd *NetworkDiscoverer) sendBroadcastMessage(message BroadcastMessage) error <span class="cov0" title="0">{
        data, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = nd.broadcastConn.Write(data)
        return err</span>
}

// discoveryLoop listens for incoming discovery broadcasts
func (nd *NetworkDiscoverer) discoveryLoop(ctx context.Context) <span class="cov8" title="1">{
        defer nd.wg.Done()

        buffer := make([]byte, 4096)

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-nd.ctx.Done():<span class="cov8" title="1">
                        return</span>
                default:<span class="cov8" title="1">
                        if err := nd.discoveryConn.SetReadDeadline(time.Now().Add(1 * time.Second)); err != nil </span><span class="cov0" title="0">{
                                nd.logger.Printf("Failed to set read deadline: %v", err)
                                continue</span>
                        }

                        <span class="cov8" title="1">n, addr, err := nd.discoveryConn.ReadFromUDP(buffer)
                        if err != nil </span><span class="cov8" title="1">{
                                if netErr, ok := err.(net.Error); ok &amp;&amp; netErr.Timeout() </span><span class="cov0" title="0">{
                                        continue</span> // Timeout is expected, continue listening
                                }
                                <span class="cov8" title="1">nd.logger.Printf("Failed to read UDP message: %v", err)
                                continue</span>
                        }

                        <span class="cov0" title="0">if err := nd.handleDiscoveryMessage(buffer[:n], addr); err != nil </span><span class="cov0" title="0">{
                                nd.logger.Printf("Failed to handle discovery message: %v", err)
                        }</span>
                }
        }
}

// handleDiscoveryMessage processes an incoming discovery message
func (nd *NetworkDiscoverer) handleDiscoveryMessage(data []byte, addr *net.UDPAddr) error <span class="cov0" title="0">{
        var message BroadcastMessage
        if err := json.Unmarshal(data, &amp;message); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal broadcast message: %w", err)
        }</span>

        // Skip our own broadcasts
        <span class="cov0" title="0">if nd.isOwnService(message.ServiceID) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">service := &amp;NetworkService{
                ID:           message.ServiceID,
                Name:         message.ServiceID,
                Host:         message.Host,
                Port:         message.Port,
                Type:         message.Type,
                Protocol:     message.Protocol,
                Capabilities: message.Capabilities,
                LastSeen:     time.Now(),
                TTL:          90 * time.Second, // 90 seconds TTL
        }

        nd.mu.Lock()
        nd.services[message.ServiceID] = service
        nd.mu.Unlock()

        nd.logger.Printf("Discovered service: %s (%s:%d)", message.ServiceID, message.Host, message.Port)

        return nil</span>
}

// isOwnService checks if the service ID belongs to this instance
func (nd *NetworkDiscoverer) isOwnService(serviceID string) bool <span class="cov0" title="0">{
        // This would need to be implemented based on how service IDs are generated
        // For now, we'll assume all services are external
        return false
}</span>

// determineServiceType determines the service type from instance ID
func (nd *NetworkDiscoverer) determineServiceType(instanceID string) string <span class="cov8" title="1">{
        if contains(instanceID, "main") || contains(instanceID, "coordinator") </span><span class="cov8" title="1">{
                return "coordinator"
        }</span>
        <span class="cov8" title="1">if contains(instanceID, "worker") </span><span class="cov8" title="1">{
                return "worker"
        }</span>
        <span class="cov8" title="1">return "unknown"</span>
}

// contains checks if a string contains a substring (case-insensitive)
func contains(s, substr string) bool <span class="cov8" title="1">{
        return len(s) &gt;= len(substr) &amp;&amp; (s == substr || len(s) &gt; len(substr) &amp;&amp;
                (s[:len(substr)] == substr || s[len(s)-len(substr):] == substr ||
                        containsMiddle(s, substr)))
}</span>

func containsMiddle(s, substr string) bool <span class="cov8" title="1">{
        for i := 0; i &lt;= len(s)-len(substr); i++ </span><span class="cov8" title="1">{
                if s[i:i+len(substr)] == substr </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// GetDiscoveredServices returns all discovered services
func (nd *NetworkDiscoverer) GetDiscoveredServices() map[string]*NetworkService <span class="cov8" title="1">{
        nd.mu.RLock()
        defer nd.mu.RUnlock()

        // Clean up expired services
        now := time.Now()
        for id, service := range nd.services </span><span class="cov8" title="1">{
                if now.Sub(service.LastSeen) &gt; service.TTL </span><span class="cov8" title="1">{
                        delete(nd.services, id)
                }</span>
        }

        <span class="cov8" title="1">result := make(map[string]*NetworkService)
        for k, v := range nd.services </span><span class="cov0" title="0">{
                result[k] = v
        }</span>
        <span class="cov8" title="1">return result</span>
}

// QueryService queries a specific service for its capabilities
func (nd *NetworkDiscoverer) QueryService(ctx context.Context, service *NetworkService) (map[string]interface{}, error) <span class="cov0" title="0">{
        // This would implement HTTP queries to discovered services
        // For now, return the cached capabilities
        return service.Capabilities, nil
}</span>

// Close shuts down the network discoverer
func (nd *NetworkDiscoverer) Close() error <span class="cov8" title="1">{
        nd.logger.Println("Shutting down network discoverer...")

        nd.cancel()

        if nd.broadcastConn != nil </span><span class="cov8" title="1">{
                nd.broadcastConn.Close()
        }</span>

        <span class="cov8" title="1">if nd.discoveryConn != nil </span><span class="cov8" title="1">{
                nd.discoveryConn.Close()
        }</span>

        <span class="cov8" title="1">nd.wg.Wait()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package deployment

import (
        "context"
        "fmt"
        "log"
        "net"
        "os"
        "strings"
        "sync"
        "time"

        "digital.vasic.translator/internal/config"
        "digital.vasic.translator/pkg/events"
)

// DeploymentOrchestrator manages automated deployment of distributed instances
type DeploymentOrchestrator struct {
        config      *config.Config
        eventBus    *events.EventBus
        deployer    *SSHDeployer
        discoverer  *NetworkDiscoverer
        apiLogger   *APICommunicationLogger
        logger      *log.Logger
        mu          sync.RWMutex
        initialized bool
        deployed    map[string]*DeployedInstance
}

// DeployedInstance represents a deployed instance
type DeployedInstance struct {
        ID          string
        Host        string
        Port        int
        ContainerID string
        Status      string
        Config      *DeploymentConfig
        LastSeen    time.Time
        mu          sync.RWMutex
}

// DeploymentConfig holds deployment configuration for a single instance
type DeploymentConfig struct {
        Host          string
        User          string
        Password      string
        SSHKeyPath    string
        DockerImage   string
        ContainerName string
        Ports         []PortMapping
        Environment   map[string]string
        Volumes       []VolumeMapping
        Networks      []string
        RestartPolicy string
        HealthCheck   *HealthCheckConfig
}

// PortMapping represents port mapping configuration
type PortMapping struct {
        HostPort      int
        ContainerPort int
        Protocol      string
}

// VolumeMapping represents volume mapping configuration
type VolumeMapping struct {
        HostPath      string
        ContainerPath string
        ReadOnly      bool
}

// HealthCheckConfig represents health check configuration
type HealthCheckConfig struct {
        Test        []string
        Interval    time.Duration
        Timeout     time.Duration
        Retries     int
        StartPeriod time.Duration
}

// NewDeploymentOrchestrator creates a new deployment orchestrator
func NewDeploymentOrchestrator(cfg *config.Config, eventBus *events.EventBus) *DeploymentOrchestrator <span class="cov8" title="1">{
        logger := log.New(os.Stdout, "[DEPLOYMENT] ", log.LstdFlags)

        deployer := NewSSHDeployer(logger)
        discoverer := NewNetworkDiscoverer(cfg, logger)

        // Initialize API communication logger
        apiLogger, err := NewAPICommunicationLogger("workers_api_communication.log")
        if err != nil </span><span class="cov0" title="0">{
                logger.Printf("Warning: failed to initialize API logger: %v", err)
                apiLogger = nil
        }</span>

        <span class="cov8" title="1">return &amp;DeploymentOrchestrator{
                config:     cfg,
                eventBus:   eventBus,
                deployer:   deployer,
                discoverer: discoverer,
                apiLogger:  apiLogger,
                logger:     logger,
                deployed:   make(map[string]*DeployedInstance),
        }</span>
}

// DeployDistributedSystem deploys the complete distributed system
func (do *DeploymentOrchestrator) DeployDistributedSystem(ctx context.Context, deploymentPlan *DeploymentPlan) error <span class="cov8" title="1">{
        do.logger.Println("Starting automated distributed system deployment...")

        // Validate deployment plan
        if err := do.validateDeploymentPlan(deploymentPlan); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid deployment plan: %w", err)
        }</span>

        // Deploy main instance first
        <span class="cov0" title="0">if err := do.deployMainInstance(ctx, deploymentPlan.Main); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to deploy main instance: %w", err)
        }</span>

        // Deploy worker instances
        <span class="cov0" title="0">for i, worker := range deploymentPlan.Workers </span><span class="cov0" title="0">{
                if err := do.deployWorkerInstance(ctx, worker, i+1); err != nil </span><span class="cov0" title="0">{
                        do.logger.Printf("Failed to deploy worker %d: %v", i+1, err)
                        continue</span>
                }
        }

        // Wait for all instances to be healthy
        <span class="cov0" title="0">if err := do.waitForSystemHealth(ctx, deploymentPlan); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("system health check failed: %w", err)
        }</span>

        // Initialize network discovery and broadcasting
        <span class="cov0" title="0">if err := do.initializeNetworkDiscovery(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize network discovery: %w", err)
        }</span>

        <span class="cov0" title="0">do.emitEvent(events.Event{
                Type:      "deployment_completed",
                SessionID: "system",
                Message:   "Distributed system deployment completed successfully",
                Data: map[string]interface{}{
                        "main_instance":    deploymentPlan.Main.ContainerName,
                        "worker_instances": len(deploymentPlan.Workers),
                        "total_instances":  len(do.deployed),
                },
        })

        return nil</span>
}

// deployMainInstance deploys the main coordinator instance
func (do *DeploymentOrchestrator) deployMainInstance(ctx context.Context, cfg *DeploymentConfig) error <span class="cov0" title="0">{
        do.logger.Printf("Deploying main instance to %s...", cfg.Host)

        // Find available port for main instance
        port, err := do.findAvailablePort(cfg.Host, 8443)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to find available port: %w", err)
        }</span>

        // Update port mapping
        <span class="cov0" title="0">cfg.Ports[0].HostPort = port

        // Deploy via SSH
        containerID, err := do.deployer.DeployInstance(ctx, cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("SSH deployment failed: %w", err)
        }</span>

        // Register deployed instance
        <span class="cov0" title="0">instance := &amp;DeployedInstance{
                ID:          cfg.ContainerName,
                Host:        cfg.Host,
                Port:        port,
                ContainerID: containerID,
                Status:      "deploying",
                Config:      cfg,
                LastSeen:    time.Now(),
        }

        do.mu.Lock()
        do.deployed[cfg.ContainerName] = instance
        do.mu.Unlock()

        do.logger.Printf("Main instance deployed successfully: %s (port %d)", containerID[:12], port)
        return nil</span>
}

// deployWorkerInstance deploys a worker instance
func (do *DeploymentOrchestrator) deployWorkerInstance(ctx context.Context, cfg *DeploymentConfig, index int) error <span class="cov0" title="0">{
        do.logger.Printf("Deploying worker instance %d to %s...", index, cfg.Host)

        // Find available port for worker
        port, err := do.findAvailablePort(cfg.Host, 8443+index)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to find available port for worker %d: %w", index, err)
        }</span>

        // Update port mapping
        <span class="cov0" title="0">cfg.Ports[0].HostPort = port

        // Set worker-specific environment variables
        if cfg.Environment == nil </span><span class="cov0" title="0">{
                cfg.Environment = make(map[string]string)
        }</span>
        <span class="cov0" title="0">cfg.Environment["WORKER_INDEX"] = fmt.Sprintf("%d", index)
        cfg.Environment["MAIN_HOST"] = do.getMainInstanceHost()

        // Deploy via SSH
        containerID, err := do.deployer.DeployInstance(ctx, cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("SSH deployment failed for worker %d: %w", index, err)
        }</span>

        // Register deployed instance
        <span class="cov0" title="0">instance := &amp;DeployedInstance{
                ID:          cfg.ContainerName,
                Host:        cfg.Host,
                Port:        port,
                ContainerID: containerID,
                Status:      "deploying",
                Config:      cfg,
                LastSeen:    time.Now(),
        }

        do.mu.Lock()
        do.deployed[cfg.ContainerName] = instance
        do.mu.Unlock()

        do.logger.Printf("Worker instance %d deployed successfully: %s (port %d)", index, containerID[:12], port)
        return nil</span>
}

// findAvailablePort finds the first available port starting from preferredPort
func (do *DeploymentOrchestrator) findAvailablePort(host string, preferredPort int) (int, error) <span class="cov8" title="1">{
        for port := preferredPort; port &lt; preferredPort+100; port++ </span><span class="cov8" title="1">{
                if do.isPortAvailable(host, port) </span><span class="cov8" title="1">{
                        return port, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, fmt.Errorf("no available ports found in range %d-%d", preferredPort, preferredPort+99)</span>
}

// isPortAvailable checks if a port is available on the given host
func (do *DeploymentOrchestrator) isPortAvailable(host string, port int) bool <span class="cov8" title="1">{
        address := net.JoinHostPort(host, fmt.Sprintf("%d", port))
        conn, err := net.DialTimeout("tcp", address, 1*time.Second)
        if err != nil </span><span class="cov8" title="1">{
                return true // Port is available if we can't connect
        }</span>
        <span class="cov0" title="0">conn.Close()
        return false</span> // Port is in use
}

// waitForSystemHealth waits for all deployed instances to become healthy
func (do *DeploymentOrchestrator) waitForSystemHealth(ctx context.Context, plan *DeploymentPlan) error <span class="cov0" title="0">{
        do.logger.Println("Waiting for system health checks...")

        timeout := time.After(5 * time.Minute)
        ticker := time.NewTicker(10 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                case &lt;-timeout:<span class="cov0" title="0">
                        return fmt.Errorf("timeout waiting for system health")</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        allHealthy := true

                        do.mu.RLock()
                        for id, instance := range do.deployed </span><span class="cov0" title="0">{
                                healthy, err := do.checkInstanceHealth(ctx, instance)
                                if err != nil </span><span class="cov0" title="0">{
                                        do.logger.Printf("Health check failed for %s: %v", id, err)
                                        allHealthy = false
                                        continue</span>
                                }

                                <span class="cov0" title="0">if !healthy </span><span class="cov0" title="0">{
                                        allHealthy = false
                                        continue</span>
                                }

                                <span class="cov0" title="0">instance.mu.Lock()
                                instance.Status = "healthy"
                                instance.LastSeen = time.Now()
                                instance.mu.Unlock()</span>
                        }
                        <span class="cov0" title="0">do.mu.RUnlock()

                        if allHealthy </span><span class="cov0" title="0">{
                                do.logger.Println("All instances are healthy!")
                                return nil
                        }</span>
                }
        }
}

// checkInstanceHealth performs health check on a deployed instance
func (do *DeploymentOrchestrator) checkInstanceHealth(ctx context.Context, instance *DeployedInstance) (bool, error) <span class="cov0" title="0">{
        return do.deployer.CheckInstanceHealth(ctx, instance.Host, instance.Port)
}</span>

// initializeNetworkDiscovery initializes network discovery and broadcasting
func (do *DeploymentOrchestrator) initializeNetworkDiscovery(ctx context.Context) error <span class="cov0" title="0">{
        do.logger.Println("Initializing network discovery and broadcasting...")

        // Start broadcasting service configurations
        if err := do.discoverer.StartBroadcasting(ctx, do.deployed); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start broadcasting: %w", err)
        }</span>

        // Start discovery listener
        <span class="cov0" title="0">if err := do.discoverer.StartDiscovery(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start discovery: %w", err)
        }</span>

        <span class="cov0" title="0">do.logger.Println("Network discovery initialized successfully")
        return nil</span>
}

// validateDeploymentPlan validates the deployment plan
func (do *DeploymentOrchestrator) validateDeploymentPlan(plan *DeploymentPlan) error <span class="cov8" title="1">{
        if plan.Main == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("main instance configuration is required")
        }</span>

        <span class="cov8" title="1">if len(plan.Workers) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("at least one worker instance is required")
        }</span>

        // Validate main instance config
        <span class="cov8" title="1">if err := do.validateInstanceConfig(plan.Main); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid main instance config: %w", err)
        }</span>

        // Validate worker instance configs
        <span class="cov8" title="1">for i, worker := range plan.Workers </span><span class="cov8" title="1">{
                if err := do.validateInstanceConfig(worker); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid worker %d config: %w", i+1, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// validateInstanceConfig validates a single instance configuration
func (do *DeploymentOrchestrator) validateInstanceConfig(cfg *DeploymentConfig) error <span class="cov8" title="1">{
        if cfg.Host == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("host is required")
        }</span>

        <span class="cov8" title="1">if cfg.User == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("user is required")
        }</span>

        <span class="cov8" title="1">if cfg.DockerImage == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("docker image is required")
        }</span>

        <span class="cov8" title="1">if cfg.ContainerName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("container name is required")
        }</span>

        <span class="cov8" title="1">if len(cfg.Ports) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("at least one port mapping is required")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// getMainInstanceHost returns the host of the main instance
func (do *DeploymentOrchestrator) getMainInstanceHost() string <span class="cov0" title="0">{
        do.mu.RLock()
        defer do.mu.RUnlock()

        for _, instance := range do.deployed </span><span class="cov0" title="0">{
                if strings.Contains(instance.ID, "main") </span><span class="cov0" title="0">{
                        return instance.Host
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// GetDeployedInstances returns all deployed instances
func (do *DeploymentOrchestrator) GetDeployedInstances() map[string]*DeployedInstance <span class="cov8" title="1">{
        do.mu.RLock()
        defer do.mu.RUnlock()

        result := make(map[string]*DeployedInstance)
        for k, v := range do.deployed </span><span class="cov8" title="1">{
                result[k] = v
        }</span>
        <span class="cov8" title="1">return result</span>
}

// emitEvent emits an event if event bus is available
func (do *DeploymentOrchestrator) emitEvent(event events.Event) <span class="cov0" title="0">{
        if do.eventBus != nil </span><span class="cov0" title="0">{
                do.eventBus.Publish(event)
        }</span>
}

// UpdateService updates a specific service to a new image version
func (do *DeploymentOrchestrator) UpdateService(ctx context.Context, serviceName, newImage string) error <span class="cov0" title="0">{
        do.logger.Printf("Updating service %s to image %s...", serviceName, newImage)

        do.mu.RLock()
        instance, exists := do.deployed[serviceName]
        do.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("service %s not found in deployed instances", serviceName)
        }</span>

        // Update the instance configuration with new image
        <span class="cov0" title="0">instance.Config.DockerImage = newImage

        // Redeploy the instance
        containerID, err := do.deployer.UpdateInstance(ctx, instance.Config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update service %s: %w", serviceName, err)
        }</span>

        // Update instance information
        <span class="cov0" title="0">instance.mu.Lock()
        instance.ContainerID = containerID
        instance.Status = "updating"
        instance.LastSeen = time.Now()
        instance.mu.Unlock()

        // Wait for the instance to become healthy
        if err := do.waitForInstanceHealth(ctx, instance, 5*time.Minute); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("service %s failed health check after update: %w", serviceName, err)
        }</span>

        <span class="cov0" title="0">instance.mu.Lock()
        instance.Status = "healthy"
        instance.LastSeen = time.Now()
        instance.mu.Unlock()

        do.emitEvent(events.Event{
                Type:      "service_updated",
                SessionID: "system",
                Message:   fmt.Sprintf("Service %s updated to %s", serviceName, newImage),
                Data: map[string]interface{}{
                        "service":      serviceName,
                        "image":        newImage,
                        "container_id": containerID,
                },
        })

        do.logger.Printf("Service %s updated successfully to %s", serviceName, newImage)
        return nil</span>
}

// UpdateAllServices updates all deployed services to their latest images
func (do *DeploymentOrchestrator) UpdateAllServices(ctx context.Context) error <span class="cov0" title="0">{
        do.logger.Println("Updating all services...")

        do.mu.RLock()
        instances := make([]*DeployedInstance, 0, len(do.deployed))
        for _, instance := range do.deployed </span><span class="cov0" title="0">{
                instances = append(instances, instance)
        }</span>
        <span class="cov0" title="0">do.mu.RUnlock()

        for _, instance := range instances </span><span class="cov0" title="0">{
                if err := do.UpdateService(ctx, instance.ID, instance.Config.DockerImage+":latest"); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update service %s: %w", instance.ID, err)
                }</span>
        }

        <span class="cov0" title="0">do.emitEvent(events.Event{
                Type:      "all_services_updated",
                SessionID: "system",
                Message:   "All services updated successfully",
        })

        do.logger.Println("All services updated successfully")
        return nil</span>
}

// RestartService restarts a specific service
func (do *DeploymentOrchestrator) RestartService(ctx context.Context, serviceName string) error <span class="cov0" title="0">{
        do.logger.Printf("Restarting service %s...", serviceName)

        do.mu.RLock()
        instance, exists := do.deployed[serviceName]
        do.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("service %s not found in deployed instances", serviceName)
        }</span>

        // Restart the instance
        <span class="cov0" title="0">if err := do.deployer.RestartInstance(ctx, instance.Config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to restart service %s: %w", serviceName, err)
        }</span>

        // Update instance status
        <span class="cov0" title="0">instance.mu.Lock()
        instance.Status = "restarting"
        instance.LastSeen = time.Now()
        instance.mu.Unlock()

        // Wait for the instance to become healthy
        if err := do.waitForInstanceHealth(ctx, instance, 2*time.Minute); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("service %s failed health check after restart: %w", serviceName, err)
        }</span>

        <span class="cov0" title="0">instance.mu.Lock()
        instance.Status = "healthy"
        instance.LastSeen = time.Now()
        instance.mu.Unlock()

        do.emitEvent(events.Event{
                Type:      "service_restarted",
                SessionID: "system",
                Message:   fmt.Sprintf("Service %s restarted", serviceName),
                Data: map[string]interface{}{
                        "service": serviceName,
                },
        })

        do.logger.Printf("Service %s restarted successfully", serviceName)
        return nil</span>
}

// RestartAllServices restarts all deployed services
func (do *DeploymentOrchestrator) RestartAllServices(ctx context.Context) error <span class="cov0" title="0">{
        do.logger.Println("Restarting all services...")

        do.mu.RLock()
        instances := make([]*DeployedInstance, 0, len(do.deployed))
        for _, instance := range do.deployed </span><span class="cov0" title="0">{
                instances = append(instances, instance)
        }</span>
        <span class="cov0" title="0">do.mu.RUnlock()

        for _, instance := range instances </span><span class="cov0" title="0">{
                if err := do.RestartService(ctx, instance.ID); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to restart service %s: %w", instance.ID, err)
                }</span>
        }

        <span class="cov0" title="0">do.emitEvent(events.Event{
                Type:      "all_services_restarted",
                SessionID: "system",
                Message:   "All services restarted successfully",
        })

        do.logger.Println("All services restarted successfully")
        return nil</span>
}

// waitForInstanceHealth waits for a specific instance to become healthy
func (do *DeploymentOrchestrator) waitForInstanceHealth(ctx context.Context, instance *DeployedInstance, timeout time.Duration) error <span class="cov0" title="0">{
        timeoutChan := time.After(timeout)
        ticker := time.NewTicker(5 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                case &lt;-timeoutChan:<span class="cov0" title="0">
                        return fmt.Errorf("timeout waiting for instance %s to become healthy", instance.ID)</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        healthy, err := do.checkInstanceHealth(ctx, instance)
                        if err != nil </span><span class="cov0" title="0">{
                                do.logger.Printf("Health check error for %s: %v", instance.ID, err)
                                continue</span>
                        }

                        <span class="cov0" title="0">if healthy </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }
        }
}

// Close shuts down the deployment orchestrator
func (do *DeploymentOrchestrator) Close() error <span class="cov8" title="1">{
        do.logger.Println("Shutting down deployment orchestrator...")

        if do.apiLogger != nil </span><span class="cov8" title="1">{
                do.apiLogger.Close()
        }</span>

        <span class="cov8" title="1">if do.discoverer != nil </span><span class="cov8" title="1">{
                do.discoverer.Close()
        }</span>

        <span class="cov8" title="1">if do.deployer != nil </span><span class="cov8" title="1">{
                do.deployer.Close()
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package deployment

import (
        "context"
        "fmt"
        "log"
        "net/http"
        "strings"
        "time"

        "golang.org/x/crypto/ssh"
)

// SSHDeployer handles SSH-based deployment of Docker containers
type SSHDeployer struct {
        logger *log.Logger
}

// NewSSHDeployer creates a new SSH deployer
func NewSSHDeployer(logger *log.Logger) *SSHDeployer <span class="cov8" title="1">{
        return &amp;SSHDeployer{
                logger: logger,
        }
}</span>

// DeployInstance deploys a Docker container instance via SSH
func (sd *SSHDeployer) DeployInstance(ctx context.Context, config *DeploymentConfig) (string, error) <span class="cov0" title="0">{
        sd.logger.Printf("Deploying instance %s to %s@%s", config.ContainerName, config.User, config.Host)

        // Establish SSH connection
        client, err := sd.connectSSH(config)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to connect to SSH: %w", err)
        }</span>
        <span class="cov0" title="0">defer client.Close()

        // Ensure Docker is installed and running
        if err := sd.ensureDocker(ctx, client); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to ensure Docker: %w", err)
        }</span>

        // Pull Docker image
        <span class="cov0" title="0">if err := sd.pullImage(ctx, client, config.DockerImage); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to pull image: %w", err)
        }</span>

        // Stop and remove existing container if it exists
        <span class="cov0" title="0">if err := sd.cleanupExistingContainer(ctx, client, config.ContainerName); err != nil </span><span class="cov0" title="0">{
                sd.logger.Printf("Warning: failed to cleanup existing container: %v", err)
        }</span>

        // Create and start container
        <span class="cov0" title="0">containerID, err := sd.createAndStartContainer(ctx, client, config)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create and start container: %w", err)
        }</span>

        <span class="cov0" title="0">sd.logger.Printf("Successfully deployed container %s", containerID[:12])
        return containerID, nil</span>
}

// connectSSH establishes SSH connection
func (sd *SSHDeployer) connectSSH(config *DeploymentConfig) (*ssh.Client, error) <span class="cov0" title="0">{
        // SSH client config
        sshConfig := &amp;ssh.ClientConfig{
                User: config.User,
                Auth: []ssh.AuthMethod{
                        ssh.Password(config.Password),
                },
                HostKeyCallback: ssh.InsecureIgnoreHostKey(), // In production, use proper host key verification
                Timeout:         30 * time.Second,
        }

        // Connect
        client, err := ssh.Dial("tcp", fmt.Sprintf("%s:22", config.Host), sshConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to dial SSH: %w", err)
        }</span>

        <span class="cov0" title="0">return client, nil</span>
}

// ensureDocker ensures Docker is installed and running
func (sd *SSHDeployer) ensureDocker(ctx context.Context, client *ssh.Client) error <span class="cov0" title="0">{
        session, err := client.NewSession()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer session.Close()

        // Check if Docker is installed
        if err := session.Run("which docker"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Docker is not installed on remote host")
        }</span>

        // Start Docker service if not running
        <span class="cov0" title="0">session, err = client.NewSession()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer session.Close()

        // Check Docker daemon status
        if err := session.Run("systemctl is-active --quiet docker"); err != nil </span><span class="cov0" title="0">{
                // Try to start Docker
                session, err = client.NewSession()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer session.Close()

                if err := session.Run("sudo systemctl start docker"); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to start Docker service: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// pullImage pulls the Docker image
func (sd *SSHDeployer) pullImage(ctx context.Context, client *ssh.Client, image string) error <span class="cov0" title="0">{
        session, err := client.NewSession()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer session.Close()

        cmd := fmt.Sprintf("docker pull %s", image)
        return session.Run(cmd)</span>
}

// cleanupExistingContainer stops and removes existing container
func (sd *SSHDeployer) cleanupExistingContainer(ctx context.Context, client *ssh.Client, containerName string) error <span class="cov0" title="0">{
        session, err := client.NewSession()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer session.Close()

        // Stop container if running
        cmd := fmt.Sprintf("docker stop %s 2&gt;/dev/null || true", containerName)
        if err := session.Run(cmd); err != nil </span><span class="cov0" title="0">{
                sd.logger.Printf("Warning: failed to stop container %s: %v", containerName, err)
        }</span>

        <span class="cov0" title="0">session, err = client.NewSession()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer session.Close()

        // Remove container
        cmd = fmt.Sprintf("docker rm %s 2&gt;/dev/null || true", containerName)
        if err := session.Run(cmd); err != nil </span><span class="cov0" title="0">{
                sd.logger.Printf("Warning: failed to remove container %s: %v", containerName, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// createAndStartContainer creates and starts the Docker container
func (sd *SSHDeployer) createAndStartContainer(ctx context.Context, client *ssh.Client, config *DeploymentConfig) (string, error) <span class="cov0" title="0">{
        session, err := client.NewSession()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer session.Close()

        // Build Docker run command
        cmd := sd.buildDockerRunCommand(config)

        sd.logger.Printf("Running Docker command: %s", cmd)

        // Execute command and capture output
        var stdout, stderr strings.Builder
        session.Stdout = &amp;stdout
        session.Stderr = &amp;stderr

        if err := session.Run(cmd); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("docker run failed: %w\nstdout: %s\nstderr: %s", err, stdout.String(), stderr.String())
        }</span>

        // Extract container ID from output
        <span class="cov0" title="0">containerID := strings.TrimSpace(stdout.String())
        if containerID == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no container ID returned")
        }</span>

        <span class="cov0" title="0">return containerID, nil</span>
}

// buildDockerRunCommand builds the Docker run command
func (sd *SSHDeployer) buildDockerRunCommand(config *DeploymentConfig) string <span class="cov0" title="0">{
        var cmd strings.Builder
        cmd.WriteString("docker run -d --name ")
        cmd.WriteString(config.ContainerName)

        // Add restart policy
        if config.RestartPolicy != "" </span><span class="cov0" title="0">{
                cmd.WriteString(" --restart ")
                cmd.WriteString(config.RestartPolicy)
        }</span> else<span class="cov0" title="0"> {
                cmd.WriteString(" --restart unless-stopped")
        }</span>

        // Add networks
        <span class="cov0" title="0">for _, network := range config.Networks </span><span class="cov0" title="0">{
                cmd.WriteString(" --network ")
                cmd.WriteString(network)
        }</span>

        // Add port mappings
        <span class="cov0" title="0">for _, port := range config.Ports </span><span class="cov0" title="0">{
                cmd.WriteString(fmt.Sprintf(" -p %d:%d", port.HostPort, port.ContainerPort))
                if port.Protocol != "" &amp;&amp; port.Protocol != "tcp" </span><span class="cov0" title="0">{
                        cmd.WriteString("/")
                        cmd.WriteString(port.Protocol)
                }</span>
        }

        // Add volume mappings
        <span class="cov0" title="0">for _, volume := range config.Volumes </span><span class="cov0" title="0">{
                cmd.WriteString(" -v ")
                cmd.WriteString(volume.HostPath)
                cmd.WriteString(":")
                cmd.WriteString(volume.ContainerPath)
                if volume.ReadOnly </span><span class="cov0" title="0">{
                        cmd.WriteString(":ro")
                }</span>
        }

        // Add environment variables
        <span class="cov0" title="0">for key, value := range config.Environment </span><span class="cov0" title="0">{
                cmd.WriteString(" -e ")
                cmd.WriteString(key)
                cmd.WriteString("=\"")
                cmd.WriteString(value)
                cmd.WriteString("\"")
        }</span>

        // Add health check if configured
        <span class="cov0" title="0">if config.HealthCheck != nil </span><span class="cov0" title="0">{
                cmd.WriteString(" --health-cmd=\"")
                cmd.WriteString(strings.Join(config.HealthCheck.Test, " "))
                cmd.WriteString("\"")

                if config.HealthCheck.Interval &gt; 0 </span><span class="cov0" title="0">{
                        cmd.WriteString(fmt.Sprintf(" --health-interval=%s", config.HealthCheck.Interval))
                }</span>
                <span class="cov0" title="0">if config.HealthCheck.Timeout &gt; 0 </span><span class="cov0" title="0">{
                        cmd.WriteString(fmt.Sprintf(" --health-timeout=%s", config.HealthCheck.Timeout))
                }</span>
                <span class="cov0" title="0">if config.HealthCheck.Retries &gt; 0 </span><span class="cov0" title="0">{
                        cmd.WriteString(fmt.Sprintf(" --health-retries=%d", config.HealthCheck.Retries))
                }</span>
                <span class="cov0" title="0">if config.HealthCheck.StartPeriod &gt; 0 </span><span class="cov0" title="0">{
                        cmd.WriteString(fmt.Sprintf(" --health-start-period=%s", config.HealthCheck.StartPeriod))
                }</span>
        }

        // Add image name
        <span class="cov0" title="0">cmd.WriteString(" ")
        cmd.WriteString(config.DockerImage)

        return cmd.String()</span>
}

// CheckInstanceHealth checks the health of a deployed instance
func (sd *SSHDeployer) CheckInstanceHealth(ctx context.Context, host string, port int) (bool, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("http://%s:%d/health", host, port)

        client := &amp;http.Client{
                Timeout: 10 * time.Second,
        }

        resp, err := client.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        return resp.StatusCode == http.StatusOK, nil</span>
}

// GetContainerLogs retrieves logs from a container
func (sd *SSHDeployer) GetContainerLogs(ctx context.Context, config *DeploymentConfig, lines int) (string, error) <span class="cov0" title="0">{
        client, err := sd.connectSSH(config)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer client.Close()

        session, err := client.NewSession()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer session.Close()

        cmd := fmt.Sprintf("docker logs --tail %d %s", lines, config.ContainerName)

        var output strings.Builder
        session.Stdout = &amp;output
        session.Stderr = &amp;output

        if err := session.Run(cmd); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return output.String(), nil</span>
}

// StopInstance stops a deployed instance
func (sd *SSHDeployer) StopInstance(ctx context.Context, config *DeploymentConfig) error <span class="cov0" title="0">{
        client, err := sd.connectSSH(config)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer client.Close()

        session, err := client.NewSession()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer session.Close()

        cmd := fmt.Sprintf("docker stop %s", config.ContainerName)
        return session.Run(cmd)</span>
}

// RemoveInstance removes a deployed instance
func (sd *SSHDeployer) RemoveInstance(ctx context.Context, config *DeploymentConfig) error <span class="cov0" title="0">{
        client, err := sd.connectSSH(config)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer client.Close()

        session, err := client.NewSession()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer session.Close()

        cmd := fmt.Sprintf("docker rm %s", config.ContainerName)
        return session.Run(cmd)</span>
}

// UpdateInstance updates a deployed instance to a new image version
func (sd *SSHDeployer) UpdateInstance(ctx context.Context, config *DeploymentConfig) (string, error) <span class="cov0" title="0">{
        sd.logger.Printf("Updating instance %s to image %s...", config.ContainerName, config.DockerImage)

        client, err := sd.connectSSH(config)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer client.Close()

        session, err := client.NewSession()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer session.Close()

        // Stop the existing container
        stopCmd := fmt.Sprintf("docker stop %s", config.ContainerName)
        if err := session.Run(stopCmd); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to stop container: %w", err)
        }</span>

        // Remove the existing container
        <span class="cov0" title="0">removeCmd := fmt.Sprintf("docker rm %s", config.ContainerName)
        if err := session.Run(removeCmd); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to remove container: %w", err)
        }</span>

        // Pull the new image
        <span class="cov0" title="0">pullCmd := fmt.Sprintf("docker pull %s", config.DockerImage)
        session2, err := client.NewSession()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer session2.Close()

        if err := session2.Run(pullCmd); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to pull image: %w", err)
        }</span>

        // Start the new container
        <span class="cov0" title="0">runCmd := sd.buildDockerRunCommand(config)
        session3, err := client.NewSession()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer session3.Close()

        var output strings.Builder
        session3.Stdout = &amp;output

        if err := session3.Run(runCmd); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to start updated container: %w", err)
        }</span>

        <span class="cov0" title="0">containerID := strings.TrimSpace(output.String())
        sd.logger.Printf("Instance %s updated successfully: %s", config.ContainerName, containerID[:12])

        return containerID, nil</span>
}

// RestartInstance restarts a deployed instance
func (sd *SSHDeployer) RestartInstance(ctx context.Context, config *DeploymentConfig) error <span class="cov0" title="0">{
        sd.logger.Printf("Restarting instance %s...", config.ContainerName)

        client, err := sd.connectSSH(config)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer client.Close()

        session, err := client.NewSession()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer session.Close()

        cmd := fmt.Sprintf("docker restart %s", config.ContainerName)
        return session.Run(cmd)</span>
}

// Close closes the SSH deployer
func (sd *SSHDeployer) Close() error <span class="cov8" title="1">{
        // No persistent connections to close
        return nil
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package events

import (
        "sync"
        "time"
)

// EventType represents different types of events
type EventType string

const (
        EventTranslationStarted   EventType = "translation_started"
        EventTranslationProgress  EventType = "translation_progress"
        EventTranslationCompleted EventType = "translation_completed"
        EventTranslationError     EventType = "translation_error"
        EventConversionStarted    EventType = "conversion_started"
        EventConversionProgress   EventType = "conversion_progress"
        EventConversionCompleted  EventType = "conversion_completed"
        EventConversionError      EventType = "conversion_error"
)

// Event represents a system event
type Event struct {
        ID        string                 `json:"id"`
        Type      EventType              `json:"type"`
        Timestamp time.Time              `json:"timestamp"`
        Message   string                 `json:"message"`
        Data      map[string]interface{} `json:"data,omitempty"`
        SessionID string                 `json:"session_id,omitempty"`
}

// EventHandler is a function that processes events
type EventHandler func(event Event)

// EventBus manages event distribution
type EventBus struct {
        mu        sync.RWMutex
        handlers  map[EventType][]EventHandler
        allEvents []EventHandler
}

// NewEventBus creates a new event bus
func NewEventBus() *EventBus <span class="cov8" title="1">{
        return &amp;EventBus{
                handlers:  make(map[EventType][]EventHandler),
                allEvents: make([]EventHandler, 0),
        }
}</span>

// Subscribe adds a handler for a specific event type
func (eb *EventBus) Subscribe(eventType EventType, handler EventHandler) <span class="cov8" title="1">{
        eb.mu.Lock()
        defer eb.mu.Unlock()
        eb.handlers[eventType] = append(eb.handlers[eventType], handler)
}</span>

// SubscribeAll adds a handler for all events
func (eb *EventBus) SubscribeAll(handler EventHandler) <span class="cov8" title="1">{
        eb.mu.Lock()
        defer eb.mu.Unlock()
        eb.allEvents = append(eb.allEvents, handler)
}</span>

// Publish sends an event to all subscribed handlers
func (eb *EventBus) Publish(event Event) <span class="cov8" title="1">{
        eb.mu.RLock()
        defer eb.mu.RUnlock()

        // Send to specific handlers
        if handlers, ok := eb.handlers[event.Type]; ok </span><span class="cov8" title="1">{
                for _, handler := range handlers </span><span class="cov8" title="1">{
                        go func(h EventHandler) </span><span class="cov8" title="1">{
                                defer func() </span><span class="cov8" title="1">{
                                        if r := recover(); r != nil </span>{<span class="cov8" title="1">
                                                // Handler panicked, but we continue
                                        }</span>
                                }()
                                <span class="cov8" title="1">h(event)</span>
                        }(handler)
                }
        }

        // Send to all-event handlers
        <span class="cov8" title="1">for _, handler := range eb.allEvents </span><span class="cov8" title="1">{
                go func(h EventHandler) </span><span class="cov8" title="1">{
                        defer func() </span><span class="cov8" title="1">{
                                if r := recover(); r != nil </span>{<span class="cov0" title="0">
                                        // Handler panicked, but we continue
                                }</span>
                        }()
                        <span class="cov8" title="1">h(event)</span>
                }(handler)
        }
}

// NewEvent creates a new event with timestamp and unique ID
func NewEvent(eventType EventType, message string, data map[string]interface{}) Event <span class="cov8" title="1">{
        return Event{
                ID:        generateEventID(),
                Type:      eventType,
                Timestamp: time.Now(),
                Message:   message,
                Data:      data,
        }
}</span>

// generateEventID creates a unique event ID
func generateEventID() string <span class="cov8" title="1">{
        return time.Now().Format("20060102150405.000000")
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package fb2

import (
        "encoding/xml"
        "fmt"
        "io"
        "os"
)

// FB2 namespace constants
const (
        FB2Namespace   = "http://www.gribuser.ru/xml/fictionbook/2.0"
        XLinkNamespace = "http://www.w3.org/1999/xlink"
)

// FictionBook represents the root FB2 structure
type FictionBook struct {
        XMLName     xml.Name    `xml:"http://www.gribuser.ru/xml/fictionbook/2.0 FictionBook"`
        Description Description `xml:"description"`
        Body        []Body      `xml:"body"`
        Binary      []Binary    `xml:"binary,omitempty"`
}

// Description contains metadata
type Description struct {
        TitleInfo      TitleInfo      `xml:"title-info"`
        DocumentInfo   DocumentInfo   `xml:"document-info,omitempty"`
        PublishInfo    PublishInfo    `xml:"publish-info,omitempty"`
        CustomInfo     []CustomInfo   `xml:"custom-info,omitempty"`
        SrcTitleInfo   *TitleInfo     `xml:"src-title-info,omitempty"`
}

// TitleInfo contains book information
type TitleInfo struct {
        Genre      []string   `xml:"genre"`
        Author     []Author   `xml:"author"`
        BookTitle  string     `xml:"book-title"`
        Annotation Annotation `xml:"annotation,omitempty"`
        Keywords   string     `xml:"keywords,omitempty"`
        Date       Date       `xml:"date,omitempty"`
        Coverpage  Coverpage  `xml:"coverpage,omitempty"`
        Lang       string     `xml:"lang"`
        SrcLang    string     `xml:"src-lang,omitempty"`
        Translator []Author   `xml:"translator,omitempty"`
        Sequence   []Sequence `xml:"sequence,omitempty"`
}

// Author represents author information
type Author struct {
        FirstName  string `xml:"first-name,omitempty"`
        MiddleName string `xml:"middle-name,omitempty"`
        LastName   string `xml:"last-name,omitempty"`
        Nickname   string `xml:"nickname,omitempty"`
        HomePage   string `xml:"home-page,omitempty"`
        Email      string `xml:"email,omitempty"`
}

// Annotation represents book annotation
type Annotation struct {
        Paragraphs []Paragraph `xml:"p"`
}

// Date represents a date with optional value attribute
type Date struct {
        Value string `xml:"value,attr,omitempty"`
        Text  string `xml:",chardata"`
}

// Coverpage contains cover image reference
type Coverpage struct {
        Image Image `xml:"image"`
}

// Image represents an image reference
type Image struct {
        Href string `xml:"http://www.w3.org/1999/xlink href,attr"`
        Alt  string `xml:"alt,attr,omitempty"`
}

// Sequence represents a book series
type Sequence struct {
        Name   string `xml:"name,attr"`
        Number int    `xml:"number,attr,omitempty"`
}

// DocumentInfo contains document metadata
type DocumentInfo struct {
        Author      []Author `xml:"author"`
        ProgramUsed string   `xml:"program-used,omitempty"`
        Date        Date     `xml:"date"`
        SrcURL      []string `xml:"src-url,omitempty"`
        SrcOCR      string   `xml:"src-ocr,omitempty"`
        ID          string   `xml:"id"`
        Version     string   `xml:"version"`
}

// PublishInfo contains publishing information
type PublishInfo struct {
        BookName  string `xml:"book-name,omitempty"`
        Publisher string `xml:"publisher,omitempty"`
        City      string `xml:"city,omitempty"`
        Year      string `xml:"year,omitempty"`
        ISBN      string `xml:"isbn,omitempty"`
}

// CustomInfo contains custom metadata
type CustomInfo struct {
        InfoType string `xml:"info-type,attr"`
        Text     string `xml:",chardata"`
}

// Body represents the main content body
type Body struct {
        Name    string    `xml:"name,attr,omitempty"`
        Title   Title     `xml:"title,omitempty"`
        Section []Section `xml:"section"`
}

// Section represents a content section
type Section struct {
        ID        string      `xml:"id,attr,omitempty"`
        Title     Title       `xml:"title,omitempty"`
        Epigraph  []Epigraph  `xml:"epigraph,omitempty"`
        Section   []Section   `xml:"section,omitempty"`
        Paragraph []Paragraph `xml:"p,omitempty"`
        Poem      []Poem      `xml:"poem,omitempty"`
        Subtitle  []string    `xml:"subtitle,omitempty"`
        Cite      []Cite      `xml:"cite,omitempty"`
        EmptyLine []struct{}  `xml:"empty-line,omitempty"`
}

// Title represents a title
type Title struct {
        Paragraphs []Paragraph `xml:"p"`
        EmptyLine  []struct{}  `xml:"empty-line,omitempty"`
}

// Paragraph represents a text paragraph with mixed content
type Paragraph struct {
        ID      string        `xml:"id,attr,omitempty"`
        Style   string        `xml:"style,attr,omitempty"`
        Content []interface{} `xml:",any"`
        Text    string        `xml:",chardata"`
}

// Emphasis represents emphasized text
type Emphasis struct {
        Style string `xml:"style,attr,omitempty"`
        Text  string `xml:",chardata"`
}

// Strong represents strong text
type Strong struct {
        Text string `xml:",chardata"`
}

// Epigraph represents an epigraph
type Epigraph struct {
        Paragraph  []Paragraph `xml:"p"`
        Poem       []Poem      `xml:"poem,omitempty"`
        Cite       []Cite      `xml:"cite,omitempty"`
        TextAuthor []string    `xml:"text-author,omitempty"`
}

// Poem represents a poem
type Poem struct {
        Title    Title      `xml:"title,omitempty"`
        Epigraph []Epigraph `xml:"epigraph,omitempty"`
        Stanza   []Stanza   `xml:"stanza"`
}

// Stanza represents a poem stanza
type Stanza struct {
        Title   Title  `xml:"title,omitempty"`
        Subtitle string `xml:"subtitle,omitempty"`
        V       []V    `xml:"v"`
}

// V represents a verse line
type V struct {
        Text string `xml:",chardata"`
}

// Cite represents a citation
type Cite struct {
        Paragraph  []Paragraph `xml:"p"`
        Subtitle   []string    `xml:"subtitle,omitempty"`
        Poem       []Poem      `xml:"poem,omitempty"`
        EmptyLine  []struct{}  `xml:"empty-line,omitempty"`
        TextAuthor []string    `xml:"text-author,omitempty"`
}

// Binary represents embedded binary data (images)
type Binary struct {
        ID          string `xml:"id,attr"`
        ContentType string `xml:"content-type,attr"`
        Data        string `xml:",chardata"`
}

// Parser handles FB2 parsing and writing
type Parser struct{}

// NewParser creates a new FB2 parser
func NewParser() *Parser <span class="cov8" title="1">{
        return &amp;Parser{}
}</span>

// Parse reads and parses an FB2 file
func (p *Parser) Parse(filename string) (*FictionBook, error) <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to open file: %w", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        return p.ParseReader(file)</span>
}

// ParseReader parses FB2 from an io.Reader
func (p *Parser) ParseReader(reader io.Reader) (*FictionBook, error) <span class="cov8" title="1">{
        var fb FictionBook
        decoder := xml.NewDecoder(reader)

        if err := decoder.Decode(&amp;fb); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse FB2: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;fb, nil</span>
}

// Write writes an FB2 structure to a file
func (p *Parser) Write(filename string, fb *FictionBook) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create file: %w", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        return p.WriteToWriter(file, fb)</span>
}

// WriteToWriter writes FB2 to an io.Writer
func (p *Parser) WriteToWriter(writer io.Writer, fb *FictionBook) error <span class="cov8" title="1">{
        encoder := xml.NewEncoder(writer)
        encoder.Indent("", "  ")

        // Write XML header
        if _, err := writer.Write([]byte(xml.Header)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write XML header: %w", err)
        }</span>

        <span class="cov8" title="1">if err := encoder.Encode(fb); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to encode FB2: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetLanguage returns the document language
func (fb *FictionBook) GetLanguage() string <span class="cov8" title="1">{
        return fb.Description.TitleInfo.Lang
}</span>

// SetLanguage sets the document language
func (fb *FictionBook) SetLanguage(lang string) <span class="cov8" title="1">{
        fb.Description.TitleInfo.Lang = lang
}</span>

// GetTitle returns the book title
func (fb *FictionBook) GetTitle() string <span class="cov8" title="1">{
        return fb.Description.TitleInfo.BookTitle
}</span>

// SetTitle sets the book title
func (fb *FictionBook) SetTitle(title string) <span class="cov8" title="1">{
        fb.Description.TitleInfo.BookTitle = title
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package format

import (
        "archive/zip"
        "bytes"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
)

// Format represents an ebook format
type Format string

const (
        FormatFB2     Format = "fb2"
        FormatEPUB    Format = "epub"
        FormatPDF     Format = "pdf"
        FormatMOBI    Format = "mobi"
        FormatAZW     Format = "azw"
        FormatAZW3    Format = "azw3"
        FormatTXT     Format = "txt"
        FormatHTML    Format = "html"
        FormatDOCX    Format = "docx"
        FormatRTF     Format = "rtf"
        FormatUnknown Format = "unknown"
)

// Magic byte signatures for different formats
var magicBytes = map[Format][]byte{
        FormatPDF:  []byte("%PDF"),
        FormatEPUB: []byte("PK"), // EPUB is a ZIP file (DOCX also uses PK but is handled by disambiguation)
        FormatMOBI: []byte("BOOKMOBI"),
        FormatAZW:  []byte("TPZ0"),
        FormatAZW3: []byte("PK"), // AZW3 is also a ZIP file, handled by disambiguation
}

// Detector handles ebook format detection
type Detector struct{}

// NewDetector creates a new format detector
func NewDetector() *Detector <span class="cov8" title="1">{
        return &amp;Detector{}
}</span>

// DetectFile detects the format of a file
func (d *Detector) DetectFile(filename string) (Format, error) <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return FormatUnknown, fmt.Errorf("failed to open file: %w", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // Read first 512 bytes for magic byte detection
        header := make([]byte, 512)
        n, err := file.Read(header)
        if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return FormatUnknown, fmt.Errorf("failed to read file header: %w", err)
        }</span>
        <span class="cov8" title="1">header = header[:n]

        // Check file extension first
        ext := strings.ToLower(filepath.Ext(filename))
        formatByExt := d.detectByExtension(ext)

        // Check magic bytes
        formatByMagic := d.detectByMagicBytes(header)

        // Prioritize magic bytes over extension
        if formatByMagic != FormatUnknown </span><span class="cov8" title="1">{
                // Disambiguate ZIP-based formats (EPUB, DOCX both use PK magic bytes)
                if formatByMagic == FormatEPUB || formatByMagic == FormatDOCX </span><span class="cov8" title="1">{
                        return d.disambiguateZipFormat(filename, ext)
                }</span>
                <span class="cov8" title="1">return formatByMagic, nil</span>
        }

        <span class="cov8" title="1">if formatByExt != FormatUnknown </span><span class="cov8" title="1">{
                return formatByExt, nil
        }</span>

        // Try content-based detection
        <span class="cov8" title="1">return d.detectByContent(header), nil</span>
}

// detectByExtension detects format by file extension
func (d *Detector) detectByExtension(ext string) Format <span class="cov8" title="1">{
        ext = strings.TrimPrefix(ext, ".")
        ext = strings.ToLower(ext)

        switch ext </span>{
        case "fb2":<span class="cov8" title="1">
                return FormatFB2</span>
        case "epub":<span class="cov8" title="1">
                return FormatEPUB</span>
        case "pdf":<span class="cov8" title="1">
                return FormatPDF</span>
        case "mobi", "prc":<span class="cov8" title="1">
                return FormatMOBI</span>
        case "azw":<span class="cov8" title="1">
                return FormatAZW</span>
        case "azw3":<span class="cov8" title="1">
                return FormatAZW3</span>
        case "txt":<span class="cov8" title="1">
                return FormatTXT</span>
        case "html", "htm":<span class="cov8" title="1">
                return FormatHTML</span>
        case "docx":<span class="cov8" title="1">
                return FormatDOCX</span>
        case "rtf":<span class="cov8" title="1">
                return FormatRTF</span>
        default:<span class="cov8" title="1">
                return FormatUnknown</span>
        }
}

// detectByMagicBytes detects format by magic bytes
func (d *Detector) detectByMagicBytes(data []byte) Format <span class="cov8" title="1">{
        for format, magic := range magicBytes </span><span class="cov8" title="1">{
                if bytes.HasPrefix(data, magic) </span><span class="cov8" title="1">{
                        return format
                }</span>
        }
        <span class="cov8" title="1">return FormatUnknown</span>
}

// disambiguateZipFormat distinguishes between EPUB, DOCX, AZW3, and other ZIP formats
func (d *Detector) disambiguateZipFormat(filename string, ext string) (Format, error) <span class="cov8" title="1">{
        // Check extension first
        switch strings.ToLower(ext) </span>{
        case ".epub":<span class="cov8" title="1">
                return FormatEPUB, nil</span>
        case ".docx":<span class="cov8" title="1">
                return FormatDOCX, nil</span>
        case ".azw3":<span class="cov0" title="0">
                return FormatAZW3, nil</span>
        }

        // Check mimetype file inside ZIP
        <span class="cov8" title="1">mimetype, err := d.getZipMimetype(filename)
        if err == nil </span><span class="cov0" title="0">{
                switch mimetype </span>{
                case "application/epub+zip":<span class="cov0" title="0">
                        return FormatEPUB, nil</span>
                case "application/vnd.openxmlformats-officedocument.wordprocessingml.document":<span class="cov0" title="0">
                        return FormatDOCX, nil</span>
                case "application/x-mobipocket-ebook":<span class="cov0" title="0">
                        return FormatAZW3, nil</span>
                }
        }

        // Check for AZW3 specific structure
        <span class="cov8" title="1">if d.isAZW3File(filename) </span><span class="cov0" title="0">{
                return FormatAZW3, nil
        }</span>

        // Default to EPUB for unknown ZIP formats
        <span class="cov8" title="1">return FormatEPUB, nil</span>
}

// getZipMimetype reads the mimetype file from a ZIP archive
func (d *Detector) getZipMimetype(filename string) (string, error) <span class="cov8" title="1">{
        r, err := zip.OpenReader(filename)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer r.Close()

        for _, f := range r.File </span><span class="cov0" title="0">{
                if f.Name == "mimetype" </span><span class="cov0" title="0">{
                        rc, err := f.Open()
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov0" title="0">defer rc.Close()

                        data, err := io.ReadAll(rc)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>

                        <span class="cov0" title="0">return strings.TrimSpace(string(data)), nil</span>
                }
        }

        <span class="cov0" title="0">return "", fmt.Errorf("mimetype file not found")</span>
}

// isAZW3File checks if the ZIP file has AZW3 specific structure
func (d *Detector) isAZW3File(filename string) bool <span class="cov8" title="1">{
        r, err := zip.OpenReader(filename)
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov0" title="0">defer r.Close()

        // Look for AZW3 specific files
        azw3Indicators := []string{
                "mimetype",
                "OEBPS",
                "META-INF",
        }

        hasIndicators := 0
        for _, f := range r.File </span><span class="cov0" title="0">{
                for _, indicator := range azw3Indicators </span><span class="cov0" title="0">{
                        if strings.Contains(f.Name, indicator) </span><span class="cov0" title="0">{
                                hasIndicators++
                                break</span>
                        }
                }
        }

        // If we have multiple indicators, likely AZW3
        <span class="cov0" title="0">return hasIndicators &gt;= 2</span>
}

// detectByContent detects format by analyzing content
func (d *Detector) detectByContent(data []byte) Format <span class="cov8" title="1">{
        content := string(data)

        // Check for XML-based formats
        if strings.Contains(content, "&lt;?xml") </span><span class="cov8" title="1">{
                if strings.Contains(content, "FictionBook") </span><span class="cov8" title="1">{
                        return FormatFB2
                }</span>
                <span class="cov0" title="0">if strings.Contains(content, "&lt;html") || strings.Contains(content, "&lt;HTML") </span><span class="cov0" title="0">{
                        return FormatHTML
                }</span>
        }

        // Check for HTML
        <span class="cov8" title="1">if strings.Contains(content, "&lt;html") || strings.Contains(content, "&lt;!DOCTYPE html") </span><span class="cov8" title="1">{
                return FormatHTML
        }</span>

        // Check for RTF
        <span class="cov8" title="1">if strings.HasPrefix(content, "{\\rtf") </span><span class="cov8" title="1">{
                return FormatRTF
        }</span>

        // Check for PDF content (if magic bytes were missed)
        <span class="cov8" title="1">if strings.Contains(content, "%PDF") </span><span class="cov0" title="0">{
                return FormatPDF
        }</span>

        // Check for MOBI content (if magic bytes were missed)
        <span class="cov8" title="1">if strings.Contains(content, "BOOKMOBI") </span><span class="cov0" title="0">{
                return FormatMOBI
        }</span>

        // Check for AZW content (if magic bytes were missed)
        <span class="cov8" title="1">if strings.Contains(content, "TPZ0") </span><span class="cov0" title="0">{
                return FormatAZW
        }</span>

        // Default to plain text if mostly readable
        <span class="cov8" title="1">if d.isPlainText(data) </span><span class="cov8" title="1">{
                return FormatTXT
        }</span>

        <span class="cov8" title="1">return FormatUnknown</span>
}

// isPlainText checks if data is mostly plain text
func (d *Detector) isPlainText(data []byte) bool <span class="cov8" title="1">{
        if len(data) == 0 </span><span class="cov8" title="1">{
                return true // Empty data is considered plain text
        }</span>
        <span class="cov8" title="1">printableCount := 0
        for _, b := range data </span><span class="cov8" title="1">{
                if (b &gt;= 32 &amp;&amp; b &lt;= 126) || b == '\n' || b == '\r' || b == '\t' || b &gt;= 128 </span><span class="cov8" title="1">{
                        printableCount++
                }</span>
        }
        <span class="cov8" title="1">return float64(printableCount)/float64(len(data)) &gt; 0.85</span>
}

// IsSupported checks if a format is supported
func (d *Detector) IsSupported(format Format) bool <span class="cov8" title="1">{
        supported := []Format{
                FormatFB2,
                FormatEPUB,
                FormatTXT,
                FormatHTML,
                FormatPDF,
                FormatMOBI,
                FormatAZW,
                FormatAZW3,
        }

        for _, f := range supported </span><span class="cov8" title="1">{
                if f == format </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// GetSupportedFormats returns list of supported formats
func (d *Detector) GetSupportedFormats() []Format <span class="cov8" title="1">{
        return []Format{
                FormatFB2,
                FormatEPUB,
                FormatTXT,
                FormatHTML,
                FormatPDF,
                FormatMOBI,
                FormatAZW,
                FormatAZW3,
        }
}</span>

// FormatToString converts Format to string
func (f Format) String() string <span class="cov8" title="1">{
        return string(f)
}</span>

// ParseFormat parses a format string
func ParseFormat(s string) Format <span class="cov8" title="1">{
        s = strings.ToLower(strings.TrimSpace(s))
        switch s </span>{
        case "fb2":<span class="cov8" title="1">
                return FormatFB2</span>
        case "epub":<span class="cov8" title="1">
                return FormatEPUB</span>
        case "pdf":<span class="cov8" title="1">
                return FormatPDF</span>
        case "mobi":<span class="cov8" title="1">
                return FormatMOBI</span>
        case "azw":<span class="cov8" title="1">
                return FormatAZW</span>
        case "azw3":<span class="cov8" title="1">
                return FormatAZW3</span>
        case "txt", "text":<span class="cov8" title="1">
                return FormatTXT</span>
        case "html", "htm":<span class="cov8" title="1">
                return FormatHTML</span>
        case "docx":<span class="cov8" title="1">
                return FormatDOCX</span>
        case "rtf":<span class="cov8" title="1">
                return FormatRTF</span>
        default:<span class="cov8" title="1">
                return FormatUnknown</span>
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package hardware

import (
        "fmt"
        "os/exec"
        "runtime"
        "strconv"
        "strings"
)

// Capabilities represents system hardware capabilities
type Capabilities struct {
        Architecture string // arm64, amd64, etc.
        TotalRAM     uint64 // in bytes
        AvailableRAM uint64 // in bytes
        CPUModel     string // e.g., "Apple M3 Pro"
        CPUCores     int    // physical cores
        HasGPU       bool   // GPU acceleration available
        GPUType      string // metal, cuda, rocm, vulkan, or empty
        MaxModelSize uint64 // estimated max model size in parameters (7B, 13B, etc.)
}

// Detector provides hardware detection functionality
type Detector struct{}

// NewDetector creates a new hardware detector
func NewDetector() *Detector <span class="cov8" title="1">{
        return &amp;Detector{}
}</span>

// Detect analyzes system hardware and returns capabilities
func (d *Detector) Detect() (*Capabilities, error) <span class="cov8" title="1">{
        caps := &amp;Capabilities{
                Architecture: runtime.GOARCH,
        }

        var err error

        // Detect RAM
        caps.TotalRAM, err = d.getTotalRAM()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to detect total RAM: %w", err)
        }</span>

        <span class="cov8" title="1">caps.AvailableRAM, err = d.getAvailableRAM()
        if err != nil </span><span class="cov0" title="0">{
                // Estimate as 70% of total if we can't get precise value
                caps.AvailableRAM = uint64(float64(caps.TotalRAM) * 0.7)
        }</span>

        // Detect CPU
        <span class="cov8" title="1">caps.CPUModel, err = d.getCPUModel()
        if err != nil </span><span class="cov0" title="0">{
                caps.CPUModel = "Unknown"
        }</span>

        <span class="cov8" title="1">caps.CPUCores, err = d.getCPUCores()
        if err != nil </span><span class="cov0" title="0">{
                caps.CPUCores = runtime.NumCPU()
        }</span>

        // Detect GPU
        <span class="cov8" title="1">caps.HasGPU, caps.GPUType = d.detectGPU()

        // Calculate max model size based on available RAM
        caps.MaxModelSize = d.calculateMaxModelSize(caps.AvailableRAM, caps.HasGPU)

        return caps, nil</span>
}

// getTotalRAM returns total system RAM in bytes
func (d *Detector) getTotalRAM() (uint64, error) <span class="cov8" title="1">{
        switch runtime.GOOS </span>{
        case "darwin":<span class="cov8" title="1">
                return d.getMacOSRAM()</span>
        case "linux":<span class="cov0" title="0">
                return d.getLinuxRAM()</span>
        case "windows":<span class="cov0" title="0">
                return d.getWindowsRAM()</span>
        default:<span class="cov0" title="0">
                return 0, fmt.Errorf("unsupported operating system: %s", runtime.GOOS)</span>
        }
}

// getMacOSRAM gets RAM on macOS
func (d *Detector) getMacOSRAM() (uint64, error) <span class="cov8" title="1">{
        cmd := exec.Command("sysctl", "-n", "hw.memsize")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">ramBytes, err := strconv.ParseUint(strings.TrimSpace(string(output)), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return ramBytes, nil</span>
}

// getLinuxRAM gets RAM on Linux
func (d *Detector) getLinuxRAM() (uint64, error) <span class="cov0" title="0">{
        cmd := exec.Command("grep", "MemTotal", "/proc/meminfo")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // MemTotal:       16384000 kB
        <span class="cov0" title="0">parts := strings.Fields(string(output))
        if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("unexpected meminfo format")
        }</span>

        <span class="cov0" title="0">ramKB, err := strconv.ParseUint(parts[1], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return ramKB * 1024, nil</span>
}

// getWindowsRAM gets RAM on Windows
func (d *Detector) getWindowsRAM() (uint64, error) <span class="cov0" title="0">{
        cmd := exec.Command("wmic", "computersystem", "get", "totalphysicalmemory")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">lines := strings.Split(string(output), "\n")
        if len(lines) &lt; 2 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("unexpected wmic output")
        }</span>

        <span class="cov0" title="0">ramBytes, err := strconv.ParseUint(strings.TrimSpace(lines[1]), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return ramBytes, nil</span>
}

// getAvailableRAM returns available RAM in bytes
func (d *Detector) getAvailableRAM() (uint64, error) <span class="cov8" title="1">{
        switch runtime.GOOS </span>{
        case "darwin":<span class="cov8" title="1">
                // On macOS, use vm_stat to get available memory
                cmd := exec.Command("vm_stat")
                output, err := cmd.Output()
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                // Parse vm_stat output to get free + inactive + speculative pages
                <span class="cov8" title="1">lines := strings.Split(string(output), "\n")
                var freePages, inactivePages, speculativePages uint64
                var pageSize uint64 = 16384 // default page size for Apple Silicon

                for _, line := range lines </span><span class="cov8" title="1">{
                        if strings.Contains(line, "Pages free:") </span><span class="cov8" title="1">{
                                parts := strings.Fields(line)
                                if len(parts) &gt;= 3 </span><span class="cov8" title="1">{
                                        pages, _ := strconv.ParseUint(strings.TrimSuffix(parts[2], "."), 10, 64)
                                        freePages = pages
                                }</span>
                        } else<span class="cov8" title="1"> if strings.Contains(line, "Pages inactive:") </span><span class="cov8" title="1">{
                                parts := strings.Fields(line)
                                if len(parts) &gt;= 3 </span><span class="cov8" title="1">{
                                        pages, _ := strconv.ParseUint(strings.TrimSuffix(parts[2], "."), 10, 64)
                                        inactivePages = pages
                                }</span>
                        } else<span class="cov8" title="1"> if strings.Contains(line, "Pages speculative:") </span><span class="cov8" title="1">{
                                parts := strings.Fields(line)
                                if len(parts) &gt;= 3 </span><span class="cov8" title="1">{
                                        pages, _ := strconv.ParseUint(strings.TrimSuffix(parts[2], "."), 10, 64)
                                        speculativePages = pages
                                }</span>
                        } else<span class="cov8" title="1"> if strings.Contains(line, "page size of") </span><span class="cov8" title="1">{
                                parts := strings.Fields(line)
                                for i, part := range parts </span><span class="cov8" title="1">{
                                        if part == "of" &amp;&amp; i+1 &lt; len(parts) </span><span class="cov8" title="1">{
                                                pageSize, _ = strconv.ParseUint(parts[i+1], 10, 64)
                                                break</span>
                                        }
                                }
                        }
                }

                // Available RAM = free + inactive + speculative pages
                <span class="cov8" title="1">totalAvailablePages := freePages + inactivePages + speculativePages
                return totalAvailablePages * pageSize, nil</span>

        case "linux":<span class="cov0" title="0">
                cmd := exec.Command("grep", "MemAvailable", "/proc/meminfo")
                output, err := cmd.Output()
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov0" title="0">parts := strings.Fields(string(output))
                if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("unexpected meminfo format")
                }</span>

                <span class="cov0" title="0">availKB, err := strconv.ParseUint(parts[1], 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov0" title="0">return availKB * 1024, nil</span>

        case "windows":<span class="cov0" title="0">
                // Use PowerShell to get available memory (more reliable than wmic)
                cmd := exec.Command("powershell", "-Command",
                        "(Get-CimInstance -ClassName Win32_OperatingSystem).FreePhysicalMemory * 1024")
                output, err := cmd.Output()
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov0" title="0">availBytes, err := strconv.ParseUint(strings.TrimSpace(string(output)), 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov0" title="0">return availBytes, nil</span>

        case "freebsd", "openbsd", "netbsd", "dragonfly":<span class="cov0" title="0">
                // Use sysctl for BSD systems
                cmd := exec.Command("sysctl", "hw.usermem")
                output, err := cmd.Output()
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                // Parse sysctl output (format: hw.usermem: 12345678)
                <span class="cov0" title="0">parts := strings.Split(strings.TrimSpace(string(output)), ":")
                if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("unexpected sysctl format")
                }</span>

                <span class="cov0" title="0">totalMem, err := strconv.ParseUint(strings.TrimSpace(parts[1]), 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                // Estimate available memory (roughly 70% of total)
                <span class="cov0" title="0">return uint64(float64(totalMem) * 0.7), nil</span>

        default:<span class="cov0" title="0">
                return 0, fmt.Errorf("not implemented for %s", runtime.GOOS)</span>
        }
}

// getCPUModel returns the CPU model string
func (d *Detector) getCPUModel() (string, error) <span class="cov8" title="1">{
        switch runtime.GOOS </span>{
        case "darwin":<span class="cov8" title="1">
                cmd := exec.Command("sysctl", "-n", "machdep.cpu.brand_string")
                output, err := cmd.Output()
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">return strings.TrimSpace(string(output)), nil</span>

        case "linux":<span class="cov0" title="0">
                cmd := exec.Command("grep", "-m1", "model name", "/proc/cpuinfo")
                output, err := cmd.Output()
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">parts := strings.Split(string(output), ":")
                if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("unexpected cpuinfo format")
                }</span>
                <span class="cov0" title="0">return strings.TrimSpace(parts[1]), nil</span>

        case "windows":<span class="cov0" title="0">
                // Use PowerShell to get CPU name
                cmd := exec.Command("powershell", "-Command",
                        "(Get-CimInstance -ClassName Win32_Processor).Name")
                output, err := cmd.Output()
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">return strings.TrimSpace(string(output)), nil</span>

        case "freebsd", "openbsd", "netbsd", "dragonfly":<span class="cov0" title="0">
                // Use sysctl for BSD systems
                cmd := exec.Command("sysctl", "hw.model")
                output, err := cmd.Output()
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                // Parse sysctl output (format: hw.model: Intel(R) Core(TM) i7-8700K)
                <span class="cov0" title="0">parts := strings.Split(strings.TrimSpace(string(output)), ":")
                if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("unexpected sysctl format")
                }</span>

                <span class="cov0" title="0">return strings.TrimSpace(parts[1]), nil</span>

        default:<span class="cov0" title="0">
                return "", fmt.Errorf("not implemented for %s", runtime.GOOS)</span>
        }
}

// getCPUCores returns the number of physical CPU cores
func (d *Detector) getCPUCores() (int, error) <span class="cov8" title="1">{
        switch runtime.GOOS </span>{
        case "darwin":<span class="cov8" title="1">
                cmd := exec.Command("sysctl", "-n", "hw.physicalcpu")
                output, err := cmd.Output()
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov8" title="1">cores, err := strconv.Atoi(strings.TrimSpace(string(output)))
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov8" title="1">return cores, nil</span>

        case "linux":<span class="cov0" title="0">
                cmd := exec.Command("lscpu")
                output, err := cmd.Output()
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov0" title="0">for _, line := range strings.Split(string(output), "\n") </span><span class="cov0" title="0">{
                        if strings.Contains(line, "Core(s) per socket:") </span><span class="cov0" title="0">{
                                parts := strings.Fields(line)
                                if len(parts) &gt;= 4 </span><span class="cov0" title="0">{
                                        cores, err := strconv.Atoi(parts[3])
                                        if err == nil </span><span class="cov0" title="0">{
                                                return cores, nil
                                        }</span>
                                }
                        }
                }
                <span class="cov0" title="0">return 0, fmt.Errorf("could not parse core count")</span>

        case "windows":<span class="cov0" title="0">
                // Use PowerShell to get physical cores
                cmd := exec.Command("powershell", "-Command",
                        "(Get-CimInstance -ClassName Win32_Processor).NumberOfCores")
                output, err := cmd.Output()
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">cores, err := strconv.Atoi(strings.TrimSpace(string(output)))
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">return cores, nil</span>

        case "freebsd", "openbsd", "netbsd", "dragonfly":<span class="cov0" title="0">
                // Use sysctl for BSD systems
                cmd := exec.Command("sysctl", "hw.ncpu")
                output, err := cmd.Output()
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                // Parse sysctl output (format: hw.ncpu: 8)
                <span class="cov0" title="0">parts := strings.Split(strings.TrimSpace(string(output)), ":")
                if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("unexpected sysctl format")
                }</span>

                <span class="cov0" title="0">cores, err := strconv.Atoi(strings.TrimSpace(parts[1]))
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov0" title="0">return cores, nil</span>

        default:<span class="cov0" title="0">
                return 0, fmt.Errorf("not implemented for %s", runtime.GOOS)</span>
        }
}

// detectGPU detects GPU presence and type
func (d *Detector) detectGPU() (bool, string) <span class="cov8" title="1">{
        // Check for Metal (Apple Silicon)
        if runtime.GOOS == "darwin" &amp;&amp; runtime.GOARCH == "arm64" </span><span class="cov8" title="1">{
                return true, "metal"
        }</span>

        // Check for NVIDIA CUDA
        <span class="cov0" title="0">if _, err := exec.LookPath("nvidia-smi"); err == nil </span><span class="cov0" title="0">{
                return true, "cuda"
        }</span>

        // Check for AMD ROCm
        <span class="cov0" title="0">if _, err := exec.LookPath("rocm-smi"); err == nil </span><span class="cov0" title="0">{
                return true, "rocm"
        }</span>

        // Check for Vulkan (cross-platform)
        <span class="cov0" title="0">if _, err := exec.LookPath("vulkaninfo"); err == nil </span><span class="cov0" title="0">{
                return true, "vulkan"
        }</span>

        // Windows-specific GPU detection
        <span class="cov0" title="0">if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                // Check for DirectX/Vulkan capable GPUs via PowerShell
                cmd := exec.Command("powershell", "-Command",
                        "Get-CimInstance -ClassName Win32_VideoController | Where-Object { $_.AdapterRAM -gt 0 } | Select-Object -First 1")
                if err := cmd.Run(); err == nil </span><span class="cov0" title="0">{
                        // If we have a video controller, assume Vulkan support
                        return true, "vulkan"
                }</span>
        }

        <span class="cov0" title="0">return false, ""</span>
}

// calculateMaxModelSize estimates maximum model size in parameters (e.g., 7B, 13B)
// Based on available RAM and GPU acceleration
func (d *Detector) calculateMaxModelSize(availableRAM uint64, hasGPU bool) uint64 <span class="cov8" title="1">{
        // Convert RAM to GB
        ramGB := float64(availableRAM) / (1024 * 1024 * 1024)

        // Rule of thumb: Model needs ~2x its size in parameters for inference
        // - 7B model needs ~14GB RAM (Q4 quant: ~7GB, Q8: ~10GB)
        // - 13B model needs ~26GB RAM (Q4 quant: ~13GB, Q8: ~18GB)
        // - 27B model needs ~54GB RAM (Q4 quant: ~27GB, Q8: ~36GB)

        // With GPU acceleration, we can use less RAM
        multiplier := 2.0
        if hasGPU </span><span class="cov8" title="1">{
                multiplier = 1.5
        }</span>

        // Estimate max model size in billions of parameters
        <span class="cov8" title="1">maxParams := ramGB / multiplier

        // Round to standard model sizes: 7B, 13B, 27B, 70B, etc.
        if maxParams &gt;= 70 </span><span class="cov8" title="1">{
                return 70_000_000_000
        }</span> else<span class="cov8" title="1"> if maxParams &gt;= 27 </span><span class="cov8" title="1">{
                return 27_000_000_000
        }</span> else<span class="cov8" title="1"> if maxParams &gt;= 13 </span><span class="cov8" title="1">{
                return 13_000_000_000
        }</span> else<span class="cov8" title="1"> if maxParams &gt;= 7 </span><span class="cov8" title="1">{
                return 7_000_000_000
        }</span> else<span class="cov8" title="1"> if maxParams &gt;= 3 </span><span class="cov8" title="1">{
                return 3_000_000_000
        }</span>

        <span class="cov8" title="1">return 1_000_000_000</span> // 1B minimum
}

// String returns a human-readable summary of capabilities
func (c *Capabilities) String() string <span class="cov8" title="1">{
        ramGB := float64(c.TotalRAM) / (1024 * 1024 * 1024)
        availGB := float64(c.AvailableRAM) / (1024 * 1024 * 1024)
        maxModelB := float64(c.MaxModelSize) / 1_000_000_000

        gpuInfo := "None"
        if c.HasGPU </span><span class="cov8" title="1">{
                gpuInfo = fmt.Sprintf("%s acceleration", c.GPUType)
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf(
                "Hardware Capabilities:\n"+
                        "  Architecture: %s\n"+
                        "  CPU: %s (%d cores)\n"+
                        "  Total RAM: %.1f GB\n"+
                        "  Available RAM: %.1f GB\n"+
                        "  GPU: %s\n"+
                        "  Max Model Size: %.0fB parameters",
                c.Architecture, c.CPUModel, c.CPUCores,
                ramGB, availGB, gpuInfo, maxModelB,
        )</span>
}

// CanRunModel checks if the system can run a model of given size
func (c *Capabilities) CanRunModel(modelSizeB uint64) bool <span class="cov8" title="1">{
        return modelSizeB &lt;= c.MaxModelSize
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package language

import (
        "context"
        "fmt"
        "strings"
        "unicode"
)

// Language represents a language with its codes
type Language struct {
        Code   string // ISO 639-1 code (e.g., "en", "ru", "sr")
        Name   string // English name (e.g., "English", "Russian")
        Native string // Native name (e.g., "English", "–†—É—Å—Å–∫–∏–π")
}

// Common languages
var (
        English    = Language{Code: "en", Name: "English", Native: "English"}
        Russian    = Language{Code: "ru", Name: "Russian", Native: "–†—É—Å—Å–∫–∏–π"}
        Serbian    = Language{Code: "sr", Name: "Serbian", Native: "–°—Ä–ø—Å–∫–∏"}
        German     = Language{Code: "de", Name: "German", Native: "Deutsch"}
        French     = Language{Code: "fr", Name: "French", Native: "Fran√ßais"}
        Spanish    = Language{Code: "es", Name: "Spanish", Native: "Espa√±ol"}
        Italian    = Language{Code: "it", Name: "Italian", Native: "Italiano"}
        Portuguese = Language{Code: "pt", Name: "Portuguese", Native: "Portugu√™s"}
        Chinese    = Language{Code: "zh", Name: "Chinese", Native: "‰∏≠Êñá"}
        Japanese   = Language{Code: "ja", Name: "Japanese", Native: "Êó•Êú¨Ë™û"}
        Korean     = Language{Code: "ko", Name: "Korean", Native: "ÌïúÍµ≠Ïñ¥"}
        Arabic     = Language{Code: "ar", Name: "Arabic", Native: "ÿßŸÑÿπÿ±ÿ®Ÿäÿ©"}
        Polish     = Language{Code: "pl", Name: "Polish", Native: "Polski"}
        Ukrainian  = Language{Code: "uk", Name: "Ukrainian", Native: "–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞"}
        Czech      = Language{Code: "cs", Name: "Czech", Native: "ƒåe≈°tina"}
        Slovak     = Language{Code: "sk", Name: "Slovak", Native: "Slovenƒçina"}
        Croatian   = Language{Code: "hr", Name: "Croatian", Native: "Hrvatski"}
        Bulgarian  = Language{Code: "bg", Name: "Bulgarian", Native: "–ë—ä–ª–≥–∞—Ä—Å–∫–∏"}
)

// languageMap maps codes and names to Language structs
var languageMap = map[string]Language{
        // Codes
        "en": English, "eng": English,
        "ru": Russian, "rus": Russian,
        "sr": Serbian, "srp": Serbian,
        "de": German, "deu": German, "ger": German,
        "fr": French, "fra": French, "fre": French,
        "es": Spanish, "spa": Spanish,
        "it": Italian, "ita": Italian,
        "pt": Portuguese, "por": Portuguese,
        "zh": Chinese, "zho": Chinese, "chi": Chinese,
        "ja": Japanese, "jpn": Japanese,
        "ko": Korean, "kor": Korean,
        "ar": Arabic, "ara": Arabic,
        "pl": Polish, "pol": Polish,
        "uk": Ukrainian, "ukr": Ukrainian,
        "cs": Czech, "ces": Czech, "cze": Czech,
        "sk": Slovak, "slk": Slovak, "slo": Slovak,
        "hr": Croatian, "hrv": Croatian,
        "bg": Bulgarian, "bul": Bulgarian,

        // Names (lowercase)
        "english":    English,
        "russian":    Russian,
        "serbian":    Serbian,
        "german":     German,
        "french":     French,
        "spanish":    Spanish,
        "italian":    Italian,
        "portuguese": Portuguese,
        "chinese":    Chinese,
        "japanese":   Japanese,
        "korean":     Korean,
        "arabic":     Arabic,
        "polish":     Polish,
        "ukrainian":  Ukrainian,
        "czech":      Czech,
        "slovak":     Slovak,
        "croatian":   Croatian,
        "bulgarian":  Bulgarian,
}

// Detector handles language detection
type Detector struct {
        llmDetector LLMDetector
}

// LLMDetector interface for LLM-based language detection
type LLMDetector interface {
        DetectLanguage(ctx context.Context, text string) (string, error)
}

// NewDetector creates a new language detector
func NewDetector(llmDetector LLMDetector) *Detector <span class="cov8" title="1">{
        return &amp;Detector{
                llmDetector: llmDetector,
        }
}</span>

// Detect detects the language of the given text
func (d *Detector) Detect(ctx context.Context, text string) (Language, error) <span class="cov8" title="1">{
        // Try LLM detection first if available
        if d.llmDetector != nil </span><span class="cov8" title="1">{
                code, err := d.llmDetector.DetectLanguage(ctx, text)
                if err == nil &amp;&amp; code != "" </span><span class="cov8" title="1">{
                        if lang, ok := languageMap[strings.ToLower(code)]; ok </span><span class="cov8" title="1">{
                                return lang, nil
                        }</span>
                }
        }

        // Fallback to heuristic detection
        <span class="cov8" title="1">return d.detectHeuristic(text), nil</span>
}

// detectHeuristic uses character-based heuristics to detect language
func (d *Detector) detectHeuristic(text string) Language <span class="cov8" title="1">{
        if text == "" </span><span class="cov8" title="1">{
                return English // default
        }</span>

        // Sample first 1000 characters
        <span class="cov8" title="1">sample := text
        if len(text) &gt; 1000 </span><span class="cov0" title="0">{
                sample = text[:1000]
        }</span>

        // Count character types
        <span class="cov8" title="1">var (
                cyrillic int
                latin    int
                cjk      int
                arabic   int
        )

        for _, r := range sample </span><span class="cov8" title="1">{
                switch </span>{
                case isCyrillic(r):<span class="cov8" title="1">
                        cyrillic++</span>
                case isLatin(r):<span class="cov8" title="1">
                        latin++</span>
                case isCJK(r):<span class="cov8" title="1">
                        cjk++</span>
                case isArabic(r):<span class="cov8" title="1">
                        arabic++</span>
                }
        }

        // Determine language by character frequency
        <span class="cov8" title="1">total := cyrillic + latin + cjk + arabic
        if total == 0 </span><span class="cov8" title="1">{
                return English // default
        }</span>

        // CJK languages
        <span class="cov8" title="1">if float64(cjk)/float64(total) &gt; 0.3 </span><span class="cov8" title="1">{
                // Could be Chinese, Japanese, or Korean
                // For now, default to Chinese
                return Chinese
        }</span>

        // Arabic
        <span class="cov8" title="1">if float64(arabic)/float64(total) &gt; 0.3 </span><span class="cov8" title="1">{
                return Arabic
        }</span>

        // Cyrillic scripts
        <span class="cov8" title="1">if float64(cyrillic)/float64(total) &gt; 0.3 </span><span class="cov8" title="1">{
                // Try to distinguish between Russian, Serbian, Ukrainian, etc.
                return d.detectCyrillicLanguage(sample)
        }</span>

        // Latin scripts - default to English
        // Could be improved with n-gram analysis
        <span class="cov8" title="1">return English</span>
}

// detectCyrillicLanguage distinguishes between Cyrillic languages
func (d *Detector) detectCyrillicLanguage(text string) Language <span class="cov8" title="1">{
        // Count language-specific characters
        var (
                russianChars  int
                serbianChars  int
                ukrainianChars int
        )

        for _, r := range text </span><span class="cov8" title="1">{
                switch r </span>{
                case '–Å', '—ë', '–´', '—ã', '–≠', '—ç':<span class="cov8" title="1">
                        russianChars++</span>
                case '–Ç', '—í', '–ã', '—õ', '–â', '—ô', '–ä', '—ö', '–è', '—ü':<span class="cov0" title="0">
                        serbianChars++</span>
                case '–Ñ', '—î', '–Ü', '—ñ', '–á', '—ó', '“ê', '“ë':<span class="cov8" title="1">
                        ukrainianChars++</span>
                }
        }

        // Return language with most specific characters
        <span class="cov8" title="1">if serbianChars &gt; russianChars &amp;&amp; serbianChars &gt; ukrainianChars </span><span class="cov0" title="0">{
                return Serbian
        }</span>
        <span class="cov8" title="1">if ukrainianChars &gt; russianChars &amp;&amp; ukrainianChars &gt; serbianChars </span><span class="cov8" title="1">{
                return Ukrainian
        }</span>

        // Default to Russian for Cyrillic
        <span class="cov8" title="1">return Russian</span>
}

// ParseLanguage parses a language string (code or name)
func ParseLanguage(s string) (Language, error) <span class="cov0" title="0">{
        s = strings.TrimSpace(strings.ToLower(s))
        if lang, ok := languageMap[s]; ok </span><span class="cov0" title="0">{
                return lang, nil
        }</span>
        <span class="cov0" title="0">return Language{}, fmt.Errorf("unknown language: %s", s)</span>
}

// GetSupportedLanguages returns list of supported languages
func GetSupportedLanguages() []Language <span class="cov0" title="0">{
        return []Language{
                English, Russian, Serbian, German, French, Spanish,
                Italian, Portuguese, Chinese, Japanese, Korean, Arabic,
                Polish, Ukrainian, Czech, Slovak, Croatian, Bulgarian,
        }
}</span>

// isCyrillic checks if a rune is Cyrillic
func isCyrillic(r rune) bool <span class="cov8" title="1">{
        return unicode.Is(unicode.Cyrillic, r)
}</span>

// isLatin checks if a rune is Latin
func isLatin(r rune) bool <span class="cov8" title="1">{
        return unicode.Is(unicode.Latin, r)
}</span>

// isCJK checks if a rune is CJK (Chinese, Japanese, Korean)
func isCJK(r rune) bool <span class="cov8" title="1">{
        return unicode.Is(unicode.Han, r) ||
                unicode.Is(unicode.Hiragana, r) ||
                unicode.Is(unicode.Katakana, r) ||
                unicode.Is(unicode.Hangul, r)
}</span>

// isArabic checks if a rune is Arabic
func isArabic(r rune) bool <span class="cov8" title="1">{
        return unicode.Is(unicode.Arabic, r)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package language

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strings"
        "time"
)

// SimpleLLMDetector implements LLM-based language detection
type SimpleLLMDetector struct {
        apiKey   string
        provider string
        baseURL  string
        model    string
        client   *http.Client
}

// NewSimpleLLMDetector creates a new LLM detector
func NewSimpleLLMDetector(provider, apiKey string) *SimpleLLMDetector <span class="cov8" title="1">{
        detector := &amp;SimpleLLMDetector{
                apiKey:   apiKey,
                provider: provider,
                client: &amp;http.Client{
                        Timeout: 30 * time.Second,
                },
        }

        // Set provider-specific defaults
        switch provider </span>{
        case "openai":<span class="cov8" title="1">
                detector.baseURL = "https://api.openai.com/v1"
                detector.model = "gpt-3.5-turbo"</span>
        case "deepseek":<span class="cov0" title="0">
                detector.baseURL = "https://api.deepseek.com/v1"
                detector.model = "deepseek-chat"</span>
        case "anthropic":<span class="cov0" title="0">
                detector.baseURL = "https://api.anthropic.com/v1"
                detector.model = "claude-3-haiku-20240307"</span>
        case "zhipu":<span class="cov0" title="0">
                detector.baseURL = "https://open.bigmodel.cn/api/paas/v4"
                detector.model = "glm-4"</span>
        default:<span class="cov0" title="0">
                detector.baseURL = "https://api.openai.com/v1"
                detector.model = "gpt-3.5-turbo"</span>
        }

        <span class="cov8" title="1">return detector</span>
}

// DetectLanguage detects language using LLM
func (d *SimpleLLMDetector) DetectLanguage(ctx context.Context, text string) (string, error) <span class="cov8" title="1">{
        if text == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("empty text provided")
        }</span>

        // Sample text (first 500 characters)
        <span class="cov8" title="1">sample := text
        if len(text) &gt; 500 </span><span class="cov0" title="0">{
                sample = text[:500]
        }</span>

        // Create prompt for language detection
        <span class="cov8" title="1">prompt := fmt.Sprintf(`Identify the language of the following text.
Respond with ONLY the ISO 639-1 language code (e.g., "en" for English, "ru" for Russian, "sr" for Serbian, "de" for German).
Do not include any explanation, just the 2-letter code.

Text:
%s

Language code:`, sample)

        // Call LLM API based on provider
        switch d.provider </span>{
        case "openai", "deepseek":<span class="cov8" title="1">
                return d.callOpenAICompatible(ctx, prompt)</span>
        case "anthropic":<span class="cov0" title="0">
                return d.callAnthropic(ctx, prompt)</span>
        case "zhipu":<span class="cov0" title="0">
                return d.callZhipu(ctx, prompt)</span>
        default:<span class="cov0" title="0">
                return d.callOpenAICompatible(ctx, prompt)</span>
        }
}

// callOpenAICompatible calls OpenAI-compatible APIs (OpenAI, DeepSeek)
func (d *SimpleLLMDetector) callOpenAICompatible(ctx context.Context, prompt string) (string, error) <span class="cov8" title="1">{
        request := map[string]interface{}{
                "model": d.model,
                "messages": []map[string]string{
                        {"role": "user", "content": prompt},
                },
                "temperature": 0.0, // Deterministic response
                "max_tokens":  10,  // Only need a short response
        }

        jsonData, err := json.Marshal(request)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, "POST", d.baseURL+"/chat/completions", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+d.apiKey)

        resp, err := d.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to send request: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                return "", fmt.Errorf("API error (status %d): %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var response struct {
                Choices []struct {
                        Message struct {
                                Content string `json:"content"`
                        } `json:"message"`
                } `json:"choices"`
        }

        if err := json.Unmarshal(body, &amp;response); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to unmarshal response: %w", err)
        }</span>

        <span class="cov0" title="0">if len(response.Choices) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no choices in response")
        }</span>

        <span class="cov0" title="0">content := strings.TrimSpace(response.Choices[0].Message.Content)
        return FormatLanguageCode(content), nil</span>
}

// callAnthropic calls Anthropic Claude API
func (d *SimpleLLMDetector) callAnthropic(ctx context.Context, prompt string) (string, error) <span class="cov0" title="0">{
        request := map[string]interface{}{
                "model":      d.model,
                "max_tokens": 10,
                "messages": []map[string]string{
                        {"role": "user", "content": prompt},
                },
        }

        jsonData, err := json.Marshal(request)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, "POST", d.baseURL+"/messages", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("x-api-key", d.apiKey)
        req.Header.Set("anthropic-version", "2023-06-01")

        resp, err := d.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to send request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return "", fmt.Errorf("API error (status %d): %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var response struct {
                Content []struct {
                        Text string `json:"text"`
                } `json:"content"`
        }

        if err := json.Unmarshal(body, &amp;response); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to unmarshal response: %w", err)
        }</span>

        <span class="cov0" title="0">if len(response.Content) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no content in response")
        }</span>

        <span class="cov0" title="0">content := strings.TrimSpace(response.Content[0].Text)
        return FormatLanguageCode(content), nil</span>
}

// callZhipu calls Zhipu AI API
func (d *SimpleLLMDetector) callZhipu(ctx context.Context, prompt string) (string, error) <span class="cov0" title="0">{
        request := map[string]interface{}{
                "model": d.model,
                "messages": []map[string]string{
                        {"role": "user", "content": prompt},
                },
                "temperature": 0.0,
                "max_tokens":  10,
        }

        jsonData, err := json.Marshal(request)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, "POST", d.baseURL+"/chat/completions", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+d.apiKey)

        resp, err := d.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to send request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return "", fmt.Errorf("API error (status %d): %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var response struct {
                Choices []struct {
                        Message struct {
                                Content string `json:"content"`
                        } `json:"message"`
                } `json:"choices"`
        }

        if err := json.Unmarshal(body, &amp;response); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to unmarshal response: %w", err)
        }</span>

        <span class="cov0" title="0">if len(response.Choices) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no choices in response")
        }</span>

        <span class="cov0" title="0">content := strings.TrimSpace(response.Choices[0].Message.Content)
        return FormatLanguageCode(content), nil</span>
}

// FormatLanguageCode normalizes language codes
func FormatLanguageCode(code string) string <span class="cov8" title="1">{
        code = strings.TrimSpace(strings.ToLower(code))

        // Handle common variations
        if len(code) &gt; 2 </span><span class="cov8" title="1">{
                code = code[:2]
        }</span>

        <span class="cov8" title="1">return code</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package markdown

import (
        "archive/zip"
        "digital.vasic.translator/pkg/ebook"
        "encoding/xml"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"

        "golang.org/x/net/html"
)

// EPUBToMarkdownConverter converts EPUB files to Markdown format
type EPUBToMarkdownConverter struct {
        preserveImages bool
        imagesDir      string
}

// NewEPUBToMarkdownConverter creates a new converter
func NewEPUBToMarkdownConverter(preserveImages bool, imagesDir string) *EPUBToMarkdownConverter <span class="cov8" title="1">{
        return &amp;EPUBToMarkdownConverter{
                preserveImages: preserveImages,
                imagesDir:      imagesDir,
        }
}</span>

// ConvertEPUBToMarkdown converts an EPUB file to Markdown
func (c *EPUBToMarkdownConverter) ConvertEPUBToMarkdown(epubPath, outputMDPath string) error <span class="cov8" title="1">{
        // Set up images directory next to markdown file
        if c.imagesDir == "" </span><span class="cov8" title="1">{
                mdDir := filepath.Dir(outputMDPath)
                c.imagesDir = filepath.Join(mdDir, "Images")
        }</span>

        // Create Images directory
        <span class="cov8" title="1">if err := os.MkdirAll(c.imagesDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create images directory: %w", err)
        }</span>

        // Parse EPUB using universal parser to get metadata including cover
        <span class="cov8" title="1">parser := ebook.NewUniversalParser()
        book, err := parser.Parse(epubPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse EPUB: %w", err)
        }</span>
        <span class="cov8" title="1">metadata := book.Metadata

        // Open EPUB again to get content files structure
        r, err := zip.OpenReader(epubPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open EPUB: %w", err)
        }</span>
        <span class="cov8" title="1">defer r.Close()

        // Get content files structure
        _, contentFiles, opfDir, err := c.parseEPUBStructure(r)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse EPUB structure: %w", err)
        }</span>

        // Extract cover image if present
        <span class="cov8" title="1">var coverFilename string
        if len(metadata.Cover) &gt; 0 </span><span class="cov8" title="1">{
                coverFilename = "cover.jpg"
                coverPath := filepath.Join(c.imagesDir, coverFilename)
                if err := os.WriteFile(coverPath, metadata.Cover, 0644); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write cover image: %w", err)
                }</span>
        }

        // Extract all images from EPUB
        <span class="cov8" title="1">if err := c.extractImages(r, opfDir); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to extract images: %w", err)
        }</span>

        // Create markdown content
        <span class="cov8" title="1">var mdContent strings.Builder

        // Add title and metadata (YAML frontmatter)
        mdContent.WriteString("---\n")
        mdContent.WriteString(fmt.Sprintf("title: %s\n", metadata.Title))
        if len(metadata.Authors) &gt; 0 </span><span class="cov8" title="1">{
                mdContent.WriteString(fmt.Sprintf("authors: %s\n", strings.Join(metadata.Authors, ", ")))
        }</span>
        <span class="cov8" title="1">if metadata.Description != "" </span><span class="cov8" title="1">{
                // Escape multi-line descriptions
                desc := strings.ReplaceAll(metadata.Description, "\n", " ")
                mdContent.WriteString(fmt.Sprintf("description: %s\n", desc))
        }</span>
        <span class="cov8" title="1">if metadata.Publisher != "" </span><span class="cov8" title="1">{
                mdContent.WriteString(fmt.Sprintf("publisher: %s\n", metadata.Publisher))
        }</span>
        <span class="cov8" title="1">mdContent.WriteString(fmt.Sprintf("language: %s\n", metadata.Language))
        if metadata.ISBN != "" </span><span class="cov8" title="1">{
                mdContent.WriteString(fmt.Sprintf("isbn: %s\n", metadata.ISBN))
        }</span>
        <span class="cov8" title="1">if metadata.Date != "" </span><span class="cov8" title="1">{
                mdContent.WriteString(fmt.Sprintf("date: %s\n", metadata.Date))
        }</span>
        <span class="cov8" title="1">if coverFilename != "" </span><span class="cov8" title="1">{
                mdContent.WriteString(fmt.Sprintf("cover: Images/%s\n", coverFilename))
        }</span>
        <span class="cov8" title="1">mdContent.WriteString("---\n\n")

        // Add main title
        mdContent.WriteString(fmt.Sprintf("# %s\n\n", metadata.Title))
        if len(metadata.Authors) &gt; 0 </span><span class="cov8" title="1">{
                mdContent.WriteString(fmt.Sprintf("**By %s**\n\n", strings.Join(metadata.Authors, ", ")))
        }</span>
        <span class="cov8" title="1">mdContent.WriteString("---\n\n")

        // Process each chapter
        for idx, contentFile := range contentFiles </span><span class="cov8" title="1">{
                fullPath := opfDir + contentFile
                for _, f := range r.File </span><span class="cov8" title="1">{
                        if f.Name == fullPath </span><span class="cov8" title="1">{
                                chapterMD, err := c.convertHTMLToMarkdown(f, idx+1)
                                if err == nil &amp;&amp; chapterMD != "" </span><span class="cov8" title="1">{
                                        mdContent.WriteString(chapterMD)
                                        mdContent.WriteString("\n\n---\n\n")
                                }</span>
                                <span class="cov8" title="1">break</span>
                        }
                }
        }

        // Write markdown file
        <span class="cov8" title="1">if err := os.WriteFile(outputMDPath, []byte(mdContent.String()), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write markdown: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// parseEPUBStructure extracts metadata and content file paths from EPUB
func (c *EPUBToMarkdownConverter) parseEPUBStructure(r *zip.ReadCloser) (*ebook.Metadata, []string, string, error) <span class="cov8" title="1">{
        // Find container.xml to locate content.opf
        opfPath := ""
        for _, f := range r.File </span><span class="cov8" title="1">{
                if f.Name == "META-INF/container.xml" </span><span class="cov8" title="1">{
                        var err error
                        opfPath, err = c.parseContainer(f)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, "", err
                        }</span>
                        <span class="cov8" title="1">break</span>
                }
        }

        <span class="cov8" title="1">if opfPath == "" </span><span class="cov0" title="0">{
                return nil, nil, "", fmt.Errorf("container.xml not found")
        }</span>

        // Parse content.opf
        <span class="cov8" title="1">var metadata ebook.Metadata
        var contentFiles []string
        for _, f := range r.File </span><span class="cov8" title="1">{
                if f.Name == opfPath </span><span class="cov8" title="1">{
                        var err error
                        metadata, contentFiles, err = c.parseOPF(f)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, "", err
                        }</span>
                        <span class="cov8" title="1">break</span>
                }
        }

        // Extract OPF directory path
        <span class="cov8" title="1">opfDir := ""
        if idx := strings.LastIndex(opfPath, "/"); idx != -1 </span><span class="cov8" title="1">{
                opfDir = opfPath[:idx+1]
        }</span>

        <span class="cov8" title="1">return &amp;metadata, contentFiles, opfDir, nil</span>
}

// parseContainer parses container.xml
func (c *EPUBToMarkdownConverter) parseContainer(f *zip.File) (string, error) <span class="cov8" title="1">{
        rc, err := f.Open()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">defer rc.Close()

        type Container struct {
                Rootfiles struct {
                        Rootfile []struct {
                                FullPath string `xml:"full-path,attr"`
                        } `xml:"rootfile"`
                } `xml:"rootfiles"`
        }

        var container Container
        if err := xml.NewDecoder(rc).Decode(&amp;container); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">if len(container.Rootfiles.Rootfile) &gt; 0 </span><span class="cov8" title="1">{
                return container.Rootfiles.Rootfile[0].FullPath, nil
        }</span>

        <span class="cov0" title="0">return "", fmt.Errorf("no rootfile found")</span>
}

// parseOPF parses content.opf for metadata and spine
func (c *EPUBToMarkdownConverter) parseOPF(f *zip.File) (ebook.Metadata, []string, error) <span class="cov8" title="1">{
        rc, err := f.Open()
        if err != nil </span><span class="cov0" title="0">{
                return ebook.Metadata{}, nil, err
        }</span>
        <span class="cov8" title="1">defer rc.Close()

        type Package struct {
                Metadata struct {
                        Title       []string `xml:"title"`
                        Creator     []string `xml:"creator"`
                        Language    string   `xml:"language"`
                        Description []string `xml:"description"`
                        Publisher   []string `xml:"publisher"`
                        Date        []string `xml:"date"`
                        Identifier  []string `xml:"identifier"`
                } `xml:"metadata"`
                Spine struct {
                        Itemref []struct {
                                Idref string `xml:"idref,attr"`
                        } `xml:"itemref"`
                } `xml:"spine"`
                Manifest struct {
                        Item []struct {
                                ID   string `xml:"id,attr"`
                                Href string `xml:"href,attr"`
                        } `xml:"item"`
                } `xml:"manifest"`
        }

        var pkg Package
        if err := xml.NewDecoder(rc).Decode(&amp;pkg); err != nil </span><span class="cov0" title="0">{
                return ebook.Metadata{}, nil, err
        }</span>

        <span class="cov8" title="1">metadata := ebook.Metadata{
                Language: pkg.Metadata.Language,
                Authors:  pkg.Metadata.Creator,
        }
        if len(pkg.Metadata.Title) &gt; 0 </span><span class="cov8" title="1">{
                metadata.Title = pkg.Metadata.Title[0]
        }</span>
        <span class="cov8" title="1">if len(pkg.Metadata.Description) &gt; 0 </span><span class="cov8" title="1">{
                metadata.Description = pkg.Metadata.Description[0]
        }</span>
        <span class="cov8" title="1">if len(pkg.Metadata.Publisher) &gt; 0 </span><span class="cov8" title="1">{
                metadata.Publisher = pkg.Metadata.Publisher[0]
        }</span>
        <span class="cov8" title="1">if len(pkg.Metadata.Date) &gt; 0 </span><span class="cov8" title="1">{
                metadata.Date = pkg.Metadata.Date[0]
        }</span>
        // Extract ISBN from identifier
        <span class="cov8" title="1">for _, id := range pkg.Metadata.Identifier </span><span class="cov8" title="1">{
                if strings.Contains(strings.ToLower(id), "isbn") || len(id) &gt;= 10 </span><span class="cov8" title="1">{
                        metadata.ISBN = id
                        break</span>
                }
        }

        // Build ID to href mapping
        <span class="cov8" title="1">idToHref := make(map[string]string)
        for _, item := range pkg.Manifest.Item </span><span class="cov8" title="1">{
                idToHref[item.ID] = item.Href
        }</span>

        // Get content files in spine order
        <span class="cov8" title="1">var contentFiles []string
        for _, itemref := range pkg.Spine.Itemref </span><span class="cov8" title="1">{
                if href, ok := idToHref[itemref.Idref]; ok </span><span class="cov8" title="1">{
                        contentFiles = append(contentFiles, href)
                }</span>
        }

        <span class="cov8" title="1">return metadata, contentFiles, nil</span>
}

// convertHTMLToMarkdown converts an HTML/XHTML file to Markdown
func (c *EPUBToMarkdownConverter) convertHTMLToMarkdown(f *zip.File, chapterNum int) (string, error) <span class="cov8" title="1">{
        rc, err := f.Open()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">defer rc.Close()

        data, err := io.ReadAll(rc)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Parse HTML
        <span class="cov8" title="1">doc, err := html.Parse(strings.NewReader(string(data)))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to parse HTML: %w", err)
        }</span>

        // Find the body element
        <span class="cov8" title="1">body := c.findBody(doc)
        if body == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        // Convert body content to markdown
        <span class="cov8" title="1">var mdBuilder strings.Builder
        c.convertChildren(body, &amp;mdBuilder, 0)

        content := mdBuilder.String()
        content = strings.TrimSpace(content)

        if content == "" </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov8" title="1">return content, nil</span>
}

// findBody recursively searches for the body element
func (c *EPUBToMarkdownConverter) findBody(n *html.Node) *html.Node <span class="cov8" title="1">{
        if n.Type == html.ElementNode &amp;&amp; n.Data == "body" </span><span class="cov8" title="1">{
                return n
        }</span>
        <span class="cov8" title="1">for child := n.FirstChild; child != nil; child = child.NextSibling </span><span class="cov8" title="1">{
                if body := c.findBody(child); body != nil </span><span class="cov8" title="1">{
                        return body
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// convertNode recursively converts HTML nodes to Markdown
func (c *EPUBToMarkdownConverter) convertNode(n *html.Node, md *strings.Builder, depth int) <span class="cov8" title="1">{
        if n.Type == html.TextNode </span><span class="cov8" title="1">{
                text := strings.TrimSpace(n.Data)
                if text != "" </span><span class="cov8" title="1">{
                        md.WriteString(text)
                }</span>
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">if n.Type == html.ElementNode </span><span class="cov8" title="1">{
                switch n.Data </span>{
                case "h1":<span class="cov8" title="1">
                        md.WriteString("\n\n# ")
                        c.convertChildren(n, md, depth)
                        md.WriteString("\n\n")</span>
                case "h2":<span class="cov0" title="0">
                        md.WriteString("\n\n## ")
                        c.convertChildren(n, md, depth)
                        md.WriteString("\n\n")</span>
                case "h3":<span class="cov0" title="0">
                        md.WriteString("\n\n### ")
                        c.convertChildren(n, md, depth)
                        md.WriteString("\n\n")</span>
                case "h4":<span class="cov0" title="0">
                        md.WriteString("\n\n#### ")
                        c.convertChildren(n, md, depth)
                        md.WriteString("\n\n")</span>
                case "h5":<span class="cov0" title="0">
                        md.WriteString("\n\n##### ")
                        c.convertChildren(n, md, depth)
                        md.WriteString("\n\n")</span>
                case "h6":<span class="cov0" title="0">
                        md.WriteString("\n\n###### ")
                        c.convertChildren(n, md, depth)
                        md.WriteString("\n\n")</span>
                case "p":<span class="cov8" title="1">
                        md.WriteString("\n\n")
                        c.convertChildren(n, md, depth)
                        md.WriteString("\n\n")</span>
                case "br":<span class="cov0" title="0">
                        md.WriteString("  \n")</span>
                case "strong", "b":<span class="cov0" title="0">
                        md.WriteString("**")
                        c.convertChildren(n, md, depth)
                        md.WriteString("**")</span>
                case "em", "i":<span class="cov0" title="0">
                        md.WriteString("*")
                        c.convertChildren(n, md, depth)
                        md.WriteString("*")</span>
                case "code":<span class="cov0" title="0">
                        md.WriteString("`")
                        c.convertChildren(n, md, depth)
                        md.WriteString("`")</span>
                case "pre":<span class="cov0" title="0">
                        md.WriteString("\n\n```\n")
                        c.convertChildren(n, md, depth)
                        md.WriteString("\n```\n\n")</span>
                case "blockquote":<span class="cov0" title="0">
                        md.WriteString("\n\n&gt; ")
                        c.convertChildren(n, md, depth)
                        md.WriteString("\n\n")</span>
                case "ul":<span class="cov0" title="0">
                        md.WriteString("\n\n")
                        c.convertChildren(n, md, depth+1)
                        md.WriteString("\n\n")</span>
                case "ol":<span class="cov0" title="0">
                        md.WriteString("\n\n")
                        c.convertChildren(n, md, depth+1)
                        md.WriteString("\n\n")</span>
                case "li":<span class="cov0" title="0">
                        if depth &gt; 0 </span><span class="cov0" title="0">{
                                md.WriteString(strings.Repeat("  ", depth-1))
                                md.WriteString("- ")
                                c.convertChildren(n, md, depth)
                                md.WriteString("\n")
                        }</span>
                case "a":<span class="cov0" title="0">
                        href := c.getAttribute(n, "href")
                        md.WriteString("[")
                        c.convertChildren(n, md, depth)
                        md.WriteString("](")
                        md.WriteString(href)
                        md.WriteString(")")</span>
                case "img":<span class="cov0" title="0">
                        src := c.getAttribute(n, "src")
                        alt := c.getAttribute(n, "alt")
                        // Convert image src to Images/ reference
                        imgFilename := filepath.Base(src)
                        md.WriteString(fmt.Sprintf("![%s](Images/%s)", alt, imgFilename))</span>
                case "hr":<span class="cov0" title="0">
                        md.WriteString("\n\n---\n\n")</span>
                default:<span class="cov0" title="0">
                        // For unknown elements, just process children
                        c.convertChildren(n, md, depth)</span>
                }
        }
        // Note: Sibling processing is handled by convertChildren loop
}

// convertChildren converts all child nodes
func (c *EPUBToMarkdownConverter) convertChildren(n *html.Node, md *strings.Builder, depth int) <span class="cov8" title="1">{
        for child := n.FirstChild; child != nil; child = child.NextSibling </span><span class="cov8" title="1">{
                c.convertNode(child, md, depth)
        }</span>
}

// getAttribute gets an attribute value from a node
func (c *EPUBToMarkdownConverter) getAttribute(n *html.Node, key string) string <span class="cov0" title="0">{
        for _, attr := range n.Attr </span><span class="cov0" title="0">{
                if attr.Key == key </span><span class="cov0" title="0">{
                        return attr.Val
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// extractImages extracts all images from EPUB to Images directory
func (c *EPUBToMarkdownConverter) extractImages(r *zip.ReadCloser, opfDir string) error <span class="cov8" title="1">{
        for _, f := range r.File </span><span class="cov8" title="1">{
                // Check if file is an image
                if strings.HasPrefix(f.Name, opfDir) &amp;&amp; isImageFile(f.Name) </span><span class="cov8" title="1">{
                        // Extract filename from path
                        filename := filepath.Base(f.Name)

                        // Skip cover.jpg (already extracted separately)
                        if filename == "cover.jpg" </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        // Read image data
                        <span class="cov0" title="0">rc, err := f.Open()
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">imgData, err := io.ReadAll(rc)
                        rc.Close()
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Write to Images directory
                        <span class="cov0" title="0">imgPath := filepath.Join(c.imagesDir, filename)
                        if err := os.WriteFile(imgPath, imgData, 0644); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to write image %s: %w", filename, err)
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// isImageFile checks if filename has an image extension
func isImageFile(filename string) bool <span class="cov8" title="1">{
        ext := strings.ToLower(filepath.Ext(filename))
        return ext == ".jpg" || ext == ".jpeg" || ext == ".png" || ext == ".gif" || ext == ".svg" || ext == ".webp"
}</span>

// ConvertBookToMarkdown converts a Book struct to markdown and saves it
func ConvertBookToMarkdown(book *ebook.Book, outputPath string) error <span class="cov8" title="1">{
        var mdContent strings.Builder

        // Add frontmatter
        mdContent.WriteString("---\n")
        mdContent.WriteString(fmt.Sprintf("title: %s\n", book.Metadata.Title))
        if len(book.Metadata.Authors) &gt; 0 </span><span class="cov8" title="1">{
                mdContent.WriteString(fmt.Sprintf("authors: %s\n", strings.Join(book.Metadata.Authors, ", ")))
        }</span>
        <span class="cov8" title="1">mdContent.WriteString(fmt.Sprintf("language: %s\n", book.Metadata.Language))
        mdContent.WriteString("---\n\n")

        // Add main title
        mdContent.WriteString(fmt.Sprintf("# %s\n\n", book.Metadata.Title))
        if len(book.Metadata.Authors) &gt; 0 </span><span class="cov8" title="1">{
                mdContent.WriteString(fmt.Sprintf("**By %s**\n\n", strings.Join(book.Metadata.Authors, ", ")))
        }</span>
        <span class="cov8" title="1">mdContent.WriteString("---\n\n")

        // Add chapters
        for idx, chapter := range book.Chapters </span><span class="cov8" title="1">{
                mdContent.WriteString(fmt.Sprintf("## Chapter %d\n\n", idx+1))
                if chapter.Title != "" </span><span class="cov8" title="1">{
                        mdContent.WriteString(fmt.Sprintf("### %s\n\n", chapter.Title))
                }</span>

                <span class="cov8" title="1">for _, section := range chapter.Sections </span><span class="cov8" title="1">{
                        mdContent.WriteString(section.Content)
                        mdContent.WriteString("\n\n")
                }</span>

                <span class="cov8" title="1">mdContent.WriteString("---\n\n")</span>
        }

        // Ensure output directory exists
        <span class="cov8" title="1">dir := filepath.Dir(outputPath)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create output directory: %w", err)
        }</span>

        // Write to file
        <span class="cov8" title="1">if err := os.WriteFile(outputPath, []byte(mdContent.String()), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write markdown file: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package markdown

import (
        "archive/zip"
        "bufio"
        "digital.vasic.translator/pkg/ebook"
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strings"
)

// MarkdownToEPUBConverter converts Markdown files to EPUB format
type MarkdownToEPUBConverter struct {
        metadata ebook.Metadata
        hrRegex  *regexp.Regexp
}

// NewMarkdownToEPUBConverter creates a new converter
func NewMarkdownToEPUBConverter() *MarkdownToEPUBConverter <span class="cov8" title="1">{
        return &amp;MarkdownToEPUBConverter{
                metadata: ebook.Metadata{},
                hrRegex:  regexp.MustCompile(`^[-*_]{3,}$`),
        }
}</span>

// ConvertMarkdownToEPUB converts a markdown file to EPUB
func (c *MarkdownToEPUBConverter) ConvertMarkdownToEPUB(mdPath, epubPath string) error <span class="cov8" title="1">{
        // Read markdown file
        content, err := os.ReadFile(mdPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read markdown: %w", err)
        }</span>

        // Parse markdown into chapters
        <span class="cov8" title="1">chapters, metadata, coverPath, err := c.parseMarkdown(string(content), filepath.Dir(mdPath))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse markdown: %w", err)
        }</span>

        // Load cover image if specified
        <span class="cov8" title="1">if coverPath != "" </span><span class="cov8" title="1">{
                coverData, err := os.ReadFile(coverPath)
                if err == nil </span><span class="cov8" title="1">{
                        metadata.Cover = coverData
                }</span>
        }

        <span class="cov8" title="1">c.metadata = metadata

        // Create EPUB
        if err := c.createEPUB(chapters, epubPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create EPUB: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// parseMarkdown parses markdown content into chapters
func (c *MarkdownToEPUBConverter) parseMarkdown(content string, mdDir string) ([]ebook.Chapter, ebook.Metadata, string, error) <span class="cov8" title="1">{
        var metadata ebook.Metadata
        var chapters []ebook.Chapter
        var currentChapter *ebook.Chapter
        var currentContent strings.Builder
        var coverPath string

        scanner := bufio.NewScanner(strings.NewReader(content))
        inFrontmatter := false
        frontmatterDone := false
        frontmatterCount := 0
        skipNextLines := 0

        for scanner.Scan() </span><span class="cov8" title="1">{
                line := scanner.Text()

                // Handle frontmatter (only before it's done)
                if !frontmatterDone &amp;&amp; line == "---" </span><span class="cov8" title="1">{
                        frontmatterCount++
                        if frontmatterCount == 1 </span><span class="cov8" title="1">{
                                inFrontmatter = true
                                continue</span>
                        } else<span class="cov8" title="1"> if frontmatterCount &gt;= 2 </span><span class="cov8" title="1">{
                                inFrontmatter = false
                                frontmatterDone = true
                                // Skip next 5 lines (title, author, separator after frontmatter)
                                skipNextLines = 5
                                continue</span>
                        }
                }

                <span class="cov8" title="1">if inFrontmatter </span><span class="cov8" title="1">{
                        // Parse metadata
                        if cover := c.parseFrontmatterLine(line, &amp;metadata); cover != "" </span><span class="cov8" title="1">{
                                // Resolve cover path relative to markdown file
                                coverPath = filepath.Join(mdDir, cover)
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                // Skip lines after frontmatter (title, author, separator)
                <span class="cov8" title="1">if skipNextLines &gt; 0 </span><span class="cov8" title="1">{
                        skipNextLines--
                        continue</span>
                }

                // Chapter marker (# or ## followed by text)
                <span class="cov8" title="1">if (strings.HasPrefix(line, "# ") || strings.HasPrefix(line, "## ")) &amp;&amp;
                        strings.TrimSpace(strings.TrimPrefix(strings.TrimPrefix(line, "##"), "#")) != "" </span><span class="cov8" title="1">{
                        // Save previous chapter
                        if currentChapter != nil </span><span class="cov0" title="0">{
                                currentChapter.Sections = []ebook.Section{
                                        {Content: strings.TrimSpace(currentContent.String())},
                                }
                                chapters = append(chapters, *currentChapter)
                                currentContent.Reset()
                        }</span>

                        // Start new chapter
                        <span class="cov8" title="1">chapterTitle := strings.TrimSpace(strings.TrimPrefix(strings.TrimPrefix(line, "##"), "#"))
                        currentChapter = &amp;ebook.Chapter{
                                Title:    chapterTitle,
                                Sections: []ebook.Section{},
                        }
                        continue</span>
                }

                // Horizontal rule (chapter separator) - also saves chapter
                <span class="cov8" title="1">if c.hrRegex.MatchString(strings.TrimSpace(line)) </span><span class="cov8" title="1">{
                        if currentChapter != nil </span><span class="cov8" title="1">{
                                currentChapter.Sections = []ebook.Section{
                                        {Content: strings.TrimSpace(currentContent.String())},
                                }
                                chapters = append(chapters, *currentChapter)
                                currentChapter = nil
                                currentContent.Reset()
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                // Add content to current chapter
                <span class="cov8" title="1">if currentChapter != nil </span><span class="cov8" title="1">{
                        currentContent.WriteString(line + "\n")
                }</span>
        }

        // Save last chapter
        <span class="cov8" title="1">if currentChapter != nil </span><span class="cov8" title="1">{
                currentChapter.Sections = []ebook.Section{
                        {Content: strings.TrimSpace(currentContent.String())},
                }
                chapters = append(chapters, *currentChapter)
        }</span>

        <span class="cov8" title="1">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, "", fmt.Errorf("error reading markdown: %w", err)
        }</span>

        <span class="cov8" title="1">return chapters, metadata, coverPath, nil</span>
}

// parseFrontmatterLine parses a frontmatter YAML line and returns cover path if present
func (c *MarkdownToEPUBConverter) parseFrontmatterLine(line string, metadata *ebook.Metadata) string <span class="cov8" title="1">{
        parts := strings.SplitN(line, ":", 2)
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">key := strings.TrimSpace(parts[0])
        value := strings.TrimSpace(parts[1])

        switch key </span>{
        case "title":<span class="cov8" title="1">
                metadata.Title = value</span>
        case "authors":<span class="cov8" title="1">
                metadata.Authors = strings.Split(value, ",")
                for i := range metadata.Authors </span><span class="cov8" title="1">{
                        metadata.Authors[i] = strings.TrimSpace(metadata.Authors[i])
                }</span>
        case "description":<span class="cov8" title="1">
                metadata.Description = value</span>
        case "publisher":<span class="cov8" title="1">
                metadata.Publisher = value</span>
        case "language":<span class="cov8" title="1">
                metadata.Language = value</span>
        case "isbn":<span class="cov8" title="1">
                metadata.ISBN = value</span>
        case "date":<span class="cov8" title="1">
                metadata.Date = value</span>
        case "cover":<span class="cov8" title="1">
                // Return the cover path for loading the cover image
                return value</span>
        case "has_cover":<span class="cov0" title="0"></span>
                // Cover presence is tracked but binary data is preserved separately
                // This flag just indicates the original had a cover
        }
        <span class="cov8" title="1">return ""</span>
}

// createEPUB creates an EPUB file from chapters using the enhanced EPUBWriter
func (c *MarkdownToEPUBConverter) createEPUB(chapters []ebook.Chapter, outputPath string) error <span class="cov8" title="1">{
        // Create Book structure with all metadata
        book := &amp;ebook.Book{
                Metadata: c.metadata,
                Chapters: chapters,
        }

        // Use the enhanced EPUBWriter which handles all metadata properly
        writer := ebook.NewEPUBWriter()
        return writer.Write(book, outputPath)
}</span>

// writeContainer writes META-INF/container.xml
func (c *MarkdownToEPUBConverter) writeContainer(zw *zip.Writer) error <span class="cov0" title="0">{
        writer, err := zw.Create("META-INF/container.xml")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">container := `&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container"&gt;
  &lt;rootfiles&gt;
    &lt;rootfile full-path="OEBPS/content.opf" media-type="application/oebps-package+xml"/&gt;
  &lt;/rootfiles&gt;
&lt;/container&gt;`

        _, err = writer.Write([]byte(container))
        return err</span>
}

// writeContentOPF writes OEBPS/content.opf
func (c *MarkdownToEPUBConverter) writeContentOPF(zw *zip.Writer, chapters []ebook.Chapter) error <span class="cov0" title="0">{
        writer, err := zw.Create("OEBPS/content.opf")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var opf strings.Builder
        opf.WriteString(`&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;package xmlns="http://www.idpf.org/2007/opf" version="2.0" unique-identifier="BookID"&gt;
  &lt;metadata xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:opf="http://www.idpf.org/2007/opf"&gt;
`)

        // Metadata
        opf.WriteString(fmt.Sprintf("    &lt;dc:title&gt;%s&lt;/dc:title&gt;\n", c.escapeXML(c.metadata.Title)))
        for _, author := range c.metadata.Authors </span><span class="cov0" title="0">{
                opf.WriteString(fmt.Sprintf("    &lt;dc:creator&gt;%s&lt;/dc:creator&gt;\n", c.escapeXML(author)))
        }</span>
        <span class="cov0" title="0">opf.WriteString(fmt.Sprintf("    &lt;dc:language&gt;%s&lt;/dc:language&gt;\n", c.metadata.Language))
        opf.WriteString("    &lt;dc:identifier id=\"BookID\"&gt;urn:uuid:generated&lt;/dc:identifier&gt;\n")
        opf.WriteString("  &lt;/metadata&gt;\n")

        // Manifest
        opf.WriteString("  &lt;manifest&gt;\n")
        opf.WriteString("    &lt;item id=\"ncx\" href=\"toc.ncx\" media-type=\"application/x-dtbncx+xml\"/&gt;\n")
        for i := 1; i &lt;= len(chapters); i++ </span><span class="cov0" title="0">{
                opf.WriteString(fmt.Sprintf("    &lt;item id=\"chapter%d\" href=\"chapter%d.xhtml\" media-type=\"application/xhtml+xml\"/&gt;\n", i, i))
        }</span>
        <span class="cov0" title="0">opf.WriteString("  &lt;/manifest&gt;\n")

        // Spine
        opf.WriteString("  &lt;spine toc=\"ncx\"&gt;\n")
        for i := 1; i &lt;= len(chapters); i++ </span><span class="cov0" title="0">{
                opf.WriteString(fmt.Sprintf("    &lt;itemref idref=\"chapter%d\"/&gt;\n", i))
        }</span>
        <span class="cov0" title="0">opf.WriteString("  &lt;/spine&gt;\n")
        opf.WriteString("&lt;/package&gt;")

        _, err = writer.Write([]byte(opf.String()))
        return err</span>
}

// writeTOC writes OEBPS/toc.ncx
func (c *MarkdownToEPUBConverter) writeTOC(zw *zip.Writer, chapters []ebook.Chapter) error <span class="cov0" title="0">{
        writer, err := zw.Create("OEBPS/toc.ncx")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var toc strings.Builder
        toc.WriteString(`&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;ncx xmlns="http://www.daisy.org/z3986/2005/ncx/" version="2005-1"&gt;
  &lt;head&gt;
    &lt;meta name="dtb:uid" content="urn:uuid:generated"/&gt;
    &lt;meta name="dtb:depth" content="1"/&gt;
  &lt;/head&gt;
  &lt;docTitle&gt;
`)
        toc.WriteString(fmt.Sprintf("    &lt;text&gt;%s&lt;/text&gt;\n", c.escapeXML(c.metadata.Title)))
        toc.WriteString("  &lt;/docTitle&gt;\n  &lt;navMap&gt;\n")

        for idx, chapter := range chapters </span><span class="cov0" title="0">{
                toc.WriteString(fmt.Sprintf("    &lt;navPoint id=\"chapter%d\" playOrder=\"%d\"&gt;\n", idx+1, idx+1))
                toc.WriteString(fmt.Sprintf("      &lt;navLabel&gt;&lt;text&gt;%s&lt;/text&gt;&lt;/navLabel&gt;\n", c.escapeXML(chapter.Title)))
                toc.WriteString(fmt.Sprintf("      &lt;content src=\"chapter%d.xhtml\"/&gt;\n", idx+1))
                toc.WriteString("    &lt;/navPoint&gt;\n")
        }</span>

        <span class="cov0" title="0">toc.WriteString("  &lt;/navMap&gt;\n&lt;/ncx&gt;")

        _, err = writer.Write([]byte(toc.String()))
        return err</span>
}

// writeChapterHTML writes a chapter as XHTML
func (c *MarkdownToEPUBConverter) writeChapterHTML(zw *zip.Writer, chapter ebook.Chapter, chapterNum int) error <span class="cov0" title="0">{
        writer, err := zw.Create(fmt.Sprintf("OEBPS/chapter%d.xhtml", chapterNum))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var html strings.Builder
        html.WriteString(`&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;head&gt;
`)
        html.WriteString(fmt.Sprintf("  &lt;title&gt;%s&lt;/title&gt;\n", c.escapeXML(chapter.Title)))
        html.WriteString("  &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/&gt;\n")
        html.WriteString("&lt;/head&gt;\n&lt;body&gt;\n")
        html.WriteString(fmt.Sprintf("  &lt;h1&gt;%s&lt;/h1&gt;\n", c.escapeXML(chapter.Title)))

        // Convert markdown content to HTML
        for _, section := range chapter.Sections </span><span class="cov0" title="0">{
                htmlContent := c.markdownToHTML(section.Content)
                html.WriteString(htmlContent)
        }</span>

        <span class="cov0" title="0">html.WriteString("&lt;/body&gt;\n&lt;/html&gt;")

        _, err = writer.Write([]byte(html.String()))
        return err</span>
}

// markdownToHTML converts markdown content to HTML
func (c *MarkdownToEPUBConverter) markdownToHTML(markdown string) string <span class="cov8" title="1">{
        var html strings.Builder
        scanner := bufio.NewScanner(strings.NewReader(markdown))

        inParagraph := false
        inCodeBlock := false
        var currentParagraph strings.Builder
        var codeBlock strings.Builder

        for scanner.Scan() </span><span class="cov8" title="1">{
                line := scanner.Text()
                trimmed := strings.TrimSpace(line)

                // Code block delimiter
                if strings.HasPrefix(trimmed, "```") </span><span class="cov8" title="1">{
                        if inParagraph </span><span class="cov0" title="0">{
                                html.WriteString("  &lt;p&gt;" + c.convertInlineMarkdown(currentParagraph.String()) + "&lt;/p&gt;\n")
                                currentParagraph.Reset()
                                inParagraph = false
                        }</span>

                        <span class="cov8" title="1">if inCodeBlock </span><span class="cov8" title="1">{
                                // End code block
                                html.WriteString("  &lt;pre&gt;&lt;code&gt;" + c.escapeXML(codeBlock.String()) + "&lt;/code&gt;&lt;/pre&gt;\n")
                                codeBlock.Reset()
                                inCodeBlock = false
                        }</span> else<span class="cov8" title="1"> {
                                // Start code block
                                inCodeBlock = true
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                // Inside code block
                <span class="cov8" title="1">if inCodeBlock </span><span class="cov8" title="1">{
                        if codeBlock.Len() &gt; 0 </span><span class="cov8" title="1">{
                                codeBlock.WriteString("\n")
                        }</span>
                        <span class="cov8" title="1">codeBlock.WriteString(line)
                        continue</span>
                }

                // Empty line ends paragraph
                <span class="cov8" title="1">if trimmed == "" </span><span class="cov8" title="1">{
                        if inParagraph </span><span class="cov8" title="1">{
                                html.WriteString("  &lt;p&gt;" + c.convertInlineMarkdown(currentParagraph.String()) + "&lt;/p&gt;\n")
                                currentParagraph.Reset()
                                inParagraph = false
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                // Horizontal rule
                <span class="cov8" title="1">if c.hrRegex.MatchString(trimmed) </span><span class="cov8" title="1">{
                        if inParagraph </span><span class="cov0" title="0">{
                                html.WriteString("  &lt;p&gt;" + c.convertInlineMarkdown(currentParagraph.String()) + "&lt;/p&gt;\n")
                                currentParagraph.Reset()
                                inParagraph = false
                        }</span>
                        <span class="cov8" title="1">html.WriteString("  &lt;hr/&gt;\n")
                        continue</span>
                }

                // Headers (h1 through h6)
                <span class="cov8" title="1">if strings.HasPrefix(trimmed, "######") </span><span class="cov8" title="1">{
                        if inParagraph </span><span class="cov0" title="0">{
                                html.WriteString("  &lt;p&gt;" + c.convertInlineMarkdown(currentParagraph.String()) + "&lt;/p&gt;\n")
                                currentParagraph.Reset()
                                inParagraph = false
                        }</span>
                        <span class="cov8" title="1">text := strings.TrimSpace(strings.TrimPrefix(trimmed, "######"))
                        html.WriteString(fmt.Sprintf("  &lt;h6&gt;%s&lt;/h6&gt;\n", c.escapeXML(text)))
                        continue</span>
                } else<span class="cov8" title="1"> if strings.HasPrefix(trimmed, "#####") </span><span class="cov8" title="1">{
                        if inParagraph </span><span class="cov0" title="0">{
                                html.WriteString("  &lt;p&gt;" + c.convertInlineMarkdown(currentParagraph.String()) + "&lt;/p&gt;\n")
                                currentParagraph.Reset()
                                inParagraph = false
                        }</span>
                        <span class="cov8" title="1">text := strings.TrimSpace(strings.TrimPrefix(trimmed, "#####"))
                        html.WriteString(fmt.Sprintf("  &lt;h5&gt;%s&lt;/h5&gt;\n", c.escapeXML(text)))
                        continue</span>
                } else<span class="cov8" title="1"> if strings.HasPrefix(trimmed, "####") </span><span class="cov8" title="1">{
                        if inParagraph </span><span class="cov0" title="0">{
                                html.WriteString("  &lt;p&gt;" + c.convertInlineMarkdown(currentParagraph.String()) + "&lt;/p&gt;\n")
                                currentParagraph.Reset()
                                inParagraph = false
                        }</span>
                        <span class="cov8" title="1">text := strings.TrimSpace(strings.TrimPrefix(trimmed, "####"))
                        html.WriteString(fmt.Sprintf("  &lt;h4&gt;%s&lt;/h4&gt;\n", c.escapeXML(text)))
                        continue</span>
                } else<span class="cov8" title="1"> if strings.HasPrefix(trimmed, "###") </span><span class="cov8" title="1">{
                        if inParagraph </span><span class="cov0" title="0">{
                                html.WriteString("  &lt;p&gt;" + c.convertInlineMarkdown(currentParagraph.String()) + "&lt;/p&gt;\n")
                                currentParagraph.Reset()
                                inParagraph = false
                        }</span>
                        <span class="cov8" title="1">text := strings.TrimSpace(strings.TrimPrefix(trimmed, "###"))
                        html.WriteString(fmt.Sprintf("  &lt;h3&gt;%s&lt;/h3&gt;\n", c.escapeXML(text)))
                        continue</span>
                } else<span class="cov8" title="1"> if strings.HasPrefix(trimmed, "##") </span><span class="cov8" title="1">{
                        if inParagraph </span><span class="cov0" title="0">{
                                html.WriteString("  &lt;p&gt;" + c.convertInlineMarkdown(currentParagraph.String()) + "&lt;/p&gt;\n")
                                currentParagraph.Reset()
                                inParagraph = false
                        }</span>
                        <span class="cov8" title="1">text := strings.TrimSpace(strings.TrimPrefix(trimmed, "##"))
                        html.WriteString(fmt.Sprintf("  &lt;h2&gt;%s&lt;/h2&gt;\n", c.escapeXML(text)))
                        continue</span>
                } else<span class="cov8" title="1"> if strings.HasPrefix(trimmed, "#") &amp;&amp; len(trimmed) &gt; 1 &amp;&amp; trimmed[1] == ' ' </span><span class="cov8" title="1">{
                        if inParagraph </span><span class="cov0" title="0">{
                                html.WriteString("  &lt;p&gt;" + c.convertInlineMarkdown(currentParagraph.String()) + "&lt;/p&gt;\n")
                                currentParagraph.Reset()
                                inParagraph = false
                        }</span>
                        <span class="cov8" title="1">text := strings.TrimSpace(strings.TrimPrefix(trimmed, "#"))
                        html.WriteString(fmt.Sprintf("  &lt;h1&gt;%s&lt;/h1&gt;\n", c.escapeXML(text)))
                        continue</span>
                }

                // Regular paragraph content
                <span class="cov8" title="1">if !inParagraph </span><span class="cov8" title="1">{
                        inParagraph = true
                }</span> else<span class="cov8" title="1"> {
                        currentParagraph.WriteString(" ")
                }</span>
                <span class="cov8" title="1">currentParagraph.WriteString(trimmed)</span>
        }

        // Close last paragraph
        <span class="cov8" title="1">if inParagraph </span><span class="cov8" title="1">{
                html.WriteString("  &lt;p&gt;" + c.convertInlineMarkdown(currentParagraph.String()) + "&lt;/p&gt;\n")
        }</span>

        // Close unclosed code block
        <span class="cov8" title="1">if inCodeBlock </span><span class="cov0" title="0">{
                html.WriteString("  &lt;pre&gt;&lt;code&gt;" + c.escapeXML(codeBlock.String()) + "&lt;/code&gt;&lt;/pre&gt;\n")
        }</span>

        <span class="cov8" title="1">return html.String()</span>
}

// convertInlineMarkdown converts inline markdown formatting to HTML
func (c *MarkdownToEPUBConverter) convertInlineMarkdown(text string) string <span class="cov8" title="1">{
        // First escape XML special characters in the raw text
        text = c.escapeXML(text)

        // Now convert markdown to HTML (HTML tags won't be escaped)
        // Bold: **text** or __text__ (process first to avoid conflicts)
        text = regexp.MustCompile(`\*\*(.+?)\*\*`).ReplaceAllString(text, "&lt;strong&gt;$1&lt;/strong&gt;")
        text = regexp.MustCompile(`__(.+?)__`).ReplaceAllString(text, "&lt;strong&gt;$1&lt;/strong&gt;")

        // Italic: *text* or _text_ (single stars/underscores only)
        // Process after bold to avoid matching ** or __
        text = regexp.MustCompile(`\*([^*]+?)\*`).ReplaceAllString(text, "&lt;em&gt;$1&lt;/em&gt;")
        text = regexp.MustCompile(`_([^_]+?)_`).ReplaceAllString(text, "&lt;em&gt;$1&lt;/em&gt;")

        // Code: `text`
        text = regexp.MustCompile("`([^`]+)`").ReplaceAllString(text, "&lt;code&gt;$1&lt;/code&gt;")

        return text
}</span>

// escapeXML escapes special XML characters
func (c *MarkdownToEPUBConverter) escapeXML(s string) string <span class="cov8" title="1">{
        s = strings.ReplaceAll(s, "&amp;", "&amp;amp;")
        s = strings.ReplaceAll(s, "&lt;", "&amp;lt;")
        s = strings.ReplaceAll(s, "&gt;", "&amp;gt;")
        s = strings.ReplaceAll(s, "\"", "&amp;quot;")
        s = strings.ReplaceAll(s, "'", "&amp;apos;")
        return s
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package markdown

import (
        "bufio"
        "fmt"
        "os"
        "regexp"
        "strings"
)

// MarkdownTranslator translates markdown content while preserving formatting
type MarkdownTranslator struct {
        translateFunc func(text string) (string, error)
}

// NewMarkdownTranslator creates a new markdown translator
func NewMarkdownTranslator(translateFunc func(string) (string, error)) *MarkdownTranslator <span class="cov8" title="1">{
        return &amp;MarkdownTranslator{
                translateFunc: translateFunc,
        }
}</span>

// TranslateMarkdownFile translates a markdown file
func (mt *MarkdownTranslator) TranslateMarkdownFile(inputPath, outputPath string) error <span class="cov8" title="1">{
        // Read input file
        content, err := os.ReadFile(inputPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read input file: %w", err)
        }</span>

        // Translate content
        <span class="cov8" title="1">translated, err := mt.TranslateMarkdown(string(content))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("translation failed: %w", err)
        }</span>

        // Write output file
        <span class="cov8" title="1">if err := os.WriteFile(outputPath, []byte(translated), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write output file: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// TranslateMarkdown translates markdown content while preserving formatting
func (mt *MarkdownTranslator) TranslateMarkdown(content string) (string, error) <span class="cov8" title="1">{
        var result strings.Builder
        scanner := bufio.NewScanner(strings.NewReader(content))

        inFrontmatter := false
        inCodeBlock := false
        frontmatterCount := 0

        for scanner.Scan() </span><span class="cov8" title="1">{
                line := scanner.Text()

                // Handle frontmatter (YAML between ---)
                if line == "---" </span><span class="cov8" title="1">{
                        frontmatterCount++
                        result.WriteString(line + "\n")
                        if frontmatterCount == 1 </span><span class="cov8" title="1">{
                                inFrontmatter = true
                        }</span> else<span class="cov8" title="1"> if frontmatterCount == 2 </span><span class="cov8" title="1">{
                                inFrontmatter = false
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                // Handle code blocks
                <span class="cov8" title="1">if strings.HasPrefix(line, "```") </span><span class="cov8" title="1">{
                        inCodeBlock = !inCodeBlock
                        result.WriteString(line + "\n")
                        continue</span>
                }

                // Don't translate frontmatter or code blocks
                <span class="cov8" title="1">if inFrontmatter || inCodeBlock </span><span class="cov8" title="1">{
                        result.WriteString(line + "\n")
                        continue</span>
                }

                // Translate the line while preserving markdown syntax
                <span class="cov8" title="1">translated, err := mt.translateLine(line)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to translate line: %w", err)
                }</span>

                <span class="cov8" title="1">result.WriteString(translated + "\n")</span>
        }

        <span class="cov8" title="1">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error reading content: %w", err)
        }</span>

        <span class="cov8" title="1">return result.String(), nil</span>
}

// translateLine translates a single line while preserving markdown formatting
func (mt *MarkdownTranslator) translateLine(line string) (string, error) <span class="cov8" title="1">{
        // Empty lines
        if strings.TrimSpace(line) == "" </span><span class="cov8" title="1">{
                return line, nil
        }</span>

        // Headers
        <span class="cov8" title="1">if strings.HasPrefix(line, "#") </span><span class="cov8" title="1">{
                return mt.translateHeader(line)
        }</span>

        // Horizontal rules
        <span class="cov8" title="1">if matched, _ := regexp.MatchString(`^[-*_]{3,}$`, strings.TrimSpace(line)); matched </span><span class="cov0" title="0">{
                return line, nil
        }</span>

        // Lists
        <span class="cov8" title="1">if matched, _ := regexp.MatchString(`^\s*[-*+]\s`, line); matched </span><span class="cov8" title="1">{
                return mt.translateList(line)
        }</span>

        // Numbered lists
        <span class="cov8" title="1">if matched, _ := regexp.MatchString(`^\s*\d+\.\s`, line); matched </span><span class="cov0" title="0">{
                return mt.translateNumberedList(line)
        }</span>

        // Blockquotes
        <span class="cov8" title="1">if strings.HasPrefix(strings.TrimSpace(line), "&gt;") </span><span class="cov8" title="1">{
                return mt.translateBlockquote(line)
        }</span>

        // Image references (don't translate alt text for now, keep original)
        <span class="cov8" title="1">if matched, _ := regexp.MatchString(`!\[.*?\]\(.*?\)`, line); matched </span><span class="cov0" title="0">{
                return line, nil
        }</span>

        // Regular paragraph with inline formatting
        <span class="cov8" title="1">return mt.translateInlineFormatting(line)</span>
}

// translateHeader translates a header line
func (mt *MarkdownTranslator) translateHeader(line string) (string, error) <span class="cov8" title="1">{
        // Extract header level and text
        match := regexp.MustCompile(`^(#{1,6})\s+(.+)$`).FindStringSubmatch(line)
        if len(match) != 3 </span><span class="cov0" title="0">{
                return line, nil
        }</span>

        <span class="cov8" title="1">headerLevel := match[1]
        headerText := match[2]

        // Translate header text (preserve inline formatting)
        translated, err := mt.translateInlineFormatting(headerText)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return headerLevel + " " + translated, nil</span>
}

// translateList translates a list item
func (mt *MarkdownTranslator) translateList(line string) (string, error) <span class="cov8" title="1">{
        // Extract indentation, bullet, and text
        match := regexp.MustCompile(`^(\s*)([-*+])\s+(.+)$`).FindStringSubmatch(line)
        if len(match) != 4 </span><span class="cov0" title="0">{
                return line, nil
        }</span>

        <span class="cov8" title="1">indent := match[1]
        bullet := match[2]
        text := match[3]

        // Translate text
        translated, err := mt.translateInlineFormatting(text)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return indent + bullet + " " + translated, nil</span>
}

// translateNumberedList translates a numbered list item
func (mt *MarkdownTranslator) translateNumberedList(line string) (string, error) <span class="cov0" title="0">{
        // Extract indentation, number, and text
        match := regexp.MustCompile(`^(\s*)(\d+)\.\s+(.+)$`).FindStringSubmatch(line)
        if len(match) != 4 </span><span class="cov0" title="0">{
                return line, nil
        }</span>

        <span class="cov0" title="0">indent := match[1]
        number := match[2]
        text := match[3]

        // Translate text
        translated, err := mt.translateInlineFormatting(text)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return indent + number + ". " + translated, nil</span>
}

// translateBlockquote translates a blockquote
func (mt *MarkdownTranslator) translateBlockquote(line string) (string, error) <span class="cov8" title="1">{
        // Extract quote marker and text
        match := regexp.MustCompile(`^(\s*&gt;+)\s*(.*)$`).FindStringSubmatch(line)
        if len(match) != 3 </span><span class="cov0" title="0">{
                return line, nil
        }</span>

        <span class="cov8" title="1">quoteMarker := match[1]
        text := match[2]

        if text == "" </span><span class="cov0" title="0">{
                return line, nil
        }</span>

        // Translate text
        <span class="cov8" title="1">translated, err := mt.translateInlineFormatting(text)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return quoteMarker + " " + translated, nil</span>
}

// translateInlineFormatting translates text while preserving inline markdown formatting
func (mt *MarkdownTranslator) translateInlineFormatting(text string) (string, error) <span class="cov8" title="1">{
        // Pattern to match markdown inline formatting
        // Matches: **bold**, *italic*, `code`, [link](url), etc.
        pattern := regexp.MustCompile(`(\*\*.*?\*\*|\*.*?\*|__.*?__|_.*?_|` + "`" + `.*?` + "`" + `|\[.*?\]\(.*?\))`)

        // Find all formatted segments
        segments := pattern.FindAllStringIndex(text, -1)

        if len(segments) == 0 </span><span class="cov8" title="1">{
                // No formatting, translate entire text
                return mt.translateText(text)
        }</span>

        // Build result preserving formatting
        <span class="cov8" title="1">var result strings.Builder
        lastEnd := 0

        for _, seg := range segments </span><span class="cov8" title="1">{
                start, end := seg[0], seg[1]

                // Translate text before formatted segment
                if start &gt; lastEnd </span><span class="cov8" title="1">{
                        plainText := text[lastEnd:start]
                        if strings.TrimSpace(plainText) != "" </span><span class="cov8" title="1">{
                                translated, err := mt.translateText(plainText)
                                if err != nil </span><span class="cov0" title="0">{
                                        return "", err
                                }</span>
                                <span class="cov8" title="1">result.WriteString(translated)</span>
                        }
                }

                // Handle formatted segment
                <span class="cov8" title="1">formatted := text[start:end]
                translatedFormatted, err := mt.translateFormattedSegment(formatted)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">result.WriteString(translatedFormatted)

                lastEnd = end</span>
        }

        // Translate remaining text
        <span class="cov8" title="1">if lastEnd &lt; len(text) </span><span class="cov8" title="1">{
                plainText := text[lastEnd:]
                if strings.TrimSpace(plainText) != "" </span><span class="cov8" title="1">{
                        translated, err := mt.translateText(plainText)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov8" title="1">result.WriteString(translated)</span>
                }
        }

        <span class="cov8" title="1">return result.String(), nil</span>
}

// translateFormattedSegment translates a formatted markdown segment
func (mt *MarkdownTranslator) translateFormattedSegment(segment string) (string, error) <span class="cov8" title="1">{
        // Bold: **text** or __text__
        if strings.HasPrefix(segment, "**") &amp;&amp; strings.HasSuffix(segment, "**") </span><span class="cov8" title="1">{
                inner := segment[2 : len(segment)-2]
                translated, err := mt.translateText(inner)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">return "**" + translated + "**", nil</span>
        }

        <span class="cov8" title="1">if strings.HasPrefix(segment, "__") &amp;&amp; strings.HasSuffix(segment, "__") </span><span class="cov0" title="0">{
                inner := segment[2 : len(segment)-2]
                translated, err := mt.translateText(inner)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">return "__" + translated + "__", nil</span>
        }

        // Italic: *text* or _text_
        <span class="cov8" title="1">if strings.HasPrefix(segment, "*") &amp;&amp; strings.HasSuffix(segment, "*") &amp;&amp; !strings.HasPrefix(segment, "**") </span><span class="cov8" title="1">{
                inner := segment[1 : len(segment)-1]
                translated, err := mt.translateText(inner)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">return "*" + translated + "*", nil</span>
        }

        <span class="cov8" title="1">if strings.HasPrefix(segment, "_") &amp;&amp; strings.HasSuffix(segment, "_") &amp;&amp; !strings.HasPrefix(segment, "__") </span><span class="cov0" title="0">{
                inner := segment[1 : len(segment)-1]
                translated, err := mt.translateText(inner)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">return "_" + translated + "_", nil</span>
        }

        // Code: `text`
        <span class="cov8" title="1">if strings.HasPrefix(segment, "`") &amp;&amp; strings.HasSuffix(segment, "`") </span><span class="cov8" title="1">{
                // Don't translate code
                return segment, nil
        }</span>

        // Links: [text](url)
        <span class="cov8" title="1">linkPattern := regexp.MustCompile(`^\[(.*?)\]\((.*?)\)$`)
        if match := linkPattern.FindStringSubmatch(segment); len(match) == 3 </span><span class="cov8" title="1">{
                linkText := match[1]
                linkURL := match[2]

                // Translate link text only
                translated, err := mt.translateText(linkText)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">return "[" + translated + "](" + linkURL + ")", nil</span>
        }

        // Unknown format, translate as-is
        <span class="cov0" title="0">return mt.translateText(segment)</span>
}

// translateText translates plain text using the provided translation function
func (mt *MarkdownTranslator) translateText(text string) (string, error) <span class="cov8" title="1">{
        text = strings.TrimSpace(text)
        if text == "" </span><span class="cov0" title="0">{
                return text, nil
        }</span>

        <span class="cov8" title="1">translated, err := mt.translateFunc(text)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("translation error: %w", err)
        }</span>

        <span class="cov8" title="1">return translated, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package models

import (
        "crypto/sha256"
        "fmt"
        "io"
        "net/http"
        "os"
        "path/filepath"
        "strings"
        "time"
)

// Downloader manages model downloads and caching
type Downloader struct {
        cacheDir string
        client   *http.Client
}

// NewDownloader creates a new model downloader
func NewDownloader() *Downloader <span class="cov8" title="1">{
        homeDir, _ := os.UserHomeDir()
        cacheDir := filepath.Join(homeDir, ".cache", "translator", "models")
        _ = os.MkdirAll(cacheDir, 0755)

        return &amp;Downloader{
                cacheDir: cacheDir,
                client: &amp;http.Client{
                        Timeout: 30 * time.Minute, // Long timeout for large model downloads
                },
        }
}</span>

// GetModelPath returns the path to a model if it exists, or error if not downloaded
func (d *Downloader) GetModelPath(model *ModelInfo) (string, error) <span class="cov8" title="1">{
        modelPath := d.getLocalPath(model)

        // Check if model file exists and is valid
        if stat, err := os.Stat(modelPath); err == nil </span><span class="cov8" title="1">{
                // File exists, verify it's not corrupted (basic size check)
                if stat.Size() &gt; 1024*1024 </span><span class="cov8" title="1">{ // At least 1MB
                        return modelPath, nil
                }</span>
                // File too small, likely corrupted
                <span class="cov8" title="1">os.Remove(modelPath)</span>
        }

        <span class="cov8" title="1">return "", fmt.Errorf("model not downloaded: %s", model.ID)</span>
}

// DownloadModel downloads a model if not already cached
func (d *Downloader) DownloadModel(model *ModelInfo) (string, error) <span class="cov8" title="1">{
        modelPath := d.getLocalPath(model)

        // Check if already downloaded
        if _, err := os.Stat(modelPath); err == nil </span><span class="cov0" title="0">{
                fmt.Printf("[DOWNLOADER] Model already exists: %s\n", modelPath)
                return modelPath, nil
        }</span>

        // Download model
        <span class="cov8" title="1">fmt.Printf("[DOWNLOADER] Downloading %s from %s\n", model.Name, model.SourceURL)
        fmt.Printf("[DOWNLOADER] This may take several minutes...\n")

        // Create temporary file
        tmpPath := modelPath + ".tmp"
        defer os.Remove(tmpPath) // Clean up on error

        // Download with progress
        err := d.downloadWithProgress(model.SourceURL, tmpPath)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("download failed: %w", err)
        }</span>

        // Verify downloaded file (basic checks)
        <span class="cov8" title="1">stat, err := os.Stat(tmpPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to stat downloaded file: %w", err)
        }</span>

        // Check file size is reasonable (at least 100MB for any LLM)
        <span class="cov8" title="1">if stat.Size() &lt; 100*1024*1024 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("downloaded file too small: %d bytes (expected &gt; 100MB)", stat.Size())
        }</span>

        <span class="cov8" title="1">fmt.Printf("[DOWNLOADER] Download complete: %.1f GB\n", float64(stat.Size())/(1024*1024*1024))

        // Move to final location
        err = os.Rename(tmpPath, modelPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to move downloaded file: %w", err)
        }</span>

        <span class="cov8" title="1">fmt.Printf("[DOWNLOADER] Model ready: %s\n", modelPath)

        return modelPath, nil</span>
}

// downloadWithProgress downloads a file and shows progress
func (d *Downloader) downloadWithProgress(url, destPath string) error <span class="cov8" title="1">{
        // Create output file
        out, err := os.Create(destPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer out.Close()

        // Create request with Hugging Face authentication if available
        req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Add Hugging Face token if available
        // Check both HF_TOKEN and HUGGINGFACE_TOKEN environment variables
        <span class="cov8" title="1">hfToken := os.Getenv("HF_TOKEN")
        if hfToken == "" </span><span class="cov8" title="1">{
                hfToken = os.Getenv("HUGGINGFACE_TOKEN")
        }</span>
        <span class="cov8" title="1">if hfToken != "" &amp;&amp; strings.Contains(url, "huggingface.co") </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", "Bearer "+hfToken)
                fmt.Printf("[DOWNLOADER] Using Hugging Face authentication\n")
        }</span>

        // Get the data
        <span class="cov8" title="1">resp, err := d.client.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        // Check response status
        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                // Provide helpful error message for authentication failures
                if resp.StatusCode == http.StatusUnauthorized &amp;&amp; strings.Contains(url, "huggingface.co") </span><span class="cov0" title="0">{
                        return fmt.Errorf("bad status: %s - Hugging Face token required. Set HF_TOKEN environment variable with your token from https://huggingface.co/settings/tokens", resp.Status)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("bad status: %s", resp.Status)</span>
        }

        // Get content length for progress reporting
        <span class="cov8" title="1">size := resp.ContentLength

        // Create progress writer
        writer := &amp;progressWriter{
                writer:    out,
                total:     size,
                lastPrint: time.Now(),
                startTime: time.Now(),
        }

        // Copy with progress
        _, err = io.Copy(writer, resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Final progress update
        <span class="cov8" title="1">writer.printProgress(true)
        fmt.Println() // New line after progress

        return nil</span>
}

// progressWriter wraps a writer to show download progress
type progressWriter struct {
        writer     io.Writer
        total      int64
        downloaded int64
        lastPrint  time.Time
        startTime  time.Time
}

func (pw *progressWriter) Write(p []byte) (int, error) <span class="cov8" title="1">{
        n, err := pw.writer.Write(p)
        if err != nil </span><span class="cov0" title="0">{
                return n, err
        }</span>

        <span class="cov8" title="1">pw.downloaded += int64(n)

        // Print progress every second
        if time.Since(pw.lastPrint) &gt;= time.Second </span><span class="cov0" title="0">{
                pw.printProgress(false)
                pw.lastPrint = time.Now()
        }</span>

        <span class="cov8" title="1">return n, nil</span>
}

func (pw *progressWriter) printProgress(final bool) <span class="cov8" title="1">{
        if pw.total &lt;= 0 </span><span class="cov0" title="0">{
                // Unknown size, just show downloaded amount
                fmt.Printf("\r[DOWNLOADER] Downloaded: %.1f MB", float64(pw.downloaded)/(1024*1024))
                return
        }</span>

        // Calculate percentage and speed
        <span class="cov8" title="1">percent := float64(pw.downloaded) / float64(pw.total) * 100
        elapsed := time.Since(pw.startTime).Seconds()
        speed := float64(pw.downloaded) / elapsed / (1024 * 1024) // MB/s

        // Estimate time remaining
        if speed &gt; 0 </span><span class="cov8" title="1">{
                remaining := float64(pw.total-pw.downloaded) / (speed * 1024 * 1024)
                remainingMin := int(remaining / 60)
                remainingSec := int(remaining) % 60

                if final </span><span class="cov8" title="1">{
                        fmt.Printf("\r[DOWNLOADER] Complete: %.1f GB downloaded in %.0fs (%.1f MB/s)",
                                float64(pw.total)/(1024*1024*1024), elapsed, speed)
                }</span> else<span class="cov8" title="1"> {
                        fmt.Printf("\r[DOWNLOADER] Progress: %.1f%% (%.1f MB/s, ~%dm%ds remaining)",
                                percent, speed, remainingMin, remainingSec)
                }</span>
        } else<span class="cov0" title="0"> {
                fmt.Printf("\r[DOWNLOADER] Progress: %.1f%%", percent)
        }</span>
}

// getLocalPath returns the local filesystem path for a model
func (d *Downloader) getLocalPath(model *ModelInfo) string <span class="cov8" title="1">{
        // Use .gguf extension for GGUF models
        filename := model.ID + ".gguf"
        return filepath.Join(d.cacheDir, filename)
}</span>

// ListDownloadedModels returns a list of all downloaded models
func (d *Downloader) ListDownloadedModels() ([]string, error) <span class="cov8" title="1">{
        files, err := os.ReadDir(d.cacheDir)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return []string{}, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">var models []string
        for _, file := range files </span><span class="cov8" title="1">{
                if !file.IsDir() &amp;&amp; strings.HasSuffix(file.Name(), ".gguf") </span><span class="cov8" title="1">{
                        // Remove .gguf extension to get model ID
                        modelID := strings.TrimSuffix(file.Name(), ".gguf")
                        models = append(models, modelID)
                }</span>
        }

        <span class="cov8" title="1">return models, nil</span>
}

// DeleteModel removes a downloaded model from cache
func (d *Downloader) DeleteModel(modelID string) error <span class="cov8" title="1">{
        modelPath := filepath.Join(d.cacheDir, modelID+".gguf")

        err := os.Remove(modelPath)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return fmt.Errorf("model not found: %s", modelID)
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov8" title="1">fmt.Printf("[DOWNLOADER] Deleted model: %s\n", modelID)
        return nil</span>
}

// GetCacheSize returns the total size of downloaded models in bytes
func (d *Downloader) GetCacheSize() (int64, error) <span class="cov8" title="1">{
        var totalSize int64

        files, err := os.ReadDir(d.cacheDir)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return 0, nil
                }</span>
                <span class="cov0" title="0">return 0, err</span>
        }

        <span class="cov8" title="1">for _, file := range files </span><span class="cov8" title="1">{
                if !file.IsDir() &amp;&amp; strings.HasSuffix(file.Name(), ".gguf") </span><span class="cov8" title="1">{
                        info, err := file.Info()
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">totalSize += info.Size()</span>
                }
        }

        <span class="cov8" title="1">return totalSize, nil</span>
}

// CleanCache removes all downloaded models
func (d *Downloader) CleanCache() error <span class="cov8" title="1">{
        files, err := os.ReadDir(d.cacheDir)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov8" title="1">var errors []string
        for _, file := range files </span><span class="cov8" title="1">{
                if !file.IsDir() &amp;&amp; strings.HasSuffix(file.Name(), ".gguf") </span><span class="cov8" title="1">{
                        filePath := filepath.Join(d.cacheDir, file.Name())
                        if err := os.Remove(filePath); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, fmt.Sprintf("failed to delete %s: %v", file.Name(), err))
                        }</span>
                }
        }

        <span class="cov8" title="1">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("errors during cache cleaning: %s", strings.Join(errors, "; "))
        }</span>

        <span class="cov8" title="1">fmt.Println("[DOWNLOADER] Cache cleaned")
        return nil</span>
}

// VerifyModel verifies the integrity of a downloaded model
func (d *Downloader) VerifyModel(modelID string) error <span class="cov8" title="1">{
        modelPath := filepath.Join(d.cacheDir, modelID+".gguf")

        // Check if file exists
        stat, err := os.Stat(modelPath)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("model file not found: %w", err)
        }</span>

        // Check file size is reasonable
        <span class="cov8" title="1">if stat.Size() &lt; 100*1024*1024 </span><span class="cov8" title="1">{
                return fmt.Errorf("model file too small: %d bytes (possibly corrupted)", stat.Size())
        }</span>

        // Read first few bytes to verify it's a GGUF file
        <span class="cov8" title="1">file, err := os.Open(modelPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open model file: %w", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // GGUF files start with "GGUF" magic number
        magic := make([]byte, 4)
        n, err := file.Read(magic)
        if err != nil || n != 4 </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read model header: %w", err)
        }</span>

        <span class="cov8" title="1">if string(magic) != "GGUF" </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid model file: not a GGUF file")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ComputeChecksum computes SHA256 checksum of a model file
func (d *Downloader) ComputeChecksum(modelID string) (string, error) <span class="cov8" title="1">{
        modelPath := filepath.Join(d.cacheDir, modelID+".gguf")

        file, err := os.Open(modelPath)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        hash := sha256.New()
        if _, err := io.Copy(hash, file); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("%x", hash.Sum(nil)), nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package models

import (
        "fmt"
        "strings"
)

// ModelInfo contains metadata about an LLM model
type ModelInfo struct {
        ID             string   // Unique identifier (e.g., "hunyuan-mt-7b")
        Name           string   // Human-readable name
        Description    string   // Description of model capabilities
        Parameters     uint64   // Number of parameters (e.g., 7_000_000_000 for 7B)
        MinRAM         uint64   // Minimum RAM in bytes (for Q4 quantization)
        RecommendedRAM uint64   // Recommended RAM in bytes (for Q8 quantization)
        QuantType      string   // Quantization type (Q4, Q8, F16, etc.)
        SourceURL      string   // HuggingFace or other source URL
        Languages      []string // Supported languages
        OptimizedFor   string   // What this model is optimized for
        Quality        string   // Quality rating: excellent, good, moderate
        LicenseType    string   // License (Apache-2.0, MIT, etc.)
        RequiresGPU    bool     // Whether GPU is required
        ContextLength  int      // Maximum context length in tokens
}

// ModelRegistry manages available translation models
type ModelRegistry struct {
        models map[string]*ModelInfo
}

// NewRegistry creates a new model registry with pre-configured translation models
func NewRegistry() *ModelRegistry <span class="cov8" title="1">{
        registry := &amp;ModelRegistry{
                models: make(map[string]*ModelInfo),
        }

        registry.registerDefaultModels()
        return registry
}</span>

// registerDefaultModels adds translation-optimized models to the registry
func (r *ModelRegistry) registerDefaultModels() <span class="cov8" title="1">{
        // PRIORITY 1: Translation-Specialized Models

        // Hunyuan-MT-7B: Best 7B translation model (using bartowski GGUF)
        r.Register(&amp;ModelInfo{
                ID:             "hunyuan-mt-7b-q4",
                Name:           "Hunyuan-MT 7B (Q4)",
                Description:    "Translation-optimized 7B model with commercial-grade quality for 33 languages",
                Parameters:     7_000_000_000,
                MinRAM:         6 * 1024 * 1024 * 1024, // 6GB
                RecommendedRAM: 8 * 1024 * 1024 * 1024, // 8GB
                QuantType:      "Q4_K_M",
                SourceURL:      "https://huggingface.co/bartowski/Hunyuan-MT-7B-GGUF/resolve/main/Hunyuan-MT-7B-Q4_K_M.gguf",
                Languages:      []string{"en", "ru", "sr", "zh", "es", "fr", "de", "ja", "ko"},
                OptimizedFor:   "Professional Translation",
                Quality:        "excellent",
                LicenseType:    "Apache-2.0",
                RequiresGPU:    false,
                ContextLength:  8192,
        })

        r.Register(&amp;ModelInfo{
                ID:             "hunyuan-mt-7b-q8",
                Name:           "Hunyuan-MT 7B (Q8)",
                Description:    "High-quality translation with Q8 quantization for better accuracy",
                Parameters:     7_000_000_000,
                MinRAM:         9 * 1024 * 1024 * 1024,  // 9GB
                RecommendedRAM: 12 * 1024 * 1024 * 1024, // 12GB
                QuantType:      "Q8_0",
                SourceURL:      "https://huggingface.co/bartowski/Hunyuan-MT-7B-GGUF/resolve/main/Hunyuan-MT-7B-Q8_0.gguf",
                Languages:      []string{"en", "ru", "sr", "zh", "es", "fr", "de", "ja", "ko"},
                OptimizedFor:   "Professional Translation",
                Quality:        "excellent",
                LicenseType:    "Apache-2.0",
                RequiresGPU:    false,
                ContextLength:  8192,
        })

        // Aya-23: Multilingual translation model
        r.Register(&amp;ModelInfo{
                ID:             "aya-23-8b-q4",
                Name:           "Aya 23 8B (Q4)",
                Description:    "Multilingual model supporting 23 languages with strong translation",
                Parameters:     8_000_000_000,
                MinRAM:         7 * 1024 * 1024 * 1024,  // 7GB
                RecommendedRAM: 10 * 1024 * 1024 * 1024, // 10GB
                QuantType:      "Q4_K_M",
                SourceURL:      "https://huggingface.co/bartowski/aya-23-8B-GGUF/resolve/main/aya-23-8B-Q4_K_M.gguf",
                Languages:      []string{"en", "ru", "sr", "ar", "zh", "cs", "de", "es", "fr", "hi"},
                OptimizedFor:   "Multilingual Translation",
                Quality:        "excellent",
                LicenseType:    "Apache-2.0",
                RequiresGPU:    false,
                ContextLength:  8192,
        })

        // PRIORITY 2: General-Purpose Models with Strong Translation (NOW PRIORITY 1)

        // Qwen2.5: Excellent for multilingual tasks
        r.Register(&amp;ModelInfo{
                ID:             "qwen2.5-7b-instruct-q4",
                Name:           "Qwen 2.5 7B Instruct (Q4)",
                Description:    "Multilingual model with strong Russian and Serbian support",
                Parameters:     7_000_000_000,
                MinRAM:         6 * 1024 * 1024 * 1024, // 6GB
                RecommendedRAM: 8 * 1024 * 1024 * 1024, // 8GB
                QuantType:      "Q4_K_M",
                SourceURL:      "https://huggingface.co/bartowski/Qwen2.5-7B-Instruct-GGUF/resolve/main/Qwen2.5-7B-Instruct-Q4_K_M.gguf",
                Languages:      []string{"en", "ru", "sr", "zh", "ja", "ko", "de", "es", "fr"},
                OptimizedFor:   "General + Translation",
                Quality:        "excellent",
                LicenseType:    "Apache-2.0",
                RequiresGPU:    false,
                ContextLength:  32768,
        })

        // Mistral: Good general-purpose with translation capability
        r.Register(&amp;ModelInfo{
                ID:             "mistral-7b-instruct-q4",
                Name:           "Mistral 7B Instruct v0.3 (Q4)",
                Description:    "High-quality general-purpose model with good translation",
                Parameters:     7_000_000_000,
                MinRAM:         6 * 1024 * 1024 * 1024, // 6GB
                RecommendedRAM: 8 * 1024 * 1024 * 1024, // 8GB
                QuantType:      "Q4_K_M",
                SourceURL:      "https://huggingface.co/bartowski/Mistral-7B-Instruct-v0.3-GGUF/resolve/main/Mistral-7B-Instruct-v0.3-Q4_K_M.gguf",
                Languages:      []string{"en", "ru", "de", "es", "fr", "it"},
                OptimizedFor:   "General + Translation",
                Quality:        "good",
                LicenseType:    "Apache-2.0",
                RequiresGPU:    false,
                ContextLength:  8192,
        })

        // PRIORITY 3: Larger Models (for high-RAM systems)

        // Qwen2.5 14B: Better quality for systems with 16GB+ RAM
        r.Register(&amp;ModelInfo{
                ID:             "qwen2.5-14b-instruct-q4",
                Name:           "Qwen 2.5 14B Instruct (Q4)",
                Description:    "Larger model for high-quality translation on capable systems",
                Parameters:     14_000_000_000,
                MinRAM:         12 * 1024 * 1024 * 1024, // 12GB
                RecommendedRAM: 16 * 1024 * 1024 * 1024, // 16GB
                QuantType:      "Q4_K_M",
                SourceURL:      "https://huggingface.co/bartowski/Qwen2.5-14B-Instruct-GGUF/resolve/main/Qwen2.5-14B-Instruct-Q4_K_M.gguf",
                Languages:      []string{"en", "ru", "sr", "zh", "ja", "ko", "de", "es", "fr"},
                OptimizedFor:   "High-Quality Translation",
                Quality:        "excellent",
                LicenseType:    "Apache-2.0",
                RequiresGPU:    false,
                ContextLength:  32768,
        })

        // Qwen2.5 27B: Professional-grade for high-end systems
        r.Register(&amp;ModelInfo{
                ID:             "qwen2.5-27b-instruct-q4",
                Name:           "Qwen 2.5 27B Instruct (Q4)",
                Description:    "Professional-grade translation for systems with 32GB+ RAM",
                Parameters:     27_000_000_000,
                MinRAM:         24 * 1024 * 1024 * 1024, // 24GB
                RecommendedRAM: 32 * 1024 * 1024 * 1024, // 32GB
                QuantType:      "Q4_K_M",
                SourceURL:      "https://huggingface.co/bartowski/Qwen2.5-27B-Instruct-GGUF/resolve/main/Qwen2.5-27B-Instruct-Q4_K_M.gguf",
                Languages:      []string{"en", "ru", "sr", "zh", "ja", "ko", "de", "es", "fr"},
                OptimizedFor:   "Professional Translation",
                Quality:        "excellent",
                LicenseType:    "Apache-2.0",
                RequiresGPU:    false,
                ContextLength:  32768,
        })

        // PRIORITY 4: Compact Models (for low-resource systems)

        // Phi-3: Efficient small model
        r.Register(&amp;ModelInfo{
                ID:             "phi-3-mini-4k-q4",
                Name:           "Phi-3 Mini 3.8B (Q4)",
                Description:    "Compact model for resource-constrained systems",
                Parameters:     3_800_000_000,
                MinRAM:         4 * 1024 * 1024 * 1024, // 4GB
                RecommendedRAM: 6 * 1024 * 1024 * 1024, // 6GB
                QuantType:      "Q4_K_M",
                SourceURL:      "https://huggingface.co/bartowski/Phi-3-mini-4k-instruct-GGUF/resolve/main/Phi-3-mini-4k-instruct-Q4_K_M.gguf",
                Languages:      []string{"en", "ru", "de", "es", "fr"},
                OptimizedFor:   "Low-Resource Translation",
                Quality:        "moderate",
                LicenseType:    "MIT",
                RequiresGPU:    false,
                ContextLength:  4096,
        })

        // Gemma 2: Google's efficient model
        r.Register(&amp;ModelInfo{
                ID:             "gemma-2-9b-it-q4",
                Name:           "Gemma 2 9B Instruct (Q4)",
                Description:    "Google's efficient multilingual model",
                Parameters:     9_000_000_000,
                MinRAM:         8 * 1024 * 1024 * 1024,  // 8GB
                RecommendedRAM: 12 * 1024 * 1024 * 1024, // 12GB
                QuantType:      "Q4_K_M",
                SourceURL:      "https://huggingface.co/bartowski/gemma-2-9B-it-GGUF/resolve/main/gemma-2-9b-it-Q4_K_M.gguf",
                Languages:      []string{"en", "ru", "de", "es", "fr", "it", "pt", "zh", "ja", "ko"},
                OptimizedFor:   "Balanced Translation",
                Quality:        "good",
                LicenseType:    "Gemma",
                RequiresGPU:    false,
                ContextLength:  8192,
        })
}</span>

// Register adds a model to the registry
func (r *ModelRegistry) Register(model *ModelInfo) <span class="cov8" title="1">{
        r.models[model.ID] = model
}</span>

// Get retrieves a model by ID
func (r *ModelRegistry) Get(id string) (*ModelInfo, bool) <span class="cov8" title="1">{
        model, exists := r.models[id]
        return model, exists
}</span>

// List returns all registered models
func (r *ModelRegistry) List() []*ModelInfo <span class="cov8" title="1">{
        models := make([]*ModelInfo, 0, len(r.models))
        for _, model := range r.models </span><span class="cov8" title="1">{
                models = append(models, model)
        }</span>
        <span class="cov8" title="1">return models</span>
}

// FindBestModel finds the best model for given constraints
func (r *ModelRegistry) FindBestModel(maxRAM uint64, preferredLangs []string, hasGPU bool) (*ModelInfo, error) <span class="cov8" title="1">{
        var candidates []*ModelInfo

        // Filter models that fit in available RAM and match GPU availability
        // If hasGPU=true: include all models (GPU-optional and GPU-required)
        // If hasGPU=false: exclude models that require GPU
        for _, model := range r.models </span><span class="cov8" title="1">{
                if model.MinRAM &lt;= maxRAM </span><span class="cov8" title="1">{
                        if !model.RequiresGPU || hasGPU </span><span class="cov8" title="1">{
                                candidates = append(candidates, model)
                        }</span>
                }
        }

        <span class="cov8" title="1">if len(candidates) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no models found within RAM constraint of %d GB", maxRAM/(1024*1024*1024))
        }</span>

        // Score each model
        <span class="cov8" title="1">type scoredModel struct {
                model *ModelInfo
                score float64
        }

        var scored []scoredModel

        for _, model := range candidates </span><span class="cov8" title="1">{
                score := r.scoreModel(model, preferredLangs, maxRAM)
                scored = append(scored, scoredModel{model, score})
        }</span>

        // Find highest scoring model
        <span class="cov8" title="1">best := scored[0]
        for _, sm := range scored[1:] </span><span class="cov8" title="1">{
                if sm.score &gt; best.score </span><span class="cov8" title="1">{
                        best = sm
                }</span>
        }

        <span class="cov8" title="1">return best.model, nil</span>
}

// scoreModel calculates a score for a model based on preferences
func (r *ModelRegistry) scoreModel(model *ModelInfo, preferredLangs []string, maxRAM uint64) float64 <span class="cov8" title="1">{
        score := 0.0

        // Quality bonus
        switch model.Quality </span>{
        case "excellent":<span class="cov8" title="1">
                score += 10.0</span>
        case "good":<span class="cov8" title="1">
                score += 7.0</span>
        case "moderate":<span class="cov8" title="1">
                score += 4.0</span>
        }

        // Translation optimization bonus
        <span class="cov8" title="1">optimizedLower := strings.ToLower(model.OptimizedFor)
        if strings.Contains(optimizedLower, "professional translation") || strings.Contains(optimizedLower, "multilingual translation") </span><span class="cov8" title="1">{
                // Specialized translation models get higher bonus
                score += 8.0
        }</span> else<span class="cov8" title="1"> if strings.Contains(optimizedLower, "translation") </span><span class="cov8" title="1">{
                // General models with translation get smaller bonus
                score += 4.0
        }</span>

        // Language support bonus
        <span class="cov8" title="1">langSupport := 0
        for _, lang := range preferredLangs </span><span class="cov8" title="1">{
                for _, supported := range model.Languages </span><span class="cov8" title="1">{
                        if lang == supported </span><span class="cov8" title="1">{
                                langSupport++
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">score += float64(langSupport) * 2.0

        // Size efficiency bonus (prefer models that use RAM efficiently)
        ramUsagePercent := float64(model.RecommendedRAM) / float64(maxRAM)
        if ramUsagePercent &lt;= 0.6 </span><span class="cov8" title="1">{ // Uses 60% or less of available RAM
                score += 3.0
        }</span> else<span class="cov8" title="1"> if ramUsagePercent &lt;= 0.8 </span><span class="cov8" title="1">{
                score += 1.0
        }</span>

        // Parameter size bonus (larger is generally better, up to a point)
        <span class="cov8" title="1">paramB := float64(model.Parameters) / 1_000_000_000
        if paramB &gt;= 7 &amp;&amp; paramB &lt;= 14 </span><span class="cov8" title="1">{
                score += 2.0 // Sweet spot for translation
        }</span> else<span class="cov8" title="1"> if paramB &gt; 14 </span><span class="cov8" title="1">{
                score += 1.0
        }</span>

        // Context length bonus
        <span class="cov8" title="1">if model.ContextLength &gt;= 8192 </span><span class="cov8" title="1">{
                score += 1.0
        }</span>

        <span class="cov8" title="1">return score</span>
}

// FilterByLanguages returns models that support all specified languages
func (r *ModelRegistry) FilterByLanguages(languages []string) []*ModelInfo <span class="cov8" title="1">{
        var filtered []*ModelInfo

        for _, model := range r.models </span><span class="cov8" title="1">{
                supportsAll := true
                for _, reqLang := range languages </span><span class="cov8" title="1">{
                        found := false
                        for _, modelLang := range model.Languages </span><span class="cov8" title="1">{
                                if reqLang == modelLang </span><span class="cov8" title="1">{
                                        found = true
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                                supportsAll = false
                                break</span>
                        }
                }
                <span class="cov8" title="1">if supportsAll </span><span class="cov8" title="1">{
                        filtered = append(filtered, model)
                }</span>
        }

        <span class="cov8" title="1">return filtered</span>
}

// FilterByRAM returns models that fit within the specified RAM limit
func (r *ModelRegistry) FilterByRAM(maxRAM uint64) []*ModelInfo <span class="cov8" title="1">{
        var filtered []*ModelInfo

        for _, model := range r.models </span><span class="cov8" title="1">{
                if model.MinRAM &lt;= maxRAM </span><span class="cov8" title="1">{
                        filtered = append(filtered, model)
                }</span>
        }

        <span class="cov8" title="1">return filtered</span>
}

// GetRecommendationsForHardware returns recommended models for specific hardware
func (r *ModelRegistry) GetRecommendationsForHardware(ramGB float64, hasGPU bool) []*ModelInfo <span class="cov0" title="0">{
        ramBytes := uint64(ramGB * 1024 * 1024 * 1024)

        var recommendations []*ModelInfo

        // Get all models that fit in RAM
        candidates := r.FilterByRAM(ramBytes)

        // Prioritize translation-optimized models
        for _, model := range candidates </span><span class="cov0" title="0">{
                if strings.Contains(strings.ToLower(model.OptimizedFor), "translation") </span><span class="cov0" title="0">{
                        recommendations = append(recommendations, model)
                }</span>
        }

        // Add general-purpose models if we don't have enough recommendations
        <span class="cov0" title="0">if len(recommendations) &lt; 3 </span><span class="cov0" title="0">{
                for _, model := range candidates </span><span class="cov0" title="0">{
                        isAlreadyAdded := false
                        for _, rec := range recommendations </span><span class="cov0" title="0">{
                                if rec.ID == model.ID </span><span class="cov0" title="0">{
                                        isAlreadyAdded = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if !isAlreadyAdded </span><span class="cov0" title="0">{
                                recommendations = append(recommendations, model)
                        }</span>
                }
        }

        <span class="cov0" title="0">return recommendations</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package progress

import (
        "strconv"
        "sync"
        "time"
)

// TranslationProgress tracks detailed translation progress
type TranslationProgress struct {
        // Book information
        BookTitle      string `json:"book_title"`
        TotalChapters  int    `json:"total_chapters"`
        CurrentChapter int    `json:"current_chapter"`
        ChapterTitle   string `json:"chapter_title"`
        CurrentSection int    `json:"current_section"`
        TotalSections  int    `json:"total_sections"`

        // Progress metrics
        PercentComplete float64 `json:"percent_complete"`
        ItemsTotal      int     `json:"items_total"`
        ItemsCompleted  int     `json:"items_completed"`
        ItemsFailed     int     `json:"items_failed"`

        // Time tracking
        StartTime    time.Time `json:"start_time"`
        ElapsedTime  string    `json:"elapsed_time"`
        EstimatedETA string    `json:"estimated_eta"`

        // Translation details
        SourceLanguage string `json:"source_language"`
        TargetLanguage string `json:"target_language"`
        Provider       string `json:"provider"`
        Model          string `json:"model"`

        // Status
        Status      string `json:"status"` // "initializing", "translating", "completed", "error"
        CurrentTask string `json:"current_task"`
        SessionID   string `json:"session_id"`
}

// Tracker manages translation progress
type Tracker struct {
        mu       sync.RWMutex
        progress *TranslationProgress
}

// NewTracker creates a new progress tracker
func NewTracker(sessionID, bookTitle string, totalChapters int, sourceLanguage, targetLanguage, provider, model string) *Tracker <span class="cov8" title="1">{
        return &amp;Tracker{
                progress: &amp;TranslationProgress{
                        SessionID:      sessionID,
                        BookTitle:      bookTitle,
                        TotalChapters:  totalChapters,
                        SourceLanguage: sourceLanguage,
                        TargetLanguage: targetLanguage,
                        Provider:       provider,
                        Model:          model,
                        StartTime:      time.Now(),
                        Status:         "initializing",
                },
        }
}</span>

// UpdateChapter updates the current chapter being translated
func (t *Tracker) UpdateChapter(chapterNum int, chapterTitle string, totalSections int) <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()

        t.progress.CurrentChapter = chapterNum
        t.progress.ChapterTitle = chapterTitle
        t.progress.TotalSections = totalSections
        t.progress.CurrentSection = 0
        t.progress.Status = "translating"
        t.progress.CurrentTask = "Translating chapter " + chapterTitle

        t.updateProgress()
}</span>

// UpdateSection updates the current section being translated
func (t *Tracker) UpdateSection(sectionNum int) <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()

        t.progress.CurrentSection = sectionNum
        t.updateProgress()
}</span>

// IncrementCompleted increments the completed items counter
func (t *Tracker) IncrementCompleted() <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()

        t.progress.ItemsCompleted++
        t.updateProgress()
}</span>

// IncrementFailed increments the failed items counter
func (t *Tracker) IncrementFailed() <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()

        t.progress.ItemsFailed++
        t.updateProgress()
}</span>

// SetTotal sets the total number of items to translate
func (t *Tracker) SetTotal(total int) <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()

        t.progress.ItemsTotal = total
}</span>

// SetStatus updates the status
func (t *Tracker) SetStatus(status, task string) <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()

        t.progress.Status = status
        t.progress.CurrentTask = task
}</span>

// Complete marks the translation as completed
func (t *Tracker) Complete() <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()

        t.progress.Status = "completed"
        t.progress.CurrentTask = "Translation completed"
        t.progress.PercentComplete = 100.0
        t.updateProgress()
}</span>

// Error marks the translation as errored
func (t *Tracker) Error(errorMsg string) <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()

        t.progress.Status = "error"
        t.progress.CurrentTask = "Error: " + errorMsg
}</span>

// GetProgress returns a copy of the current progress
func (t *Tracker) GetProgress() TranslationProgress <span class="cov8" title="1">{
        t.mu.RLock()
        defer t.mu.RUnlock()

        // Update time fields before returning
        elapsed := time.Since(t.progress.StartTime)
        t.progress.ElapsedTime = formatDuration(elapsed)

        if t.progress.ItemsCompleted &gt; 0 &amp;&amp; t.progress.ItemsTotal &gt; 0 </span><span class="cov8" title="1">{
                avgTimePerItem := elapsed / time.Duration(t.progress.ItemsCompleted)
                remainingItems := t.progress.ItemsTotal - t.progress.ItemsCompleted
                estimatedRemaining := avgTimePerItem * time.Duration(remainingItems)
                t.progress.EstimatedETA = formatDuration(estimatedRemaining)
        }</span>

        <span class="cov8" title="1">return *t.progress</span>
}

// updateProgress calculates percentage and updates progress (must be called with lock held)
func (t *Tracker) updateProgress() <span class="cov8" title="1">{
        if t.progress.TotalChapters &gt; 0 </span><span class="cov8" title="1">{
                t.progress.PercentComplete = float64(t.progress.CurrentChapter-1) / float64(t.progress.TotalChapters) * 100.0

                // Add section progress within current chapter
                if t.progress.TotalSections &gt; 0 </span><span class="cov8" title="1">{
                        sectionPercent := float64(t.progress.CurrentSection) / float64(t.progress.TotalSections) / float64(t.progress.TotalChapters) * 100.0
                        t.progress.PercentComplete += sectionPercent
                }</span>

                // Cap at 100%
                <span class="cov8" title="1">if t.progress.PercentComplete &gt; 100.0 </span><span class="cov8" title="1">{
                        t.progress.PercentComplete = 100.0
                }</span>
        }

        // Update elapsed time
        <span class="cov8" title="1">elapsed := time.Since(t.progress.StartTime)
        t.progress.ElapsedTime = formatDuration(elapsed)

        // Calculate ETA
        if t.progress.PercentComplete &gt; 0 &amp;&amp; t.progress.PercentComplete &lt; 100 </span><span class="cov8" title="1">{
                totalEstimated := elapsed / time.Duration(t.progress.PercentComplete) * 100
                remaining := totalEstimated - elapsed
                t.progress.EstimatedETA = formatDuration(remaining)
        }</span> else<span class="cov8" title="1"> if t.progress.PercentComplete &gt;= 100 </span><span class="cov8" title="1">{
                t.progress.EstimatedETA = "Completed"
        }</span> else<span class="cov8" title="1"> {
                t.progress.EstimatedETA = "Calculating..."
        }</span>
}

// formatDuration formats a duration into a human-readable string
func formatDuration(d time.Duration) string <span class="cov8" title="1">{
        if d &lt; 0 </span><span class="cov8" title="1">{
                d = 0
        }</span>

        <span class="cov8" title="1">hours := int(d.Hours())
        minutes := int(d.Minutes()) % 60
        seconds := int(d.Seconds()) % 60

        if hours &gt; 0 </span><span class="cov8" title="1">{
                return formatTime(hours, "hour") + " " + formatTime(minutes, "minute")
        }</span> else<span class="cov8" title="1"> if minutes &gt; 0 </span><span class="cov8" title="1">{
                return formatTime(minutes, "minute") + " " + formatTime(seconds, "second")
        }</span> else<span class="cov8" title="1"> {
                return formatTime(seconds, "second")
        }</span>
}

// formatTime formats a time value with proper singular/plural
func formatTime(value int, unit string) string <span class="cov8" title="1">{
        if value == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">if value == 1 </span><span class="cov8" title="1">{
                return "1 " + unit
        }</span>
        <span class="cov8" title="1">return formatInt(value) + " " + unit + "s"</span>
}

// formatInt formats an integer
func formatInt(n int) string <span class="cov8" title="1">{
        return strconv.Itoa(n)
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package script

import "strings"

// ScriptType represents the script type
type ScriptType string

const (
        Cyrillic ScriptType = "cyrillic"
        Latin    ScriptType = "latin"
)

// Converter handles Serbian Cyrillic/Latin conversion
type Converter struct {
        cyrlToLatn map[rune]string
        latnToCyrl map[string]rune
}

// NewConverter creates a new script converter
func NewConverter() *Converter <span class="cov8" title="1">{
        cyrlToLatn := map[rune]string{
                '–ê': "A", '–ë': "B", '–í': "V", '–ì': "G", '–î': "D", '–Ç': "ƒê", '–ï': "E", '–ñ': "≈Ω", '–ó': "Z",
                '–ò': "I", '–à': "J", '–ö': "K", '–õ': "L", '–â': "Lj", '–ú': "M", '–ù': "N", '–ä': "Nj", '–û': "O",
                '–ü': "P", '–†': "R", '–°': "S", '–¢': "T", '–ã': "ƒÜ", '–£': "U", '–§': "F", '–•': "H", '–¶': "C",
                '–ß': "ƒå", '–è': "D≈æ", '–®': "≈†",
                '–∞': "a", '–±': "b", '–≤': "v", '–≥': "g", '–¥': "d", '—í': "ƒë", '–µ': "e", '–∂': "≈æ", '–∑': "z",
                '–∏': "i", '—ò': "j", '–∫': "k", '–ª': "l", '—ô': "lj", '–º': "m", '–Ω': "n", '—ö': "nj", '–æ': "o",
                '–ø': "p", '—Ä': "r", '—Å': "s", '—Ç': "t", '—õ': "ƒá", '—É': "u", '—Ñ': "f", '—Ö': "h", '—Ü': "c",
                '—á': "ƒç", '—ü': "d≈æ", '—à': "≈°",
        }

        // Build reverse mapping
        latnToCyrl := make(map[string]rune)
        for cyrl, latn := range cyrlToLatn </span><span class="cov8" title="1">{
                latnToCyrl[latn] = cyrl
        }</span>
        // Add uppercase digraphs
        <span class="cov8" title="1">latnToCyrl["LJ"] = '–â'
        latnToCyrl["NJ"] = '–ä'
        latnToCyrl["D≈Ω"] = '–è'

        return &amp;Converter{
                cyrlToLatn: cyrlToLatn,
                latnToCyrl: latnToCyrl,
        }</span>
}

// ToLatin converts Cyrillic Serbian to Latin
func (c *Converter) ToLatin(text string) string <span class="cov8" title="1">{
        var result strings.Builder
        result.Grow(len(text))

        for _, char := range text </span><span class="cov8" title="1">{
                if latin, ok := c.cyrlToLatn[char]; ok </span><span class="cov8" title="1">{
                        result.WriteString(latin)
                }</span> else<span class="cov8" title="1"> {
                        result.WriteRune(char)
                }</span>
        }

        <span class="cov8" title="1">return result.String()</span>
}

// ToCyrillic converts Latin Serbian to Cyrillic
func (c *Converter) ToCyrillic(text string) string <span class="cov8" title="1">{
        // This is more complex due to multi-character Latin equivalents (Lj, Nj, D≈æ)
        // We need to check for multi-character sequences first
        result := strings.Builder{}
        result.Grow(len(text))

        i := 0
        runes := []rune(text)
        for i &lt; len(runes) </span><span class="cov8" title="1">{
                // Try 2-character sequence first
                if i+1 &lt; len(runes) </span><span class="cov8" title="1">{
                        twoChar := string(runes[i : i+2])
                        if cyrl, ok := c.latnToCyrl[twoChar]; ok </span><span class="cov8" title="1">{
                                result.WriteRune(cyrl)
                                i += 2
                                continue</span>
                        }
                }

                // Try single character
                <span class="cov8" title="1">oneChar := string(runes[i])
                if cyrl, ok := c.latnToCyrl[oneChar]; ok </span><span class="cov8" title="1">{
                        result.WriteRune(cyrl)
                }</span> else<span class="cov8" title="1"> {
                        result.WriteRune(runes[i])
                }</span>
                <span class="cov8" title="1">i++</span>
        }

        <span class="cov8" title="1">return result.String()</span>
}

// DetectScript detects the script type of the text
func (c *Converter) DetectScript(text string) ScriptType <span class="cov8" title="1">{
        cyrillicCount := 0
        latinCount := 0

        for _, char := range text </span><span class="cov8" title="1">{
                if _, ok := c.cyrlToLatn[char]; ok </span><span class="cov8" title="1">{
                        cyrillicCount++
                }</span>
                // Simple heuristic for Latin detection
                <span class="cov8" title="1">if (char &gt;= 'a' &amp;&amp; char &lt;= 'z') || (char &gt;= 'A' &amp;&amp; char &lt;= 'Z') </span><span class="cov8" title="1">{
                        latinCount++
                }</span>
        }

        <span class="cov8" title="1">if cyrillicCount &gt; latinCount </span><span class="cov8" title="1">{
                return Cyrillic
        }</span>
        <span class="cov8" title="1">return Latin</span>
}

// Convert automatically converts between scripts
func (c *Converter) Convert(text string, targetScript ScriptType) string <span class="cov8" title="1">{
        currentScript := c.DetectScript(text)

        if currentScript == targetScript </span><span class="cov8" title="1">{
                return text
        }</span>

        <span class="cov8" title="1">if targetScript == Latin </span><span class="cov8" title="1">{
                return c.ToLatin(text)
        }</span>
        <span class="cov8" title="1">return c.ToCyrillic(text)</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package security

import (
        "crypto/rand"
        "encoding/base64"
        "errors"
        "time"

        "github.com/golang-jwt/jwt/v5"
)

// Claims represents JWT claims
type Claims struct {
        UserID   string   `json:"user_id"`
        Username string   `json:"username"`
        Roles    []string `json:"roles"`
        jwt.RegisteredClaims
}

// AuthService handles authentication
type AuthService struct {
        jwtSecret []byte
        tokenTTL  time.Duration
}

// NewAuthService creates a new auth service
func NewAuthService(jwtSecret string, tokenTTL time.Duration) *AuthService <span class="cov8" title="1">{
        return &amp;AuthService{
                jwtSecret: []byte(jwtSecret),
                tokenTTL:  tokenTTL,
        }
}</span>

// GenerateToken generates a JWT token
func (as *AuthService) GenerateToken(userID, username string, roles []string) (string, error) <span class="cov8" title="1">{
        claims := Claims{
                UserID:   userID,
                Username: username,
                Roles:    roles,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(as.tokenTTL)),
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                        NotBefore: jwt.NewNumericDate(time.Now()),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString(as.jwtSecret)
}</span>

// ValidateToken validates a JWT token
func (as *AuthService) ValidateToken(tokenString string) (*Claims, error) <span class="cov8" title="1">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov8" title="1">{
                        return nil, errors.New("invalid signing method")
                }</span>
                <span class="cov8" title="1">return as.jwtSecret, nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if claims, ok := token.Claims.(*Claims); ok &amp;&amp; token.Valid </span><span class="cov8" title="1">{
                return claims, nil
        }</span>

        <span class="cov0" title="0">return nil, errors.New("invalid token")</span>
}

// GenerateAPIKey generates a random API key
func GenerateAPIKey() (string, error) <span class="cov8" title="1">{
        bytes := make([]byte, 32)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return base64.URLEncoding.EncodeToString(bytes), nil</span>
}

// APIKeyStore manages API keys
type APIKeyStore struct {
        keys map[string]APIKeyInfo
}

// APIKeyInfo contains API key metadata
type APIKeyInfo struct {
        Key       string
        UserID    string
        Name      string
        CreatedAt time.Time
        ExpiresAt *time.Time
        Active    bool
}

// NewAPIKeyStore creates a new API key store
func NewAPIKeyStore() *APIKeyStore <span class="cov8" title="1">{
        return &amp;APIKeyStore{
                keys: make(map[string]APIKeyInfo),
        }
}</span>

// AddKey adds an API key
func (aks *APIKeyStore) AddKey(key string, info APIKeyInfo) <span class="cov8" title="1">{
        aks.keys[key] = info
}</span>

// ValidateKey validates an API key
func (aks *APIKeyStore) ValidateKey(key string) (*APIKeyInfo, bool) <span class="cov8" title="1">{
        info, ok := aks.keys[key]
        if !ok </span><span class="cov8" title="1">{
                return nil, false
        }</span>

        <span class="cov8" title="1">if !info.Active </span><span class="cov8" title="1">{
                return nil, false
        }</span>

        <span class="cov8" title="1">if info.ExpiresAt != nil &amp;&amp; time.Now().After(*info.ExpiresAt) </span><span class="cov8" title="1">{
                return nil, false
        }</span>

        <span class="cov8" title="1">return &amp;info, true</span>
}

// RevokeKey revokes an API key
func (aks *APIKeyStore) RevokeKey(key string) <span class="cov8" title="1">{
        if info, ok := aks.keys[key]; ok </span><span class="cov8" title="1">{
                info.Active = false
                aks.keys[key] = info
        }</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package security

import (
        "sync"
        "time"

        "golang.org/x/time/rate"
)

// RateLimiter implements rate limiting
type RateLimiter struct {
        mu       sync.RWMutex
        limiters map[string]*rate.Limiter
        rps      int
        burst    int
}

// NewRateLimiter creates a new rate limiter
func NewRateLimiter(rps, burst int) *RateLimiter <span class="cov8" title="1">{
        rl := &amp;RateLimiter{
                limiters: make(map[string]*rate.Limiter),
                rps:      rps,
                burst:    burst,
        }

        // Start cleanup goroutine
        go rl.cleanup()

        return rl
}</span>

// Allow checks if a request is allowed for a given key
func (rl *RateLimiter) Allow(key string) bool <span class="cov8" title="1">{
        limiter := rl.getLimiter(key)
        return limiter.Allow()
}</span>

// Wait waits until a request is allowed
func (rl *RateLimiter) Wait(key string) <span class="cov0" title="0">{
        limiter := rl.getLimiter(key)
        limiter.Wait(nil)
}</span>

// getLimiter gets or creates a limiter for a key
func (rl *RateLimiter) getLimiter(key string) *rate.Limiter <span class="cov8" title="1">{
        rl.mu.RLock()
        limiter, exists := rl.limiters[key]
        rl.mu.RUnlock()

        if exists </span><span class="cov8" title="1">{
                return limiter
        }</span>

        <span class="cov8" title="1">rl.mu.Lock()
        defer rl.mu.Unlock()

        // Double-check after acquiring write lock
        if limiter, exists := rl.limiters[key]; exists </span><span class="cov0" title="0">{
                return limiter
        }</span>

        <span class="cov8" title="1">limiter = rate.NewLimiter(rate.Limit(rl.rps), rl.burst)
        rl.limiters[key] = limiter
        return limiter</span>
}

// cleanup removes old limiters
func (rl *RateLimiter) cleanup() <span class="cov8" title="1">{
        ticker := time.NewTicker(time.Minute * 10)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                rl.mu.Lock()
                // In a real implementation, you'd track last access time
                // For now, we keep all limiters
                rl.mu.Unlock()
        }</span>
}

// Reset resets the limiter for a key
func (rl *RateLimiter) Reset(key string) <span class="cov8" title="1">{
        rl.mu.Lock()
        defer rl.mu.Unlock()
        delete(rl.limiters, key)
}</span>

// GetStats returns rate limiter statistics
func (rl *RateLimiter) GetStats() map[string]interface{} <span class="cov8" title="1">{
        rl.mu.RLock()
        defer rl.mu.RUnlock()

        return map[string]interface{}{
                "total_limiters": len(rl.limiters),
                "rps":            rl.rps,
                "burst":          rl.burst,
        }
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package storage

import (
        "context"
        "database/sql"
        "fmt"
        "time"

        _ "github.com/lib/pq" // PostgreSQL driver
)

// PostgreSQLStorage implements Storage using PostgreSQL
type PostgreSQLStorage struct {
        db *sql.DB
}

// NewPostgreSQLStorage creates a new PostgreSQL storage
func NewPostgreSQLStorage(config *Config) (*PostgreSQLStorage, error) <span class="cov0" title="0">{
        dsn := fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
                config.Host, config.Port, config.Username, config.Password, config.Database, config.SSLMode)

        db, err := sql.Open("postgres", dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database: %w", err)
        }</span>

        // Set connection pool settings
        <span class="cov0" title="0">if config.MaxOpenConns &gt; 0 </span><span class="cov0" title="0">{
                db.SetMaxOpenConns(config.MaxOpenConns)
        }</span>
        <span class="cov0" title="0">if config.MaxIdleConns &gt; 0 </span><span class="cov0" title="0">{
                db.SetMaxIdleConns(config.MaxIdleConns)
        }</span>
        <span class="cov0" title="0">if config.ConnMaxLifetime &gt; 0 </span><span class="cov0" title="0">{
                db.SetConnMaxLifetime(config.ConnMaxLifetime)
        }</span>

        <span class="cov0" title="0">storage := &amp;PostgreSQLStorage{db: db}

        // Initialize schema
        if err := storage.initSchema(); err != nil </span><span class="cov0" title="0">{
                db.Close()
                return nil, fmt.Errorf("failed to initialize schema: %w", err)
        }</span>

        <span class="cov0" title="0">return storage, nil</span>
}

// initSchema creates the necessary tables
func (s *PostgreSQLStorage) initSchema() error <span class="cov0" title="0">{
        schema := `
        CREATE TABLE IF NOT EXISTS translation_sessions (
                id TEXT PRIMARY KEY,
                book_title TEXT NOT NULL,
                input_file TEXT NOT NULL,
                output_file TEXT,
                source_language TEXT NOT NULL,
                target_language TEXT NOT NULL,
                provider TEXT NOT NULL,
                model TEXT NOT NULL,
                status TEXT NOT NULL,
                percent_complete REAL DEFAULT 0,
                current_chapter INTEGER DEFAULT 0,
                total_chapters INTEGER DEFAULT 0,
                items_completed INTEGER DEFAULT 0,
                items_failed INTEGER DEFAULT 0,
                items_total INTEGER DEFAULT 0,
                start_time TIMESTAMP NOT NULL,
                end_time TIMESTAMP,
                error_message TEXT,
                created_at TIMESTAMP NOT NULL,
                updated_at TIMESTAMP NOT NULL
        );

        CREATE INDEX IF NOT EXISTS idx_sessions_status ON translation_sessions(status);
        CREATE INDEX IF NOT EXISTS idx_sessions_created_at ON translation_sessions(created_at DESC);

        CREATE TABLE IF NOT EXISTS translation_cache (
                id TEXT PRIMARY KEY,
                source_text TEXT NOT NULL,
                target_text TEXT NOT NULL,
                source_language TEXT NOT NULL,
                target_language TEXT NOT NULL,
                provider TEXT NOT NULL,
                model TEXT NOT NULL,
                created_at TIMESTAMP NOT NULL,
                access_count INTEGER DEFAULT 0,
                last_accessed_at TIMESTAMP NOT NULL
        );

        CREATE INDEX IF NOT EXISTS idx_cache_lookup ON translation_cache(source_text, source_language, target_language, provider, model);
        CREATE INDEX IF NOT EXISTS idx_cache_last_accessed ON translation_cache(last_accessed_at);
        `

        _, err := s.db.Exec(schema)
        return err
}</span>

// CreateSession creates a new translation session
func (s *PostgreSQLStorage) CreateSession(ctx context.Context, session *TranslationSession) error <span class="cov0" title="0">{
        query := `
                INSERT INTO translation_sessions (
                        id, book_title, input_file, output_file, source_language, target_language,
                        provider, model, status, percent_complete, current_chapter, total_chapters,
                        items_completed, items_failed, items_total, start_time, created_at, updated_at
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18)
        `

        _, err := s.db.ExecContext(ctx, query,
                session.ID, session.BookTitle, session.InputFile, session.OutputFile,
                session.SourceLanguage, session.TargetLanguage, session.Provider, session.Model,
                session.Status, session.PercentComplete, session.CurrentChapter, session.TotalChapters,
                session.ItemsCompleted, session.ItemsFailed, session.ItemsTotal,
                session.StartTime, session.CreatedAt, session.UpdatedAt,
        )

        return err
}</span>

// GetSession retrieves a session by ID
func (s *PostgreSQLStorage) GetSession(ctx context.Context, sessionID string) (*TranslationSession, error) <span class="cov0" title="0">{
        query := `
                SELECT id, book_title, input_file, output_file, source_language, target_language,
                        provider, model, status, percent_complete, current_chapter, total_chapters,
                        items_completed, items_failed, items_total, start_time, end_time, error_message,
                        created_at, updated_at
                FROM translation_sessions
                WHERE id = $1
        `

        session := &amp;TranslationSession{}
        var endTime sql.NullTime
        var errorMessage sql.NullString

        err := s.db.QueryRowContext(ctx, query, sessionID).Scan(
                &amp;session.ID, &amp;session.BookTitle, &amp;session.InputFile, &amp;session.OutputFile,
                &amp;session.SourceLanguage, &amp;session.TargetLanguage, &amp;session.Provider, &amp;session.Model,
                &amp;session.Status, &amp;session.PercentComplete, &amp;session.CurrentChapter, &amp;session.TotalChapters,
                &amp;session.ItemsCompleted, &amp;session.ItemsFailed, &amp;session.ItemsTotal,
                &amp;session.StartTime, &amp;endTime, &amp;errorMessage, &amp;session.CreatedAt, &amp;session.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("session not found: %s", sessionID)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if endTime.Valid </span><span class="cov0" title="0">{
                session.EndTime = &amp;endTime.Time
        }</span>
        <span class="cov0" title="0">if errorMessage.Valid </span><span class="cov0" title="0">{
                session.ErrorMessage = errorMessage.String
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

// UpdateSession updates an existing session
func (s *PostgreSQLStorage) UpdateSession(ctx context.Context, session *TranslationSession) error <span class="cov0" title="0">{
        query := `
                UPDATE translation_sessions
                SET book_title = $1, output_file = $2, status = $3, percent_complete = $4,
                        current_chapter = $5, total_chapters = $6, items_completed = $7, items_failed = $8,
                        items_total = $9, end_time = $10, error_message = $11, updated_at = $12
                WHERE id = $13
        `

        _, err := s.db.ExecContext(ctx, query,
                session.BookTitle, session.OutputFile, session.Status, session.PercentComplete,
                session.CurrentChapter, session.TotalChapters, session.ItemsCompleted, session.ItemsFailed,
                session.ItemsTotal, session.EndTime, session.ErrorMessage, time.Now(), session.ID,
        )

        return err
}</span>

// ListSessions lists translation sessions with pagination
func (s *PostgreSQLStorage) ListSessions(ctx context.Context, limit, offset int) ([]*TranslationSession, error) <span class="cov0" title="0">{
        query := `
                SELECT id, book_title, input_file, output_file, source_language, target_language,
                        provider, model, status, percent_complete, current_chapter, total_chapters,
                        items_completed, items_failed, items_total, start_time, end_time, error_message,
                        created_at, updated_at
                FROM translation_sessions
                ORDER BY created_at DESC
                LIMIT $1 OFFSET $2
        `

        rows, err := s.db.QueryContext(ctx, query, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var sessions []*TranslationSession
        for rows.Next() </span><span class="cov0" title="0">{
                session := &amp;TranslationSession{}
                var endTime sql.NullTime
                var errorMessage sql.NullString

                err := rows.Scan(
                        &amp;session.ID, &amp;session.BookTitle, &amp;session.InputFile, &amp;session.OutputFile,
                        &amp;session.SourceLanguage, &amp;session.TargetLanguage, &amp;session.Provider, &amp;session.Model,
                        &amp;session.Status, &amp;session.PercentComplete, &amp;session.CurrentChapter, &amp;session.TotalChapters,
                        &amp;session.ItemsCompleted, &amp;session.ItemsFailed, &amp;session.ItemsTotal,
                        &amp;session.StartTime, &amp;endTime, &amp;errorMessage, &amp;session.CreatedAt, &amp;session.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if endTime.Valid </span><span class="cov0" title="0">{
                        session.EndTime = &amp;endTime.Time
                }</span>
                <span class="cov0" title="0">if errorMessage.Valid </span><span class="cov0" title="0">{
                        session.ErrorMessage = errorMessage.String
                }</span>

                <span class="cov0" title="0">sessions = append(sessions, session)</span>
        }

        <span class="cov0" title="0">return sessions, rows.Err()</span>
}

// DeleteSession deletes a session
func (s *PostgreSQLStorage) DeleteSession(ctx context.Context, sessionID string) error <span class="cov0" title="0">{
        _, err := s.db.ExecContext(ctx, "DELETE FROM translation_sessions WHERE id = $1", sessionID)
        return err
}</span>

// GetCachedTranslation retrieves a cached translation
func (s *PostgreSQLStorage) GetCachedTranslation(ctx context.Context, sourceText, sourceLanguage, targetLanguage, provider, model string) (*TranslationCache, error) <span class="cov0" title="0">{
        query := `
                SELECT id, source_text, target_text, source_language, target_language, provider, model,
                        created_at, access_count, last_accessed_at
                FROM translation_cache
                WHERE source_text = $1 AND source_language = $2 AND target_language = $3 AND provider = $4 AND model = $5
        `

        cache := &amp;TranslationCache{}
        err := s.db.QueryRowContext(ctx, query, sourceText, sourceLanguage, targetLanguage, provider, model).Scan(
                &amp;cache.ID, &amp;cache.SourceText, &amp;cache.TargetText, &amp;cache.SourceLanguage, &amp;cache.TargetLanguage,
                &amp;cache.Provider, &amp;cache.Model, &amp;cache.CreatedAt, &amp;cache.AccessCount, &amp;cache.LastAccessedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Update access count and last accessed time
        <span class="cov0" title="0">_, _ = s.db.ExecContext(ctx,
                "UPDATE translation_cache SET access_count = access_count + 1, last_accessed_at = $1 WHERE id = $2",
                time.Now(), cache.ID,
        )

        return cache, nil</span>
}

// CacheTranslation caches a translation
func (s *PostgreSQLStorage) CacheTranslation(ctx context.Context, cache *TranslationCache) error <span class="cov0" title="0">{
        query := `
                INSERT INTO translation_cache (
                        id, source_text, target_text, source_language, target_language, provider, model,
                        created_at, access_count, last_accessed_at
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
                ON CONFLICT (id) DO UPDATE SET
                        target_text = EXCLUDED.target_text,
                        last_accessed_at = EXCLUDED.last_accessed_at
        `

        _, err := s.db.ExecContext(ctx, query,
                cache.ID, cache.SourceText, cache.TargetText, cache.SourceLanguage, cache.TargetLanguage,
                cache.Provider, cache.Model, cache.CreatedAt, cache.AccessCount, cache.LastAccessedAt,
        )

        return err
}</span>

// CleanupOldCache removes cache entries older than the specified duration
func (s *PostgreSQLStorage) CleanupOldCache(ctx context.Context, olderThan time.Duration) error <span class="cov0" title="0">{
        cutoff := time.Now().Add(-olderThan)
        _, err := s.db.ExecContext(ctx, "DELETE FROM translation_cache WHERE last_accessed_at &lt; $1", cutoff)
        return err
}</span>

// GetStatistics returns translation statistics
func (s *PostgreSQLStorage) GetStatistics(ctx context.Context) (*Statistics, error) <span class="cov0" title="0">{
        stats := &amp;Statistics{}

        // Total sessions
        err := s.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM translation_sessions").Scan(&amp;stats.TotalSessions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Completed sessions
        <span class="cov0" title="0">err = s.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM translation_sessions WHERE status = 'completed'").Scan(&amp;stats.CompletedSessions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Failed sessions
        <span class="cov0" title="0">err = s.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM translation_sessions WHERE status = 'error'").Scan(&amp;stats.FailedSessions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // In progress sessions
        <span class="cov0" title="0">err = s.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM translation_sessions WHERE status IN ('initializing', 'translating')").Scan(&amp;stats.InProgressSessions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Total translations (cache entries)
        <span class="cov0" title="0">err = s.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM translation_cache").Scan(&amp;stats.TotalTranslations)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Average duration for completed sessions
        <span class="cov0" title="0">var avgDuration sql.NullFloat64
        err = s.db.QueryRowContext(ctx, `
                SELECT AVG(EXTRACT(EPOCH FROM (end_time - start_time)))
                FROM translation_sessions
                WHERE status = 'completed' AND end_time IS NOT NULL
        `).Scan(&amp;avgDuration)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if avgDuration.Valid </span><span class="cov0" title="0">{
                stats.AverageDuration = avgDuration.Float64
        }</span>

        // Cache hit rate (approximate based on access count)
        <span class="cov0" title="0">var totalAccess sql.NullInt64
        err = s.db.QueryRowContext(ctx, "SELECT SUM(access_count) FROM translation_cache").Scan(&amp;totalAccess)
        if err == nil &amp;&amp; totalAccess.Valid &amp;&amp; totalAccess.Int64 &gt; 0 &amp;&amp; stats.TotalTranslations &gt; 0 </span><span class="cov0" title="0">{
                stats.CacheHitRate = float64(totalAccess.Int64-stats.TotalTranslations) / float64(totalAccess.Int64) * 100.0
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}

// Ping checks the database connection
func (s *PostgreSQLStorage) Ping(ctx context.Context) error <span class="cov0" title="0">{
        return s.db.PingContext(ctx)
}</span>

// Close closes the database connection
func (s *PostgreSQLStorage) Close() error <span class="cov0" title="0">{
        return s.db.Close()
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package storage

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/redis/go-redis/v9"
)

// RedisStorage implements caching using Redis
type RedisStorage struct {
        client *redis.Client
        ttl    time.Duration
}

// NewRedisStorage creates a new Redis storage
func NewRedisStorage(config *Config, ttl time.Duration) (*RedisStorage, error) <span class="cov8" title="1">{
        addr := fmt.Sprintf("%s:%d", config.Host, config.Port)

        client := redis.NewClient(&amp;redis.Options{
                Addr:     addr,
                Password: config.Password,
                DB:       0,
        })

        // Test connection
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if err := client.Ping(ctx).Err(); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to connect to Redis: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;RedisStorage{
                client: client,
                ttl:    ttl,
        }, nil</span>
}

// CreateSession creates a new translation session in Redis
func (r *RedisStorage) CreateSession(ctx context.Context, session *TranslationSession) error <span class="cov0" title="0">{
        data, err := json.Marshal(session)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">key := fmt.Sprintf("session:%s", session.ID)
        return r.client.Set(ctx, key, data, r.ttl).Err()</span>
}

// GetSession retrieves a session by ID from Redis
func (r *RedisStorage) GetSession(ctx context.Context, sessionID string) (*TranslationSession, error) <span class="cov0" title="0">{
        key := fmt.Sprintf("session:%s", sessionID)
        data, err := r.client.Get(ctx, key).Bytes()
        if err == redis.Nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("session not found: %s", sessionID)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">session := &amp;TranslationSession{}
        if err := json.Unmarshal(data, session); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

// UpdateSession updates an existing session in Redis
func (r *RedisStorage) UpdateSession(ctx context.Context, session *TranslationSession) error <span class="cov0" title="0">{
        session.UpdatedAt = time.Now()
        return r.CreateSession(ctx, session) // Redis SET overwrites
}</span>

// ListSessions lists translation sessions from Redis with pagination
func (r *RedisStorage) ListSessions(ctx context.Context, limit, offset int) ([]*TranslationSession, error) <span class="cov0" title="0">{
        pattern := "session:*"
        var cursor uint64
        var sessions []*TranslationSession
        count := 0

        for </span><span class="cov0" title="0">{
                keys, nextCursor, err := r.client.Scan(ctx, cursor, pattern, 100).Result()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">for _, key := range keys </span><span class="cov0" title="0">{
                        if count &lt; offset </span><span class="cov0" title="0">{
                                count++
                                continue</span>
                        }
                        <span class="cov0" title="0">if len(sessions) &gt;= limit </span><span class="cov0" title="0">{
                                return sessions, nil
                        }</span>

                        <span class="cov0" title="0">data, err := r.client.Get(ctx, key).Bytes()
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">session := &amp;TranslationSession{}
                        if err := json.Unmarshal(data, session); err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">sessions = append(sessions, session)
                        count++</span>
                }

                <span class="cov0" title="0">cursor = nextCursor
                if cursor == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">return sessions, nil</span>
}

// DeleteSession deletes a session from Redis
func (r *RedisStorage) DeleteSession(ctx context.Context, sessionID string) error <span class="cov0" title="0">{
        key := fmt.Sprintf("session:%s", sessionID)
        return r.client.Del(ctx, key).Err()
}</span>

// GetCachedTranslation retrieves a cached translation from Redis
func (r *RedisStorage) GetCachedTranslation(ctx context.Context, sourceText, sourceLanguage, targetLanguage, provider, model string) (*TranslationCache, error) <span class="cov0" title="0">{
        key := r.makeCacheKey(sourceText, sourceLanguage, targetLanguage, provider, model)
        data, err := r.client.Get(ctx, key).Bytes()
        if err == redis.Nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">cache := &amp;TranslationCache{}
        if err := json.Unmarshal(data, cache); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Update access count and last accessed time
        <span class="cov0" title="0">cache.AccessCount++
        cache.LastAccessedAt = time.Now()
        _ = r.CacheTranslation(ctx, cache) // Update in background

        return cache, nil</span>
}

// CacheTranslation caches a translation in Redis
func (r *RedisStorage) CacheTranslation(ctx context.Context, cache *TranslationCache) error <span class="cov0" title="0">{
        key := r.makeCacheKey(cache.SourceText, cache.SourceLanguage, cache.TargetLanguage, cache.Provider, cache.Model)
        data, err := json.Marshal(cache)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return r.client.Set(ctx, key, data, r.ttl).Err()</span>
}

// CleanupOldCache removes cache entries older than the specified duration
// Note: Redis handles TTL automatically, so this is a no-op
func (r *RedisStorage) CleanupOldCache(ctx context.Context, olderThan time.Duration) error <span class="cov0" title="0">{
        // Redis handles expiration automatically via TTL
        return nil
}</span>

// GetStatistics returns translation statistics from Redis
func (r *RedisStorage) GetStatistics(ctx context.Context) (*Statistics, error) <span class="cov0" title="0">{
        stats := &amp;Statistics{}

        // Count sessions by status
        pattern := "session:*"
        var cursor uint64

        for </span><span class="cov0" title="0">{
                keys, nextCursor, err := r.client.Scan(ctx, cursor, pattern, 100).Result()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">for _, key := range keys </span><span class="cov0" title="0">{
                        data, err := r.client.Get(ctx, key).Bytes()
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">session := &amp;TranslationSession{}
                        if err := json.Unmarshal(data, session); err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">stats.TotalSessions++
                        switch session.Status </span>{
                        case "completed":<span class="cov0" title="0">
                                stats.CompletedSessions++</span>
                        case "error":<span class="cov0" title="0">
                                stats.FailedSessions++</span>
                        case "initializing", "translating":<span class="cov0" title="0">
                                stats.InProgressSessions++</span>
                        }

                        // Calculate average duration for completed sessions
                        <span class="cov0" title="0">if session.Status == "completed" &amp;&amp; session.EndTime != nil </span><span class="cov0" title="0">{
                                duration := session.EndTime.Sub(session.StartTime).Seconds()
                                stats.AverageDuration = (stats.AverageDuration*float64(stats.CompletedSessions-1) + duration) / float64(stats.CompletedSessions)
                        }</span>
                }

                <span class="cov0" title="0">cursor = nextCursor
                if cursor == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        // Count cache entries
        <span class="cov0" title="0">cachePattern := "cache:*"
        cursor = 0
        var totalAccess int64

        for </span><span class="cov0" title="0">{
                keys, nextCursor, err := r.client.Scan(ctx, cursor, cachePattern, 100).Result()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">for _, key := range keys </span><span class="cov0" title="0">{
                        data, err := r.client.Get(ctx, key).Bytes()
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">cache := &amp;TranslationCache{}
                        if err := json.Unmarshal(data, cache); err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">stats.TotalTranslations++
                        totalAccess += int64(cache.AccessCount)</span>
                }

                <span class="cov0" title="0">cursor = nextCursor
                if cursor == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        // Calculate cache hit rate
        <span class="cov0" title="0">if totalAccess &gt; 0 &amp;&amp; stats.TotalTranslations &gt; 0 </span><span class="cov0" title="0">{
                stats.CacheHitRate = float64(totalAccess-stats.TotalTranslations) / float64(totalAccess) * 100.0
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}

// Ping checks the Redis connection
func (r *RedisStorage) Ping(ctx context.Context) error <span class="cov0" title="0">{
        return r.client.Ping(ctx).Err()
}</span>

// Close closes the Redis connection
func (r *RedisStorage) Close() error <span class="cov0" title="0">{
        return r.client.Close()
}</span>

// makeCacheKey creates a cache key from translation parameters
func (r *RedisStorage) makeCacheKey(sourceText, sourceLanguage, targetLanguage, provider, model string) string <span class="cov0" title="0">{
        return fmt.Sprintf("cache:%s:%s:%s:%s:%s", sourceLanguage, targetLanguage, provider, model, hashString(sourceText))
}</span>

// hashString creates a simple hash of a string (for cache keys)
func hashString(s string) string <span class="cov0" title="0">{
        h := uint32(0)
        for _, c := range s </span><span class="cov0" title="0">{
                h = h*31 + uint32(c)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%08x", h)</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package storage

import (
        "context"
        "database/sql"
        "fmt"
        "time"

        _ "github.com/mattn/go-sqlite3" // SQLite driver
)

// SQLiteStorage implements Storage using SQLite with SQLCipher encryption
type SQLiteStorage struct {
        db *sql.DB
}

// NewSQLiteStorage creates a new SQLite storage
func NewSQLiteStorage(config *Config) (*SQLiteStorage, error) <span class="cov8" title="1">{
        dsn := config.Database

        // Add SQLCipher encryption key if provided
        if config.EncryptionKey != "" </span><span class="cov8" title="1">{
                dsn += fmt.Sprintf("?_pragma_key=%s&amp;_pragma_cipher_page_size=4096", config.EncryptionKey)
        }</span>

        <span class="cov8" title="1">db, err := sql.Open("sqlite3", dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database: %w", err)
        }</span>

        // Set connection pool settings
        <span class="cov8" title="1">if config.MaxOpenConns &gt; 0 </span><span class="cov8" title="1">{
                db.SetMaxOpenConns(config.MaxOpenConns)
        }</span>
        <span class="cov8" title="1">if config.MaxIdleConns &gt; 0 </span><span class="cov8" title="1">{
                db.SetMaxIdleConns(config.MaxIdleConns)
        }</span>
        <span class="cov8" title="1">if config.ConnMaxLifetime &gt; 0 </span><span class="cov0" title="0">{
                db.SetConnMaxLifetime(config.ConnMaxLifetime)
        }</span>

        <span class="cov8" title="1">storage := &amp;SQLiteStorage{db: db}

        // Initialize schema
        if err := storage.initSchema(); err != nil </span><span class="cov0" title="0">{
                db.Close()
                return nil, fmt.Errorf("failed to initialize schema: %w", err)
        }</span>

        <span class="cov8" title="1">return storage, nil</span>
}

// initSchema creates the necessary tables
func (s *SQLiteStorage) initSchema() error <span class="cov8" title="1">{
        schema := `
        CREATE TABLE IF NOT EXISTS translation_sessions (
                id TEXT PRIMARY KEY,
                book_title TEXT NOT NULL,
                input_file TEXT NOT NULL,
                output_file TEXT,
                source_language TEXT NOT NULL,
                target_language TEXT NOT NULL,
                provider TEXT NOT NULL,
                model TEXT NOT NULL,
                status TEXT NOT NULL,
                percent_complete REAL DEFAULT 0,
                current_chapter INTEGER DEFAULT 0,
                total_chapters INTEGER DEFAULT 0,
                items_completed INTEGER DEFAULT 0,
                items_failed INTEGER DEFAULT 0,
                items_total INTEGER DEFAULT 0,
                start_time DATETIME NOT NULL,
                end_time DATETIME,
                error_message TEXT,
                created_at DATETIME NOT NULL,
                updated_at DATETIME NOT NULL
        );

        CREATE INDEX IF NOT EXISTS idx_sessions_status ON translation_sessions(status);
        CREATE INDEX IF NOT EXISTS idx_sessions_created_at ON translation_sessions(created_at DESC);

        CREATE TABLE IF NOT EXISTS translation_cache (
                id TEXT PRIMARY KEY,
                source_text TEXT NOT NULL,
                target_text TEXT NOT NULL,
                source_language TEXT NOT NULL,
                target_language TEXT NOT NULL,
                provider TEXT NOT NULL,
                model TEXT NOT NULL,
                created_at DATETIME NOT NULL,
                access_count INTEGER DEFAULT 0,
                last_accessed_at DATETIME NOT NULL
        );

        CREATE INDEX IF NOT EXISTS idx_cache_lookup ON translation_cache(source_text, source_language, target_language, provider, model);
        CREATE INDEX IF NOT EXISTS idx_cache_last_accessed ON translation_cache(last_accessed_at);
        `

        _, err := s.db.Exec(schema)
        return err
}</span>

// CreateSession creates a new translation session
func (s *SQLiteStorage) CreateSession(ctx context.Context, session *TranslationSession) error <span class="cov8" title="1">{
        query := `
                INSERT INTO translation_sessions (
                        id, book_title, input_file, output_file, source_language, target_language,
                        provider, model, status, percent_complete, current_chapter, total_chapters,
                        items_completed, items_failed, items_total, start_time, created_at, updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err := s.db.ExecContext(ctx, query,
                session.ID, session.BookTitle, session.InputFile, session.OutputFile,
                session.SourceLanguage, session.TargetLanguage, session.Provider, session.Model,
                session.Status, session.PercentComplete, session.CurrentChapter, session.TotalChapters,
                session.ItemsCompleted, session.ItemsFailed, session.ItemsTotal,
                session.StartTime, session.CreatedAt, session.UpdatedAt,
        )

        return err
}</span>

// GetSession retrieves a session by ID
func (s *SQLiteStorage) GetSession(ctx context.Context, sessionID string) (*TranslationSession, error) <span class="cov8" title="1">{
        query := `
                SELECT id, book_title, input_file, output_file, source_language, target_language,
                        provider, model, status, percent_complete, current_chapter, total_chapters,
                        items_completed, items_failed, items_total, start_time, end_time, error_message,
                        created_at, updated_at
                FROM translation_sessions
                WHERE id = ?
        `

        session := &amp;TranslationSession{}
        var endTime sql.NullTime
        var errorMessage sql.NullString

        err := s.db.QueryRowContext(ctx, query, sessionID).Scan(
                &amp;session.ID, &amp;session.BookTitle, &amp;session.InputFile, &amp;session.OutputFile,
                &amp;session.SourceLanguage, &amp;session.TargetLanguage, &amp;session.Provider, &amp;session.Model,
                &amp;session.Status, &amp;session.PercentComplete, &amp;session.CurrentChapter, &amp;session.TotalChapters,
                &amp;session.ItemsCompleted, &amp;session.ItemsFailed, &amp;session.ItemsTotal,
                &amp;session.StartTime, &amp;endTime, &amp;errorMessage, &amp;session.CreatedAt, &amp;session.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("session not found: %s", sessionID)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if endTime.Valid </span><span class="cov8" title="1">{
                session.EndTime = &amp;endTime.Time
        }</span>
        <span class="cov8" title="1">if errorMessage.Valid </span><span class="cov8" title="1">{
                session.ErrorMessage = errorMessage.String
        }</span>

        <span class="cov8" title="1">return session, nil</span>
}

// UpdateSession updates an existing session
func (s *SQLiteStorage) UpdateSession(ctx context.Context, session *TranslationSession) error <span class="cov8" title="1">{
        query := `
                UPDATE translation_sessions
                SET book_title = ?, output_file = ?, status = ?, percent_complete = ?,
                        current_chapter = ?, total_chapters = ?, items_completed = ?, items_failed = ?,
                        items_total = ?, end_time = ?, error_message = ?, updated_at = ?
                WHERE id = ?
        `

        _, err := s.db.ExecContext(ctx, query,
                session.BookTitle, session.OutputFile, session.Status, session.PercentComplete,
                session.CurrentChapter, session.TotalChapters, session.ItemsCompleted, session.ItemsFailed,
                session.ItemsTotal, session.EndTime, session.ErrorMessage, time.Now(), session.ID,
        )

        return err
}</span>

// ListSessions lists translation sessions with pagination
func (s *SQLiteStorage) ListSessions(ctx context.Context, limit, offset int) ([]*TranslationSession, error) <span class="cov8" title="1">{
        query := `
                SELECT id, book_title, input_file, output_file, source_language, target_language,
                        provider, model, status, percent_complete, current_chapter, total_chapters,
                        items_completed, items_failed, items_total, start_time, end_time, error_message,
                        created_at, updated_at
                FROM translation_sessions
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := s.db.QueryContext(ctx, query, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var sessions []*TranslationSession
        for rows.Next() </span><span class="cov8" title="1">{
                session := &amp;TranslationSession{}
                var endTime sql.NullTime
                var errorMessage sql.NullString

                err := rows.Scan(
                        &amp;session.ID, &amp;session.BookTitle, &amp;session.InputFile, &amp;session.OutputFile,
                        &amp;session.SourceLanguage, &amp;session.TargetLanguage, &amp;session.Provider, &amp;session.Model,
                        &amp;session.Status, &amp;session.PercentComplete, &amp;session.CurrentChapter, &amp;session.TotalChapters,
                        &amp;session.ItemsCompleted, &amp;session.ItemsFailed, &amp;session.ItemsTotal,
                        &amp;session.StartTime, &amp;endTime, &amp;errorMessage, &amp;session.CreatedAt, &amp;session.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">if endTime.Valid </span><span class="cov0" title="0">{
                        session.EndTime = &amp;endTime.Time
                }</span>
                <span class="cov8" title="1">if errorMessage.Valid </span><span class="cov8" title="1">{
                        session.ErrorMessage = errorMessage.String
                }</span>

                <span class="cov8" title="1">sessions = append(sessions, session)</span>
        }

        <span class="cov8" title="1">return sessions, rows.Err()</span>
}

// DeleteSession deletes a session
func (s *SQLiteStorage) DeleteSession(ctx context.Context, sessionID string) error <span class="cov8" title="1">{
        _, err := s.db.ExecContext(ctx, "DELETE FROM translation_sessions WHERE id = ?", sessionID)
        return err
}</span>

// GetCachedTranslation retrieves a cached translation
func (s *SQLiteStorage) GetCachedTranslation(ctx context.Context, sourceText, sourceLanguage, targetLanguage, provider, model string) (*TranslationCache, error) <span class="cov8" title="1">{
        query := `
                SELECT id, source_text, target_text, source_language, target_language, provider, model,
                        created_at, access_count, last_accessed_at
                FROM translation_cache
                WHERE source_text = ? AND source_language = ? AND target_language = ? AND provider = ? AND model = ?
        `

        cache := &amp;TranslationCache{}
        err := s.db.QueryRowContext(ctx, query, sourceText, sourceLanguage, targetLanguage, provider, model).Scan(
                &amp;cache.ID, &amp;cache.SourceText, &amp;cache.TargetText, &amp;cache.SourceLanguage, &amp;cache.TargetLanguage,
                &amp;cache.Provider, &amp;cache.Model, &amp;cache.CreatedAt, &amp;cache.AccessCount, &amp;cache.LastAccessedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Update access count and last accessed time
        <span class="cov8" title="1">_, _ = s.db.ExecContext(ctx,
                "UPDATE translation_cache SET access_count = access_count + 1, last_accessed_at = ? WHERE id = ?",
                time.Now(), cache.ID,
        )

        return cache, nil</span>
}

// CacheTranslation caches a translation
func (s *SQLiteStorage) CacheTranslation(ctx context.Context, cache *TranslationCache) error <span class="cov8" title="1">{
        query := `
                INSERT OR REPLACE INTO translation_cache (
                        id, source_text, target_text, source_language, target_language, provider, model,
                        created_at, access_count, last_accessed_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err := s.db.ExecContext(ctx, query,
                cache.ID, cache.SourceText, cache.TargetText, cache.SourceLanguage, cache.TargetLanguage,
                cache.Provider, cache.Model, cache.CreatedAt, cache.AccessCount, cache.LastAccessedAt,
        )

        return err
}</span>

// CleanupOldCache removes cache entries older than the specified duration
func (s *SQLiteStorage) CleanupOldCache(ctx context.Context, olderThan time.Duration) error <span class="cov8" title="1">{
        cutoff := time.Now().Add(-olderThan)
        _, err := s.db.ExecContext(ctx, "DELETE FROM translation_cache WHERE last_accessed_at &lt; ?", cutoff)
        return err
}</span>

// GetStatistics returns translation statistics
func (s *SQLiteStorage) GetStatistics(ctx context.Context) (*Statistics, error) <span class="cov8" title="1">{
        stats := &amp;Statistics{}

        // Total sessions
        err := s.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM translation_sessions").Scan(&amp;stats.TotalSessions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Completed sessions
        <span class="cov8" title="1">err = s.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM translation_sessions WHERE status = 'completed'").Scan(&amp;stats.CompletedSessions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Failed sessions
        <span class="cov8" title="1">err = s.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM translation_sessions WHERE status = 'error'").Scan(&amp;stats.FailedSessions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // In progress sessions
        <span class="cov8" title="1">err = s.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM translation_sessions WHERE status IN ('initializing', 'translating')").Scan(&amp;stats.InProgressSessions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Total translations (cache entries)
        <span class="cov8" title="1">err = s.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM translation_cache").Scan(&amp;stats.TotalTranslations)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Average duration for completed sessions
        <span class="cov8" title="1">var avgDuration sql.NullFloat64
        err = s.db.QueryRowContext(ctx, `
                SELECT AVG(CAST((julianday(end_time) - julianday(start_time)) * 86400 AS REAL))
                FROM translation_sessions
                WHERE status = 'completed' AND end_time IS NOT NULL
        `).Scan(&amp;avgDuration)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if avgDuration.Valid </span><span class="cov0" title="0">{
                stats.AverageDuration = avgDuration.Float64
        }</span>

        // Cache hit rate (approximate based on access count)
        <span class="cov8" title="1">var totalAccess sql.NullInt64
        err = s.db.QueryRowContext(ctx, "SELECT SUM(access_count) FROM translation_cache").Scan(&amp;totalAccess)
        if err == nil &amp;&amp; totalAccess.Valid &amp;&amp; totalAccess.Int64 &gt; 0 &amp;&amp; stats.TotalTranslations &gt; 0 </span><span class="cov8" title="1">{
                stats.CacheHitRate = float64(totalAccess.Int64-stats.TotalTranslations) / float64(totalAccess.Int64) * 100.0
        }</span>

        <span class="cov8" title="1">return stats, nil</span>
}

// Ping checks the database connection
func (s *SQLiteStorage) Ping(ctx context.Context) error <span class="cov8" title="1">{
        return s.db.PingContext(ctx)
}</span>

// Close closes the database connection
func (s *SQLiteStorage) Close() error <span class="cov8" title="1">{
        return s.db.Close()
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package llm

import (
        "bytes"
        "context"
        "digital.vasic.translator/pkg/translator"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "time"
)

// AnthropicClient implements Anthropic Claude API client
type AnthropicClient struct {
        config     translator.TranslationConfig
        httpClient *http.Client
        baseURL    string
}

// AnthropicRequest represents Anthropic API request
type AnthropicRequest struct {
        Model       string            `json:"model"`
        Messages    []AnthropicMessage `json:"messages"`
        MaxTokens   int               `json:"max_tokens"`
        Temperature float64           `json:"temperature,omitempty"`
}

// AnthropicMessage represents a message in Anthropic format
type AnthropicMessage struct {
        Role    string `json:"role"`
        Content string `json:"content"`
}

// AnthropicResponse represents Anthropic API response
type AnthropicResponse struct {
        ID      string   `json:"id"`
        Type    string   `json:"type"`
        Role    string   `json:"role"`
        Content []Content `json:"content"`
        Model   string   `json:"model"`
        Usage   AnthropicUsage `json:"usage"`
}

// Content represents content block
type Content struct {
        Type string `json:"type"`
        Text string `json:"text"`
}

// AnthropicUsage represents token usage
type AnthropicUsage struct {
        InputTokens  int `json:"input_tokens"`
        OutputTokens int `json:"output_tokens"`
}

// NewAnthropicClient creates a new Anthropic client
func NewAnthropicClient(config translator.TranslationConfig) (*AnthropicClient, error) <span class="cov0" title="0">{
        if config.APIKey == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Anthropic API key is required")
        }</span>

        <span class="cov0" title="0">baseURL := config.BaseURL
        if baseURL == "" </span><span class="cov0" title="0">{
                baseURL = "https://api.anthropic.com/v1"
        }</span>

        <span class="cov0" title="0">return &amp;AnthropicClient{
                config: config,
                httpClient: &amp;http.Client{
                        Timeout: 600 * time.Second, // Increased to 10 minutes for very large book sections (up to 44KB)
                },
                baseURL: baseURL,
        }, nil</span>
}

// GetProviderName returns the provider name
func (c *AnthropicClient) GetProviderName() string <span class="cov0" title="0">{
        return "anthropic"
}</span>

// Translate translates text using Anthropic Claude
func (c *AnthropicClient) Translate(ctx context.Context, text string, prompt string) (string, error) <span class="cov0" title="0">{
        model := c.config.Model
        if model == "" </span><span class="cov0" title="0">{
                model = "claude-3-sonnet-20240229"
        }</span>

        <span class="cov0" title="0">temperature := 0.3
        if c.config.Options["temperature"] != nil </span><span class="cov0" title="0">{
                if t, ok := c.config.Options["temperature"].(float64); ok </span><span class="cov0" title="0">{
                        temperature = t
                }</span>
        }

        <span class="cov0" title="0">maxTokens := 4096
        if c.config.Options["max_tokens"] != nil </span><span class="cov0" title="0">{
                if mt, ok := c.config.Options["max_tokens"].(int); ok </span><span class="cov0" title="0">{
                        maxTokens = mt
                }</span>
        }

        <span class="cov0" title="0">request := AnthropicRequest{
                Model: model,
                Messages: []AnthropicMessage{
                        {Role: "user", Content: prompt},
                },
                MaxTokens:   maxTokens,
                Temperature: temperature,
        }

        jsonData, err := json.Marshal(request)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, "POST", c.baseURL+"/messages", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("x-api-key", c.config.APIKey)
        req.Header.Set("anthropic-version", "2023-06-01")

        resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to send request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return "", fmt.Errorf("Anthropic API error (status %d): %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var response AnthropicResponse
        if err := json.Unmarshal(body, &amp;response); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to unmarshal response: %w", err)
        }</span>

        <span class="cov0" title="0">if len(response.Content) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no content in response")
        }</span>

        <span class="cov0" title="0">return response.Content[0].Text, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package llm

import (
        "digital.vasic.translator/pkg/translator"
        "fmt"
)

// DeepSeekClient implements DeepSeek API client (uses OpenAI-compatible API)
type DeepSeekClient struct {
        *OpenAIClient
}

// NewDeepSeekClient creates a new DeepSeek client
func NewDeepSeekClient(config translator.TranslationConfig) (*DeepSeekClient, error) <span class="cov0" title="0">{
        if config.APIKey == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("DeepSeek API key is required")
        }</span>

        // DeepSeek uses OpenAI-compatible API
        <span class="cov0" title="0">if config.BaseURL == "" </span><span class="cov0" title="0">{
                config.BaseURL = "https://api.deepseek.com/v1"
        }</span>

        <span class="cov0" title="0">if config.Model == "" </span><span class="cov0" title="0">{
                config.Model = "deepseek-chat"
        }</span>

        <span class="cov0" title="0">openaiClient, err := NewOpenAIClient(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;DeepSeekClient{
                OpenAIClient: openaiClient,
        }, nil</span>
}

// GetProviderName returns the provider name
func (c *DeepSeekClient) GetProviderName() string <span class="cov0" title="0">{
        return "deepseek"
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package llm

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strings"
        "time"

        "digital.vasic.translator/pkg/translator"
)

// GeminiClient implements the LLMClient interface for Google Gemini
type GeminiClient struct {
        config     translator.TranslationConfig
        httpClient *http.Client
        baseURL    string
}

// GeminiRequest represents a request to the Gemini API
type GeminiRequest struct {
        Contents         []GeminiContent         `json:"contents"`
        GenerationConfig *GeminiGenerationConfig `json:"generationConfig,omitempty"`
        SafetySettings   []GeminiSafetySetting   `json:"safetySettings,omitempty"`
}

// GeminiContent represents content in a Gemini request
type GeminiContent struct {
        Parts []GeminiPart `json:"parts"`
        Role  string       `json:"role,omitempty"`
}

// GeminiPart represents a part of content
type GeminiPart struct {
        Text string `json:"text"`
}

// GeminiGenerationConfig represents generation configuration
type GeminiGenerationConfig struct {
        Temperature     float64  `json:"temperature,omitempty"`
        TopK            int      `json:"topK,omitempty"`
        TopP            float64  `json:"topP,omitempty"`
        MaxOutputTokens int      `json:"maxOutputTokens,omitempty"`
        StopSequences   []string `json:"stopSequences,omitempty"`
}

// GeminiSafetySetting represents safety settings
type GeminiSafetySetting struct {
        Category  string `json:"category"`
        Threshold string `json:"threshold"`
}

// GeminiResponse represents a response from the Gemini API
type GeminiResponse struct {
        Candidates    []GeminiCandidate    `json:"candidates"`
        UsageMetadata *GeminiUsageMetadata `json:"usageMetadata,omitempty"`
}

// GeminiCandidate represents a candidate response
type GeminiCandidate struct {
        Content       GeminiContent        `json:"content"`
        FinishReason  string               `json:"finishReason"`
        Index         int                  `json:"index"`
        SafetyRatings []GeminiSafetyRating `json:"safetyRatings"`
}

// GeminiSafetyRating represents safety ratings
type GeminiSafetyRating struct {
        Category    string `json:"category"`
        Probability string `json:"probability"`
}

// GeminiUsageMetadata represents usage metadata
type GeminiUsageMetadata struct {
        PromptTokenCount     int `json:"promptTokenCount"`
        CandidatesTokenCount int `json:"candidatesTokenCount"`
        TotalTokenCount      int `json:"totalTokenCount"`
}

// NewGeminiClient creates a new Gemini client
func NewGeminiClient(config translator.TranslationConfig) (*GeminiClient, error) <span class="cov0" title="0">{
        baseURL := config.BaseURL
        if baseURL == "" </span><span class="cov0" title="0">{
                baseURL = "https://generativelanguage.googleapis.com/v1beta"
        }</span>

        <span class="cov0" title="0">return &amp;GeminiClient{
                config: config,
                httpClient: &amp;http.Client{
                        Timeout: 60 * time.Second, // Default timeout
                },
                baseURL: baseURL,
        }, nil</span>
}

// Translate performs translation using Google Gemini
func (g *GeminiClient) Translate(ctx context.Context, text string, prompt string) (string, error) <span class="cov0" title="0">{
        if text == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("text is required")
        }</span>

        // Build the full prompt
        <span class="cov0" title="0">fullPrompt := g.buildPrompt(text, prompt)

        // Create the request
        geminiReq := GeminiRequest{
                Contents: []GeminiContent{
                        {
                                Parts: []GeminiPart{
                                        {Text: fullPrompt},
                                },
                                Role: "user",
                        },
                },
                GenerationConfig: &amp;GeminiGenerationConfig{
                        Temperature:     0.3,
                        TopK:            40,
                        TopP:            0.95,
                        MaxOutputTokens: 4000,
                },
                SafetySettings: []GeminiSafetySetting{
                        {
                                Category:  "HARM_CATEGORY_HARASSMENT",
                                Threshold: "BLOCK_MEDIUM_AND_ABOVE",
                        },
                        {
                                Category:  "HARM_CATEGORY_HATE_SPEECH",
                                Threshold: "BLOCK_MEDIUM_AND_ABOVE",
                        },
                        {
                                Category:  "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                                Threshold: "BLOCK_MEDIUM_AND_ABOVE",
                        },
                        {
                                Category:  "HARM_CATEGORY_DANGEROUS_CONTENT",
                                Threshold: "BLOCK_MEDIUM_AND_ABOVE",
                        },
                },
        }

        // Make the API request
        resp, err := g.makeRequest(ctx, geminiReq)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to make Gemini request: %w", err)
        }</span>

        // Parse the response
        <span class="cov0" title="0">translatedText, err := g.parseResponse(resp)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to parse Gemini response: %w", err)
        }</span>

        <span class="cov0" title="0">return translatedText, nil</span>
}

// buildPrompt creates the translation prompt
func (g *GeminiClient) buildPrompt(text, prompt string) string <span class="cov0" title="0">{
        var fullPrompt strings.Builder

        if prompt != "" </span><span class="cov0" title="0">{
                fullPrompt.WriteString(prompt)
                fullPrompt.WriteString("\n\n")
        }</span>

        <span class="cov0" title="0">fullPrompt.WriteString("Text to translate:\n")
        fullPrompt.WriteString(text)
        fullPrompt.WriteString("\n\n")
        fullPrompt.WriteString("Provide only the translated text without any explanations or additional formatting.")

        return fullPrompt.String()</span>
}

// makeRequest sends a request to the Gemini API
func (g *GeminiClient) makeRequest(ctx context.Context, req GeminiRequest) (*GeminiResponse, error) <span class="cov0" title="0">{
        // Build the URL
        model := g.config.Model
        if model == "" </span><span class="cov0" title="0">{
                model = "gemini-pro"
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("%s/models/%s:generateContent?key=%s",
                g.baseURL,
                model,
                g.config.APIKey)

        // Marshal the request
        reqBody, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        // Create HTTP request
        <span class="cov0" title="0">httpReq, err := http.NewRequestWithContext(ctx, "POST", url, bytes.NewBuffer(reqBody))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">httpReq.Header.Set("Content-Type", "application/json")

        // Send request
        resp, err := g.httpClient.Do(httpReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to send request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // Read response body
        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response body: %w", err)
        }</span>

        // Check status code
        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Gemini API returned status %d: %s", resp.StatusCode, string(body))
        }</span>

        // Parse response
        <span class="cov0" title="0">var geminiResp GeminiResponse
        if err := json.Unmarshal(body, &amp;geminiResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal response: %w", err)
        }</span>

        // Check for candidates
        <span class="cov0" title="0">if len(geminiResp.Candidates) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no candidates in Gemini response")
        }</span>

        <span class="cov0" title="0">return &amp;geminiResp, nil</span>
}

// parseResponse extracts the translated text from the Gemini response
func (g *GeminiClient) parseResponse(resp *GeminiResponse) (string, error) <span class="cov0" title="0">{
        if len(resp.Candidates) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no candidates in response")
        }</span>

        <span class="cov0" title="0">candidate := resp.Candidates[0]

        // Check finish reason
        if candidate.FinishReason != "STOP" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("generation did not complete successfully: %s", candidate.FinishReason)
        }</span>

        // Extract text from parts
        <span class="cov0" title="0">var translatedText strings.Builder
        for _, part := range candidate.Content.Parts </span><span class="cov0" title="0">{
                translatedText.WriteString(part.Text)
        }</span>

        <span class="cov0" title="0">return strings.TrimSpace(translatedText.String()), nil</span>
}

// GetProviderName returns the provider name
func (g *GeminiClient) GetProviderName() string <span class="cov0" title="0">{
        return "gemini"
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package llm

import (
        "bytes"
        "context"
        "digital.vasic.translator/pkg/hardware"
        "digital.vasic.translator/pkg/models"
        "digital.vasic.translator/pkg/translator"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "time"
)

// LlamaCppClient implements llama.cpp integration for local LLM inference
type LlamaCppClient struct {
        config       translator.TranslationConfig
        modelPath    string
        modelInfo    *models.ModelInfo
        hardwareCaps *hardware.Capabilities
        threads      int
        contextSize  int
        executable   string
}

// NewLlamaCppClient creates a new llama.cpp client with automatic hardware detection and model selection
func NewLlamaCppClient(config translator.TranslationConfig) (*LlamaCppClient, error) <span class="cov8" title="1">{
        // Detect hardware capabilities
        detector := hardware.NewDetector()
        caps, err := detector.Detect()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("hardware detection failed: %w", err)
        }</span>

        // Find llama-cli executable
        <span class="cov8" title="1">executable, err := findLlamaCppExecutable()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("llama.cpp not found: %w (install with: brew install llama.cpp)", err)
        }</span>

        // Initialize model registry
        <span class="cov8" title="1">registry := models.NewRegistry()

        // Determine which model to use
        var modelInfo *models.ModelInfo
        var modelPath string

        if config.Model != "" </span><span class="cov8" title="1">{
                // User specified a model
                modelInfo, exists := registry.Get(config.Model)
                if !exists </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("model not found: %s (use --list-models to see available models)", config.Model)
                }</span>

                // Check if system can run this model
                <span class="cov8" title="1">if !caps.CanRunModel(modelInfo.Parameters) </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf(
                                "insufficient resources for model %s (%dB parameters). Your system supports up to %dB parameters",
                                modelInfo.Name,
                                modelInfo.Parameters/1_000_000_000,
                                caps.MaxModelSize/1_000_000_000,
                        )
                }</span>
        } else<span class="cov8" title="1"> {
                // Auto-select best model for hardware and languages
                // Use 60% of total RAM for model selection (more realistic for dedicated model loading)
                // AvailableRAM only shows currently free memory, which is too conservative
                ramForModel := uint64(float64(caps.TotalRAM) * 0.6)

                modelInfo, err = registry.FindBestModel(
                        ramForModel,
                        []string{"en", "es"}, // English to Spanish translation (example)
                        caps.HasGPU,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to find suitable model: %w", err)
                }</span>

                <span class="cov8" title="1">fmt.Fprintf(os.Stderr, "[LLAMACPP] Auto-selected model: %s\n", modelInfo.Name)
                fmt.Fprintf(os.Stderr, "[LLAMACPP] RAM available for model: %.1f GB (60%% of %.1f GB total)\n",
                        float64(ramForModel)/(1024*1024*1024),
                        float64(caps.TotalRAM)/(1024*1024*1024))</span>
        }

        // Check if model is already downloaded
        <span class="cov8" title="1">downloader := models.NewDownloader()
        modelPath, err = downloader.GetModelPath(modelInfo)
        if err != nil </span><span class="cov8" title="1">{
                // Model not downloaded, download it now
                fmt.Fprintf(os.Stderr, "[LLAMACPP] Downloading model: %s\n", modelInfo.Name)
                fmt.Fprintf(os.Stderr, "[LLAMACPP] This may take several minutes depending on your connection...\n")

                modelPath, err = downloader.DownloadModel(modelInfo)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to download model: %w", err)
                }</span>

                <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "[LLAMACPP] Download complete: %s\n", modelPath)</span>
        } else<span class="cov0" title="0"> {
                fmt.Fprintf(os.Stderr, "[LLAMACPP] Using cached model: %s\n", modelPath)
        }</span>

        // Configure threads (use 75% of physical cores for optimal performance)
        <span class="cov0" title="0">threads := int(float64(caps.CPUCores) * 0.75)
        if threads &lt; 1 </span><span class="cov0" title="0">{
                threads = 1
        }</span>

        // Configure context size (from model info or default)
        <span class="cov0" title="0">contextSize := modelInfo.ContextLength
        if contextSize == 0 </span><span class="cov0" title="0">{
                contextSize = 8192 // Default
        }</span>

        <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "[LLAMACPP] Configuration: %d threads, %d context size\n", threads, contextSize)
        if caps.HasGPU </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "[LLAMACPP] GPU acceleration: %s\n", caps.GPUType)
        }</span>

        <span class="cov0" title="0">return &amp;LlamaCppClient{
                config:       config,
                modelPath:    modelPath,
                modelInfo:    modelInfo,
                hardwareCaps: caps,
                threads:      threads,
                contextSize:  contextSize,
                executable:   executable,
        }, nil</span>
}

// findLlamaCppExecutable locates the llama-cli executable
func findLlamaCppExecutable() (string, error) <span class="cov8" title="1">{
        // Try common locations
        candidates := []string{
                "llama-cli",                   // In PATH
                "/opt/homebrew/bin/llama-cli", // Homebrew on Apple Silicon
                "/usr/local/bin/llama-cli",    // Homebrew on Intel
                "/usr/bin/llama-cli",          // System install
                filepath.Join(os.Getenv("HOME"), ".local/bin/llama-cli"), // Local install
        }

        for _, candidate := range candidates </span><span class="cov8" title="1">{
                if path, err := exec.LookPath(candidate); err == nil </span><span class="cov8" title="1">{
                        return path, nil
                }</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("llama-cli not found in standard locations")</span>
}

// GetProviderName returns the provider name
func (c *LlamaCppClient) GetProviderName() string <span class="cov8" title="1">{
        return "llamacpp"
}</span>

// Translate translates text using llama.cpp local inference
func (c *LlamaCppClient) Translate(ctx context.Context, text string, prompt string) (string, error) <span class="cov0" title="0">{
        if text == "" || strings.TrimSpace(text) == "" </span><span class="cov0" title="0">{
                return text, nil
        }</span>

        // Build command with optimized parameters for translation
        <span class="cov0" title="0">args := []string{
                "-m", c.modelPath,
                "-p", prompt,
                "-n", "4096", // max tokens to generate (increased for book translation)
                "-t", fmt.Sprintf("%d", c.threads),
                "-c", fmt.Sprintf("%d", c.contextSize),
                "--temp", "0.3", // low temperature for consistent, accurate translation
                "--top-p", "0.9", // nucleus sampling
                "--top-k", "40", // top-k sampling
                "--repeat-penalty", "1.1", // prevent repetition
                "--no-display-prompt", // don't echo the prompt in output
        }

        // Enable GPU acceleration if available
        if c.hardwareCaps.HasGPU </span><span class="cov0" title="0">{
                switch c.hardwareCaps.GPUType </span>{
                case "metal":<span class="cov0" title="0">
                        args = append(args, "-ngl", "99")</span> // offload all layers to Metal GPU
                case "cuda":<span class="cov0" title="0">
                        args = append(args, "-ngl", "99")</span> // offload all layers to CUDA
                case "rocm":<span class="cov0" title="0">
                        args = append(args, "-ngl", "99")</span> // offload all layers to ROCm
                }
        }

        // Create command with context for cancellation
        <span class="cov0" title="0">cmd := exec.CommandContext(ctx, c.executable, args...)

        // Capture output
        var stdout, stderr bytes.Buffer
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr

        // Log the inference start
        startTime := time.Now()
        fmt.Fprintf(os.Stderr, "[LLAMACPP] Starting inference (text length: %d bytes)\n", len(text))

        // Execute
        err := cmd.Run()
        duration := time.Since(startTime)

        if err != nil </span><span class="cov0" title="0">{
                // Include stderr in error message for debugging
                stderrStr := stderr.String()
                if stderrStr != "" </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("llama.cpp execution failed: %w\nStderr: %s", err, stderrStr)
                }</span>
                <span class="cov0" title="0">return "", fmt.Errorf("llama.cpp execution failed: %w", err)</span>
        }

        <span class="cov0" title="0">result := stdout.String()

        // Log performance metrics
        tokensPerSecond := float64(len(result)) / duration.Seconds()
        fmt.Fprintf(os.Stderr, "[LLAMACPP] Inference complete: %.1f tokens/sec, duration: %v\n",
                tokensPerSecond, duration.Round(time.Millisecond))

        // Post-process: remove any prompt echo that might have slipped through
        result = strings.TrimSpace(result)

        // Remove prompt if it appears at the start
        if strings.HasPrefix(result, prompt) </span><span class="cov0" title="0">{
                result = strings.TrimPrefix(result, prompt)
                result = strings.TrimSpace(result)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// GetModelInfo returns information about the currently loaded model
func (c *LlamaCppClient) GetModelInfo() *models.ModelInfo <span class="cov0" title="0">{
        return c.modelInfo
}</span>

// GetHardwareInfo returns detected hardware capabilities
func (c *LlamaCppClient) GetHardwareInfo() *hardware.Capabilities <span class="cov0" title="0">{
        return c.hardwareCaps
}</span>

// Validate checks if the client is properly configured
func (c *LlamaCppClient) Validate() error <span class="cov0" title="0">{
        // Check if model file exists
        if _, err := os.Stat(c.modelPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("model file not found: %s", c.modelPath)
        }</span>

        // Check if executable exists
        <span class="cov0" title="0">if _, err := os.Stat(c.executable); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("llama-cli not found: %s", c.executable)
        }</span>

        // Check if we have enough RAM
        <span class="cov0" title="0">requiredRAM := c.modelInfo.MinRAM
        if c.hardwareCaps.AvailableRAM &lt; requiredRAM </span><span class="cov0" title="0">{
                return fmt.Errorf(
                        "insufficient RAM: model requires %.1f GB, but only %.1f GB available",
                        float64(requiredRAM)/(1024*1024*1024),
                        float64(c.hardwareCaps.AvailableRAM)/(1024*1024*1024),
                )
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package llm

import (
        "context"
        "digital.vasic.translator/pkg/events"
        "digital.vasic.translator/pkg/translator"
        "fmt"
        "os"
        "strings"
)

// Provider represents LLM provider types
type Provider string

const (
        ProviderOpenAI    Provider = "openai"
        ProviderAnthropic Provider = "anthropic"
        ProviderZhipu     Provider = "zhipu"
        ProviderDeepSeek  Provider = "deepseek"
        ProviderQwen      Provider = "qwen"
        ProviderGemini    Provider = "gemini"
        ProviderOllama    Provider = "ollama"
        ProviderLlamaCpp  Provider = "llamacpp"
)

// LLMTranslator implements LLM-based translation
type LLMTranslator struct {
        *translator.BaseTranslator
        provider Provider
        client   LLMClient
}

// LLMClient interface for different LLM providers
type LLMClient interface {
        Translate(ctx context.Context, text string, prompt string) (string, error)
        GetProviderName() string
}

// NewLLMTranslator creates a new LLM translator
func NewLLMTranslator(config translator.TranslationConfig) (*LLMTranslator, error) <span class="cov0" title="0">{
        provider := Provider(config.Provider)

        var client LLMClient
        var err error

        switch provider </span>{
        case ProviderOpenAI:<span class="cov0" title="0">
                client, err = NewOpenAIClient(config)</span>
        case ProviderAnthropic:<span class="cov0" title="0">
                client, err = NewAnthropicClient(config)</span>
        case ProviderZhipu:<span class="cov0" title="0">
                client, err = NewZhipuClient(config)</span>
        case ProviderDeepSeek:<span class="cov0" title="0">
                client, err = NewDeepSeekClient(config)</span>
        case ProviderQwen:<span class="cov0" title="0">
                client, err = NewQwenClient(config)</span>
        case ProviderGemini:<span class="cov0" title="0">
                client, err = NewGeminiClient(config)</span>
        case ProviderOllama:<span class="cov0" title="0">
                client, err = NewOllamaClient(config)</span>
        case ProviderLlamaCpp:<span class="cov0" title="0">
                client, err = NewLlamaCppClient(config)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported LLM provider: %s", provider)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create LLM client: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;LLMTranslator{
                BaseTranslator: translator.NewBaseTranslator(config),
                provider:       provider,
                client:         client,
        }, nil</span>
}

// GetName returns the translator name
func (lt *LLMTranslator) GetName() string <span class="cov0" title="0">{
        return fmt.Sprintf("llm-%s", lt.provider)
}</span>

// Translate translates text using LLM with automatic retry and text splitting
func (lt *LLMTranslator) Translate(ctx context.Context, text string, contextStr string) (string, error) <span class="cov0" title="0">{
        if text == "" || strings.TrimSpace(text) == "" </span><span class="cov0" title="0">{
                return text, nil
        }</span>

        // Check cache
        <span class="cov0" title="0">cacheKey := fmt.Sprintf("%s:%s", text, contextStr)
        if cached, found := lt.CheckCache(cacheKey); found </span><span class="cov0" title="0">{
                return cached, nil
        }</span>

        // Create translation prompt
        <span class="cov0" title="0">prompt := lt.createTranslationPrompt(text, contextStr)

        // Translate using LLM with smart retry
        result, err := lt.translateWithRetry(ctx, text, prompt, contextStr)
        if err != nil </span><span class="cov0" title="0">{
                lt.UpdateStats(false)
                return "", fmt.Errorf("LLM translation failed: %w", err)
        }</span>

        // Enhance translation
        <span class="cov0" title="0">result = lt.enhanceTranslation(text, result)

        // Update stats
        lt.UpdateStats(true)

        // Cache result
        lt.AddToCache(cacheKey, result)

        return result, nil</span>
}

// translateWithRetry attempts translation with automatic splitting on size errors
func (lt *LLMTranslator) translateWithRetry(ctx context.Context, text, prompt, contextStr string) (string, error) <span class="cov8" title="1">{
        // First attempt - try with full text
        result, err := lt.client.Translate(ctx, text, prompt)
        if err == nil </span><span class="cov8" title="1">{
                return result, nil
        }</span>

        // Check if error is due to text size
        <span class="cov8" title="1">if !isTextSizeError(err) </span><span class="cov8" title="1">{
                return "", err
        }</span>

        // Text is too large - split and translate in chunks
        <span class="cov8" title="1">fmt.Fprintf(os.Stderr, "[LLM_RETRY] Text too large (%d bytes), splitting into chunks\n", len(text))

        chunks := lt.splitText(text)
        if len(chunks) == 1 </span><span class="cov0" title="0">{
                // Cannot split further - text is too large even for one sentence
                return "", fmt.Errorf("text too large to translate even after splitting (min chunk: %d bytes): %w", len(chunks[0]), err)
        }</span>

        <span class="cov8" title="1">fmt.Fprintf(os.Stderr, "[LLM_RETRY] Split into %d chunks, translating separately\n", len(chunks))

        // Translate each chunk
        var translatedChunks []string
        for i, chunk := range chunks </span><span class="cov8" title="1">{
                chunkPrompt := lt.createTranslationPrompt(chunk, fmt.Sprintf("%s (part %d/%d)", contextStr, i+1, len(chunks)))

                chunkResult, chunkErr := lt.client.Translate(ctx, chunk, chunkPrompt)
                if chunkErr != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to translate chunk %d/%d: %w", i+1, len(chunks), chunkErr)
                }</span>

                <span class="cov8" title="1">translatedChunks = append(translatedChunks, chunkResult)</span>
        }

        // Combine translated chunks
        <span class="cov8" title="1">result = strings.Join(translatedChunks, "")
        fmt.Fprintf(os.Stderr, "[LLM_RETRY] Successfully translated %d chunks\n", len(chunks))

        return result, nil</span>
}

// isTextSizeError checks if error is due to text being too large
func isTextSizeError(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">errStr := strings.ToLower(err.Error())

        // Common size-related error patterns
        sizeErrorPatterns := []string{
                "max_tokens",
                "token limit",
                "too large",
                "too long",
                "maximum length",
                "context length",
                "exceeds",
                "invalid request",
        }

        for _, pattern := range sizeErrorPatterns </span><span class="cov8" title="1">{
                if strings.Contains(errStr, pattern) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// splitText splits text into smaller chunks at sentence boundaries
func (lt *LLMTranslator) splitText(text string) []string <span class="cov8" title="1">{
        // Target chunk size (roughly 20KB to stay well under limits)
        const maxChunkSize = 20000

        // If text is small enough, return as-is
        if len(text) &lt;= maxChunkSize </span><span class="cov8" title="1">{
                return []string{text}
        }</span>

        <span class="cov8" title="1">var chunks []string
        var currentChunk strings.Builder

        // Split by paragraphs first
        paragraphs := strings.Split(text, "\n\n")

        for _, para := range paragraphs </span><span class="cov8" title="1">{
                // If single paragraph is too large, split by sentences
                if len(para) &gt; maxChunkSize </span><span class="cov8" title="1">{
                        sentences := lt.splitBySentences(para)
                        for _, sentence := range sentences </span><span class="cov8" title="1">{
                                if currentChunk.Len()+len(sentence) &gt; maxChunkSize &amp;&amp; currentChunk.Len() &gt; 0 </span><span class="cov8" title="1">{
                                        // Current chunk is full, start new chunk
                                        chunks = append(chunks, currentChunk.String())
                                        currentChunk.Reset()
                                }</span>
                                <span class="cov8" title="1">currentChunk.WriteString(sentence)</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Add paragraph to current chunk
                        if currentChunk.Len()+len(para)+2 &gt; maxChunkSize &amp;&amp; currentChunk.Len() &gt; 0 </span><span class="cov0" title="0">{
                                // Current chunk is full, start new chunk
                                chunks = append(chunks, currentChunk.String())
                                currentChunk.Reset()
                        }</span>
                        <span class="cov0" title="0">if currentChunk.Len() &gt; 0 </span><span class="cov0" title="0">{
                                currentChunk.WriteString("\n\n")
                        }</span>
                        <span class="cov0" title="0">currentChunk.WriteString(para)</span>
                }
        }

        // Add final chunk
        <span class="cov8" title="1">if currentChunk.Len() &gt; 0 </span><span class="cov8" title="1">{
                chunks = append(chunks, currentChunk.String())
        }</span>

        <span class="cov8" title="1">return chunks</span>
}

// splitBySentences splits text into sentences
func (lt *LLMTranslator) splitBySentences(text string) []string <span class="cov8" title="1">{
        var sentences []string
        var currentSentence strings.Builder

        runes := []rune(text)
        for i := 0; i &lt; len(runes); i++ </span><span class="cov8" title="1">{
                currentSentence.WriteRune(runes[i])

                // Check for sentence endings
                if runes[i] == '.' || runes[i] == '!' || runes[i] == '?' || runes[i] == '‚Ä¶' </span><span class="cov8" title="1">{
                        // Check if followed by space or end of text
                        if i+1 &gt;= len(runes) || runes[i+1] == ' ' || runes[i+1] == '\n' </span><span class="cov8" title="1">{
                                sentences = append(sentences, currentSentence.String())
                                currentSentence.Reset()
                        }</span>
                }
        }

        // Add remaining text
        <span class="cov8" title="1">if currentSentence.Len() &gt; 0 </span><span class="cov8" title="1">{
                sentences = append(sentences, currentSentence.String())
        }</span>

        <span class="cov8" title="1">return sentences</span>
}

// TranslateWithProgress translates and reports progress
func (lt *LLMTranslator) TranslateWithProgress(
        ctx context.Context,
        text string,
        contextStr string,
        eventBus *events.EventBus,
        sessionID string,
) (string, error) <span class="cov0" title="0">{
        translator.EmitProgress(eventBus, sessionID, "Starting LLM translation", map[string]interface{}{
                "provider":    string(lt.provider),
                "text_length": len(text),
        })

        result, err := lt.Translate(ctx, text, contextStr)

        if err != nil </span><span class="cov0" title="0">{
                // Log detailed error to stdout for debugging
                fmt.Fprintf(os.Stderr, "[LLM_ERROR] Translation failed: %v\n", err)
                fmt.Fprintf(os.Stderr, "[LLM_ERROR] Text length: %d bytes, Context: %s\n", len(text), contextStr)
                translator.EmitError(eventBus, sessionID, "LLM translation failed", err)
                return "", err
        }</span>

        <span class="cov0" title="0">translator.EmitProgress(eventBus, sessionID, "LLM translation completed", map[string]interface{}{
                "provider":          string(lt.provider),
                "original_length":   len(text),
                "translated_length": len(result),
        })

        return result, nil</span>
}

// createTranslationPrompt creates the translation prompt
func (lt *LLMTranslator) createTranslationPrompt(text string, contextStr string) string <span class="cov8" title="1">{
        context := contextStr
        if context == "" </span><span class="cov0" title="0">{
                context = "Literary text"
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf(`You are a professional literary translator specializing in Russian to Serbian translation.
Your task is to translate the following Russian text into natural, idiomatic Serbian.

Guidelines:
1. Preserve the literary style and tone
2. Use appropriate Serbian vocabulary and grammar
3. Maintain cultural nuances and idioms
4. Keep names of people and places unchanged unless they have standard Serbian equivalents
5. Preserve formatting, punctuation, and paragraph structure
6. Use Serbian Cyrillic script (—õ–∏—Ä–∏–ª–∏—Ü–∞)
7. **CRITICAL**: Use ONLY Ekavica dialect (–µ–∫–∞–≤–∏—Ü–∞) - the standard Serbian dialect used in Serbia
   - Use "–µ" instead of "–∏—ò–µ/—ò–µ": mleko (not mlijeko), dete (not dijete), pesma (not pjesma)
   - Ekavica examples: hteo (not htio), lepo (not lijepo), reka (not rijeka)
   - This is MANDATORY for all translations to Serbian
8. **CRITICAL**: Use ONLY pure Serbian vocabulary - avoid Croatian, Bosnian, or Montenegrin words
   - Use standard Serbian words preferred in Serbia, not regional variants
   - Example: use "avion" (not Croatian "zrakoplov"), "pozori≈°te" (not Croatian "kazali≈°te")

Context: %s

Russian text:
%s

Serbian translation (Ekavica only):`, context, text)</span>
}

// enhanceTranslation post-processes the translation
func (lt *LLMTranslator) enhanceTranslation(original, translated string) string <span class="cov0" title="0">{
        enhanced := translated

        // Fix common punctuation issues
        enhanced = strings.ReplaceAll(enhanced, "\u201c", "\"")
        enhanced = strings.ReplaceAll(enhanced, "\u201d", "\"")
        enhanced = strings.ReplaceAll(enhanced, "\u2018", "'")

        // Preserve paragraph structure
        if strings.HasSuffix(original, "\n") &amp;&amp; !strings.HasSuffix(enhanced, "\n") </span><span class="cov0" title="0">{
                enhanced += "\n"
        }</span>

        // Fix sentence capitalization
        <span class="cov0" title="0">if len(enhanced) &gt; 0 &amp;&amp; len(original) &gt; 0 </span><span class="cov0" title="0">{
                if isLower(rune(enhanced[0])) &amp;&amp; isUpper(rune(original[0])) </span><span class="cov0" title="0">{
                        runes := []rune(enhanced)
                        runes[0] = toUpper(runes[0])
                        enhanced = string(runes)
                }</span>
        }

        <span class="cov0" title="0">return enhanced</span>
}

// Helper functions
func isLower(r rune) bool <span class="cov0" title="0">{
        return r &gt;= 'a' &amp;&amp; r &lt;= 'z'
}</span>

func isUpper(r rune) bool <span class="cov0" title="0">{
        return r &gt;= 'A' &amp;&amp; r &lt;= 'Z'
}</span>

func toUpper(r rune) rune <span class="cov0" title="0">{
        if isLower(r) </span><span class="cov0" title="0">{
                return r - 32
        }</span>
        <span class="cov0" title="0">return r</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package llm

import (
        "bytes"
        "context"
        "digital.vasic.translator/pkg/translator"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "time"
)

// OllamaClient implements Ollama API client (local LLM)
type OllamaClient struct {
        config     translator.TranslationConfig
        httpClient *http.Client
        baseURL    string
}

// OllamaRequest represents Ollama API request
type OllamaRequest struct {
        Model  string `json:"model"`
        Prompt string `json:"prompt"`
        Stream bool   `json:"stream"`
}

// OllamaResponse represents Ollama API response
type OllamaResponse struct {
        Model     string    `json:"model"`
        CreatedAt time.Time `json:"created_at"`
        Response  string    `json:"response"`
        Done      bool      `json:"done"`
}

// NewOllamaClient creates a new Ollama client
func NewOllamaClient(config translator.TranslationConfig) (*OllamaClient, error) <span class="cov0" title="0">{
        baseURL := config.BaseURL
        if baseURL == "" </span><span class="cov0" title="0">{
                baseURL = "http://localhost:11434"
        }</span>

        <span class="cov0" title="0">return &amp;OllamaClient{
                config: config,
                httpClient: &amp;http.Client{
                        Timeout: 600 * time.Second, // Increased to 10 minutes for very large book sections (up to 44KB)
                },
                baseURL: baseURL,
        }, nil</span>
}

// GetProviderName returns the provider name
func (c *OllamaClient) GetProviderName() string <span class="cov0" title="0">{
        return "ollama"
}</span>

// Translate translates text using Ollama
func (c *OllamaClient) Translate(ctx context.Context, text string, prompt string) (string, error) <span class="cov0" title="0">{
        model := c.config.Model
        if model == "" </span><span class="cov0" title="0">{
                model = "llama3:8b"
        }</span>

        <span class="cov0" title="0">request := OllamaRequest{
                Model:  model,
                Prompt: prompt,
                Stream: false,
        }

        jsonData, err := json.Marshal(request)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, "POST", c.baseURL+"/api/generate", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")

        resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to send request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return "", fmt.Errorf("Ollama API error (status %d): %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var response OllamaResponse
        if err := json.Unmarshal(body, &amp;response); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to unmarshal response: %w", err)
        }</span>

        <span class="cov0" title="0">return response.Response, nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package llm

import (
        "bytes"
        "context"
        "digital.vasic.translator/pkg/translator"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "time"
)

// OpenAIClient implements OpenAI API client
type OpenAIClient struct {
        config     translator.TranslationConfig
        httpClient *http.Client
        baseURL    string
}

// OpenAIRequest represents OpenAI API request
type OpenAIRequest struct {
        Model       string    `json:"model"`
        Messages    []Message `json:"messages"`
        Temperature float64   `json:"temperature"`
        MaxTokens   int       `json:"max_tokens,omitempty"`
}

// Message represents a chat message
type Message struct {
        Role    string `json:"role"`
        Content string `json:"content"`
}

// OpenAIResponse represents OpenAI API response
type OpenAIResponse struct {
        ID      string   `json:"id"`
        Object  string   `json:"object"`
        Created int64    `json:"created"`
        Model   string   `json:"model"`
        Choices []Choice `json:"choices"`
        Usage   Usage    `json:"usage"`
}

// Choice represents a response choice
type Choice struct {
        Index        int     `json:"index"`
        Message      Message `json:"message"`
        FinishReason string  `json:"finish_reason"`
}

// Usage represents token usage
type Usage struct {
        PromptTokens     int `json:"prompt_tokens"`
        CompletionTokens int `json:"completion_tokens"`
        TotalTokens      int `json:"total_tokens"`
}

// NewOpenAIClient creates a new OpenAI client
func NewOpenAIClient(config translator.TranslationConfig) (*OpenAIClient, error) <span class="cov0" title="0">{
        if config.APIKey == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("OpenAI API key is required")
        }</span>

        <span class="cov0" title="0">baseURL := config.BaseURL
        if baseURL == "" </span><span class="cov0" title="0">{
                baseURL = "https://api.openai.com/v1"
        }</span>

        <span class="cov0" title="0">return &amp;OpenAIClient{
                config: config,
                httpClient: &amp;http.Client{
                        Timeout: 600 * time.Second, // Increased to 10 minutes for very large book sections (up to 44KB)
                },
                baseURL: baseURL,
        }, nil</span>
}

// GetProviderName returns the provider name
func (c *OpenAIClient) GetProviderName() string <span class="cov0" title="0">{
        return "openai"
}</span>

// Translate translates text using OpenAI
func (c *OpenAIClient) Translate(ctx context.Context, text string, prompt string) (string, error) <span class="cov0" title="0">{
        model := c.config.Model
        if model == "" </span><span class="cov0" title="0">{
                model = "gpt-4"
        }</span>

        <span class="cov0" title="0">temperature := c.config.Options["temperature"]
        if temperature == nil </span><span class="cov0" title="0">{
                temperature = 0.3
        }</span>

        // Increase max_tokens for large translations (book sections can be very long)
        // DeepSeek/OpenAI compatible models support up to 8192 max_tokens
        <span class="cov0" title="0">maxTokens := 8192 // Increased from 4000 to handle book chapters (DeepSeek max)
        if c.config.Options["max_tokens"] != nil </span><span class="cov0" title="0">{
                if mt, ok := c.config.Options["max_tokens"].(int); ok </span><span class="cov0" title="0">{
                        maxTokens = mt
                }</span>
        }

        <span class="cov0" title="0">request := OpenAIRequest{
                Model: model,
                Messages: []Message{
                        {Role: "user", Content: prompt},
                },
                Temperature: temperature.(float64),
                MaxTokens:   maxTokens,
        }

        jsonData, err := json.Marshal(request)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, "POST", c.baseURL+"/chat/completions", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+c.config.APIKey)

        resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to send request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return "", fmt.Errorf("OpenAI API error (status %d): %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var response OpenAIResponse
        if err := json.Unmarshal(body, &amp;response); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to unmarshal response: %w", err)
        }</span>

        <span class="cov0" title="0">if len(response.Choices) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no choices in response")
        }</span>

        <span class="cov0" title="0">return response.Choices[0].Message.Content, nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package llm

import (
        "bytes"
        "context"
        "digital.vasic.translator/pkg/translator"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "os"
        "path/filepath"
        "time"
)

// QwenClient implements Qwen (Alibaba Cloud) LLM API client with OAuth support
type QwenClient struct {
        config       translator.TranslationConfig
        httpClient   *http.Client
        baseURL      string
        oauthToken   *QwenOAuthToken
        credFilePath string
}

// QwenOAuthToken represents OAuth credentials for Qwen
type QwenOAuthToken struct {
        AccessToken  string `json:"access_token"`
        TokenType    string `json:"token_type"`
        RefreshToken string `json:"refresh_token"`
        ResourceURL  string `json:"resource_url"`
        ExpiryDate   int64  `json:"expiry_date"`
}

// QwenRequest represents Qwen API request
type QwenRequest struct {
        Model      string        `json:"model"`
        Messages   []QwenMessage `json:"messages"`
        Stream     bool          `json:"stream"`
        MaxTokens  int           `json:"max_tokens,omitempty"`
        Temperature float64      `json:"temperature,omitempty"`
}

// QwenMessage represents a message
type QwenMessage struct {
        Role    string `json:"role"`
        Content string `json:"content"`
}

// QwenResponse represents Qwen API response
type QwenResponse struct {
        ID      string       `json:"id"`
        Created int64        `json:"created"`
        Model   string       `json:"model"`
        Choices []QwenChoice `json:"choices"`
        Usage   QwenUsage    `json:"usage"`
}

// QwenChoice represents a response choice
type QwenChoice struct {
        Index        int         `json:"index"`
        Message      QwenMessage `json:"message"`
        FinishReason string      `json:"finish_reason"`
}

// QwenUsage represents token usage
type QwenUsage struct {
        PromptTokens     int `json:"prompt_tokens"`
        CompletionTokens int `json:"completion_tokens"`
        TotalTokens      int `json:"total_tokens"`
}

// NewQwenClient creates a new Qwen client with OAuth support
func NewQwenClient(config translator.TranslationConfig) (*QwenClient, error) <span class="cov0" title="0">{
        credDir := os.Getenv("HOME")
        if credDir == "" </span><span class="cov0" title="0">{
                credDir = "."
        }</span>

        // Primary location for translator-specific credentials
        <span class="cov0" title="0">credFile := filepath.Join(credDir, ".translator", "qwen_credentials.json")

        baseURL := config.BaseURL
        if baseURL == "" </span><span class="cov0" title="0">{
                baseURL = "https://dashscope.aliyuncs.com/api/v1"
        }</span>

        <span class="cov0" title="0">client := &amp;QwenClient{
                config:       config,
                httpClient:   &amp;http.Client{Timeout: 600 * time.Second}, // Increased to 10 minutes for very large book sections (up to 44KB)
                baseURL:      baseURL,
                credFilePath: credFile,
        }

        // Load OAuth token from file or use API key
        if config.APIKey != "" </span><span class="cov0" title="0">{
                // API key provided - use it directly
                return client, nil
        }</span>

        // Try loading OAuth token from translator-specific location
        <span class="cov0" title="0">if err := client.loadOAuthToken(); err != nil </span><span class="cov0" title="0">{
                // Try Qwen Code standard location as fallback
                qwenCodeCredFile := filepath.Join(credDir, ".qwen", "oauth_creds.json")
                client.credFilePath = qwenCodeCredFile
                if err := client.loadOAuthToken(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("no API key or valid OAuth token found: %w\nPlease set QWEN_API_KEY environment variable or authenticate via OAuth", err)
                }</span>
        }

        // Note: We don't pre-emptively refresh expired tokens on initialization
        // Instead, we'll attempt to use the token and only refresh if we get a 401 error
        // This allows tokens to work even if the expiry date calculation is off
        <span class="cov0" title="0">if client.isTokenExpired() </span><span class="cov0" title="0">{
                // Log warning but continue - will refresh on 401
                fmt.Fprintf(os.Stderr, "Warning: Qwen OAuth token appears expired, will attempt to use it anyway\n")
        }</span>

        <span class="cov0" title="0">return client, nil</span>
}

// loadOAuthToken loads OAuth token from credentials file
func (c *QwenClient) loadOAuthToken() error <span class="cov0" title="0">{
        data, err := os.ReadFile(c.credFilePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read credentials file: %w", err)
        }</span>

        <span class="cov0" title="0">var token QwenOAuthToken
        if err := json.Unmarshal(data, &amp;token); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse credentials: %w", err)
        }</span>

        <span class="cov0" title="0">c.oauthToken = &amp;token
        return nil</span>
}

// saveOAuthToken saves OAuth token to credentials file
func (c *QwenClient) saveOAuthToken(token *QwenOAuthToken) error <span class="cov0" title="0">{
        // Ensure directory exists
        dir := filepath.Dir(c.credFilePath)
        if err := os.MkdirAll(dir, 0700); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create credentials directory: %w", err)
        }</span>

        <span class="cov0" title="0">data, err := json.MarshalIndent(token, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal credentials: %w", err)
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(c.credFilePath, data, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write credentials file: %w", err)
        }</span>

        <span class="cov0" title="0">c.oauthToken = token
        return nil</span>
}

// SetOAuthToken sets OAuth token from external source (e.g., OAuth flow)
func (c *QwenClient) SetOAuthToken(accessToken, refreshToken, resourceURL string, expiryDate int64) error <span class="cov0" title="0">{
        token := &amp;QwenOAuthToken{
                AccessToken:  accessToken,
                TokenType:    "Bearer",
                RefreshToken: refreshToken,
                ResourceURL:  resourceURL,
                ExpiryDate:   expiryDate,
        }
        return c.saveOAuthToken(token)
}</span>

// isTokenExpired checks if the OAuth token is expired
func (c *QwenClient) isTokenExpired() bool <span class="cov0" title="0">{
        if c.oauthToken == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        // Consider token expired if less than 5 minutes until expiry
        <span class="cov0" title="0">return time.Now().Unix() &gt; (c.oauthToken.ExpiryDate/1000 - 300)</span>
}

// refreshToken refreshes the OAuth token
func (c *QwenClient) refreshToken() error <span class="cov0" title="0">{
        if c.oauthToken == nil || c.oauthToken.RefreshToken == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("no refresh token available")
        }</span>

        // Note: Actual refresh endpoint would need to be provided by Qwen documentation
        // This is a placeholder implementation
        <span class="cov0" title="0">return fmt.Errorf("token refresh not yet implemented - please re-authenticate")</span>
}

// GetProviderName returns the provider name
func (c *QwenClient) GetProviderName() string <span class="cov0" title="0">{
        return "qwen"
}</span>

// Translate translates text using Qwen (Alibaba Cloud) LLM
func (c *QwenClient) Translate(ctx context.Context, text string, prompt string) (string, error) <span class="cov0" title="0">{
        model := c.config.Model
        if model == "" </span><span class="cov0" title="0">{
                model = "qwen-plus" // Default model
        }</span>

        <span class="cov0" title="0">temperature := 0.3
        if c.config.Options["temperature"] != nil </span><span class="cov0" title="0">{
                if t, ok := c.config.Options["temperature"].(float64); ok </span><span class="cov0" title="0">{
                        temperature = t
                }</span>
        }

        <span class="cov0" title="0">maxTokens := 4000
        if c.config.Options["max_tokens"] != nil </span><span class="cov0" title="0">{
                if mt, ok := c.config.Options["max_tokens"].(int); ok </span><span class="cov0" title="0">{
                        maxTokens = mt
                }</span>
        }

        <span class="cov0" title="0">request := QwenRequest{
                Model: model,
                Messages: []QwenMessage{
                        {Role: "user", Content: prompt},
                },
                Stream:      false,
                Temperature: temperature,
                MaxTokens:   maxTokens,
        }

        jsonData, err := json.Marshal(request)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, "POST", c.baseURL+"/services/aigc/text-generation/generation", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")

        // Use OAuth token or API key
        if c.config.APIKey != "" </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", "Bearer "+c.config.APIKey)
        }</span> else<span class="cov0" title="0"> if c.oauthToken != nil </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", c.oauthToken.TokenType+" "+c.oauthToken.AccessToken)
        }</span> else<span class="cov0" title="0"> {
                return "", fmt.Errorf("no authentication credentials available")
        }</span>

        <span class="cov0" title="0">resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to send request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                // Check if token expired
                if resp.StatusCode == http.StatusUnauthorized &amp;&amp; c.oauthToken != nil </span><span class="cov0" title="0">{
                        if err := c.refreshToken(); err == nil </span><span class="cov0" title="0">{
                                // Retry with refreshed token
                                return c.Translate(ctx, text, prompt)
                        }</span>
                }
                <span class="cov0" title="0">return "", fmt.Errorf("Qwen API error (status %d): %s", resp.StatusCode, string(body))</span>
        }

        <span class="cov0" title="0">var response QwenResponse
        if err := json.Unmarshal(body, &amp;response); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to unmarshal response: %w", err)
        }</span>

        <span class="cov0" title="0">if len(response.Choices) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no choices in response")
        }</span>

        <span class="cov0" title="0">return response.Choices[0].Message.Content, nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package llm

import (
        "bytes"
        "context"
        "digital.vasic.translator/pkg/translator"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "time"
)

// ZhipuClient implements Zhipu AI (GLM) API client
type ZhipuClient struct {
        config     translator.TranslationConfig
        httpClient *http.Client
        baseURL    string
}

// ZhipuRequest represents Zhipu API request
type ZhipuRequest struct {
        Model       string          `json:"model"`
        Messages    []ZhipuMessage  `json:"messages"`
        Temperature float64         `json:"temperature,omitempty"`
        MaxTokens   int             `json:"max_tokens,omitempty"`
}

// ZhipuMessage represents a message
type ZhipuMessage struct {
        Role    string `json:"role"`
        Content string `json:"content"`
}

// ZhipuResponse represents Zhipu API response
type ZhipuResponse struct {
        ID      string        `json:"id"`
        Created int64         `json:"created"`
        Model   string        `json:"model"`
        Choices []ZhipuChoice `json:"choices"`
        Usage   ZhipuUsage    `json:"usage"`
}

// ZhipuChoice represents a response choice
type ZhipuChoice struct {
        Index        int          `json:"index"`
        Message      ZhipuMessage `json:"message"`
        FinishReason string       `json:"finish_reason"`
}

// ZhipuUsage represents token usage
type ZhipuUsage struct {
        PromptTokens     int `json:"prompt_tokens"`
        CompletionTokens int `json:"completion_tokens"`
        TotalTokens      int `json:"total_tokens"`
}

// NewZhipuClient creates a new Zhipu client
func NewZhipuClient(config translator.TranslationConfig) (*ZhipuClient, error) <span class="cov0" title="0">{
        if config.APIKey == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Zhipu API key is required")
        }</span>

        <span class="cov0" title="0">baseURL := config.BaseURL
        if baseURL == "" </span><span class="cov0" title="0">{
                baseURL = "https://open.bigmodel.cn/api/paas/v4"
        }</span>

        <span class="cov0" title="0">return &amp;ZhipuClient{
                config: config,
                httpClient: &amp;http.Client{
                        Timeout: 600 * time.Second, // Increased to 10 minutes for very large book sections (up to 44KB)
                },
                baseURL: baseURL,
        }, nil</span>
}

// GetProviderName returns the provider name
func (c *ZhipuClient) GetProviderName() string <span class="cov0" title="0">{
        return "zhipu"
}</span>

// Translate translates text using Zhipu AI
func (c *ZhipuClient) Translate(ctx context.Context, text string, prompt string) (string, error) <span class="cov0" title="0">{
        model := c.config.Model
        if model == "" </span><span class="cov0" title="0">{
                model = "glm-4"
        }</span>

        <span class="cov0" title="0">temperature := 0.3
        if c.config.Options["temperature"] != nil </span><span class="cov0" title="0">{
                if t, ok := c.config.Options["temperature"].(float64); ok </span><span class="cov0" title="0">{
                        temperature = t
                }</span>
        }

        <span class="cov0" title="0">maxTokens := 4000
        if c.config.Options["max_tokens"] != nil </span><span class="cov0" title="0">{
                if mt, ok := c.config.Options["max_tokens"].(int); ok </span><span class="cov0" title="0">{
                        maxTokens = mt
                }</span>
        }

        <span class="cov0" title="0">request := ZhipuRequest{
                Model: model,
                Messages: []ZhipuMessage{
                        {Role: "user", Content: prompt},
                },
                Temperature: temperature,
                MaxTokens:   maxTokens,
        }

        jsonData, err := json.Marshal(request)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, "POST", c.baseURL+"/chat/completions", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+c.config.APIKey)

        resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to send request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return "", fmt.Errorf("Zhipu API error (status %d): %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var response ZhipuResponse
        if err := json.Unmarshal(body, &amp;response); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to unmarshal response: %w", err)
        }</span>

        <span class="cov0" title="0">if len(response.Choices) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no choices in response")
        }</span>

        <span class="cov0" title="0">return response.Choices[0].Message.Content, nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package translator

import (
        "context"
        "errors"
        "digital.vasic.translator/pkg/events"
)

var (
        // ErrNoLLMInstances is returned when no LLM instances are available
        ErrNoLLMInstances = errors.New("no LLM instances available")

        // ErrInvalidProvider is returned when an invalid provider is specified
        ErrInvalidProvider = errors.New("invalid translation provider")
)

// TranslationConfig holds translation configuration
type TranslationConfig struct {
        SourceLang     string
        TargetLang     string
        SourceLanguage string // Alias for SourceLang
        TargetLanguage string // Alias for TargetLang
        Provider       string
        Model          string
        APIKey         string
        BaseURL        string
        Script         string // Script type (cyrillic, latin)
        Options        map[string]interface{}
}

// TranslationResult holds the result of a translation
type TranslationResult struct {
        OriginalText  string
        TranslatedText string
        Provider      string
        Cached        bool
        Error         error
}

// TranslationStats tracks translation statistics
type TranslationStats struct {
        Total      int
        Translated int
        Cached     int
        Errors     int
}

// Translator interface defines translation methods
type Translator interface {
        // Translate translates text with optional context
        Translate(ctx context.Context, text string, context string) (string, error)

        // TranslateWithProgress translates and reports progress via events
        TranslateWithProgress(ctx context.Context, text string, context string, eventBus *events.EventBus, sessionID string) (string, error)

        // GetStats returns translation statistics
        GetStats() TranslationStats

        // GetName returns the translator name
        GetName() string
}

// BaseTranslator provides common functionality
type BaseTranslator struct {
        config TranslationConfig
        stats  TranslationStats
        cache  map[string]string
}

// NewBaseTranslator creates a new base translator
func NewBaseTranslator(config TranslationConfig) *BaseTranslator <span class="cov8" title="1">{
        return &amp;BaseTranslator{
                config: config,
                stats:  TranslationStats{},
                cache:  make(map[string]string),
        }
}</span>

// GetStats returns translation statistics
func (bt *BaseTranslator) GetStats() TranslationStats <span class="cov0" title="0">{
        return bt.stats
}</span>

// CheckCache checks if translation is cached
func (bt *BaseTranslator) CheckCache(text string) (string, bool) <span class="cov0" title="0">{
        if translated, ok := bt.cache[text]; ok </span><span class="cov0" title="0">{
                bt.stats.Cached++
                return translated, true
        }</span>
        <span class="cov0" title="0">return "", false</span>
}

// AddToCache adds a translation to cache
func (bt *BaseTranslator) AddToCache(original, translated string) <span class="cov0" title="0">{
        bt.cache[original] = translated
}</span>

// UpdateStats updates translation statistics
func (bt *BaseTranslator) UpdateStats(success bool) <span class="cov0" title="0">{
        bt.stats.Total++
        if success </span><span class="cov0" title="0">{
                bt.stats.Translated++
        }</span> else<span class="cov0" title="0"> {
                bt.stats.Errors++
        }</span>
}

// EmitProgress emits a progress event
func EmitProgress(eventBus *events.EventBus, sessionID, message string, data map[string]interface{}) <span class="cov0" title="0">{
        if eventBus == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">event := events.NewEvent(events.EventTranslationProgress, message, data)
        event.SessionID = sessionID
        eventBus.Publish(event)</span>
}

// EmitError emits an error event
func EmitError(eventBus *events.EventBus, sessionID, message string, err error) <span class="cov0" title="0">{
        if eventBus == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">data := map[string]interface{}{
                "error": err.Error(),
        }

        event := events.NewEvent(events.EventTranslationError, message, data)
        event.SessionID = sessionID
        eventBus.Publish(event)</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package translator

import (
        "context"
        "digital.vasic.translator/pkg/ebook"
        "digital.vasic.translator/pkg/events"
        "digital.vasic.translator/pkg/language"
        "fmt"
)

// UniversalTranslator handles translation of complete ebooks
type UniversalTranslator struct {
        translator     Translator
        langDetector   *language.Detector
        sourceLanguage language.Language
        targetLanguage language.Language
}

// NewUniversalTranslator creates a new universal translator
func NewUniversalTranslator(
        translator Translator,
        langDetector *language.Detector,
        sourceLang, targetLang language.Language,
) *UniversalTranslator <span class="cov0" title="0">{
        return &amp;UniversalTranslator{
                translator:     translator,
                langDetector:   langDetector,
                sourceLanguage: sourceLang,
                targetLanguage: targetLang,
        }
}</span>

// TranslateBook translates an entire ebook
func (ut *UniversalTranslator) TranslateBook(
        ctx context.Context,
        book *ebook.Book,
        eventBus *events.EventBus,
        sessionID string,
) error <span class="cov0" title="0">{
        // Detect source language if not specified
        if ut.sourceLanguage.Code == "" &amp;&amp; ut.langDetector != nil </span><span class="cov0" title="0">{
                EmitProgress(eventBus, sessionID, "Detecting source language", nil)

                sample := book.ExtractText()
                if len(sample) &gt; 2000 </span><span class="cov0" title="0">{
                        sample = sample[:2000]
                }</span>

                <span class="cov0" title="0">detectedLang, err := ut.langDetector.Detect(ctx, sample)
                if err == nil </span><span class="cov0" title="0">{
                        ut.sourceLanguage = detectedLang
                        EmitProgress(eventBus, sessionID,
                                fmt.Sprintf("Detected language: %s", detectedLang.Name),
                                map[string]interface{}{
                                        "language_code": detectedLang.Code,
                                        "language_name": detectedLang.Name,
                                })
                }</span>
        }

        // Update metadata language
        <span class="cov0" title="0">if book.Metadata.Language == "" </span><span class="cov0" title="0">{
                book.Metadata.Language = ut.targetLanguage.Code
        }</span>

        // Translate metadata
        <span class="cov0" title="0">EmitProgress(eventBus, sessionID, "Translating metadata", nil)
        if err := ut.translateMetadata(ctx, &amp;book.Metadata, eventBus, sessionID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to translate metadata: %w", err)
        }</span>

        // Translate chapters
        <span class="cov0" title="0">totalChapters := len(book.Chapters)
        for i := range book.Chapters </span><span class="cov0" title="0">{
                EmitProgress(eventBus, sessionID,
                        fmt.Sprintf("Translating chapter %d/%d", i+1, totalChapters),
                        map[string]interface{}{
                                "chapter":       i + 1,
                                "total_chapters": totalChapters,
                                "progress":      float64(i+1) / float64(totalChapters) * 100,
                        })

                if err := ut.translateChapter(ctx, &amp;book.Chapters[i], eventBus, sessionID); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to translate chapter %d: %w", i+1, err)
                }</span>
        }

        // Update book language
        <span class="cov0" title="0">book.Metadata.Language = ut.targetLanguage.Code

        return nil</span>
}

// translateMetadata translates book metadata
func (ut *UniversalTranslator) translateMetadata(
        ctx context.Context,
        metadata *ebook.Metadata,
        eventBus *events.EventBus,
        sessionID string,
) error <span class="cov0" title="0">{
        // Translate title
        if metadata.Title != "" </span><span class="cov0" title="0">{
                translated, err := ut.translator.TranslateWithProgress(
                        ctx,
                        metadata.Title,
                        "Book title",
                        eventBus,
                        sessionID,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to translate title: %w", err)
                }</span>
                <span class="cov0" title="0">metadata.Title = translated</span>
        }

        // Translate description
        <span class="cov0" title="0">if metadata.Description != "" </span><span class="cov0" title="0">{
                translated, err := ut.translator.TranslateWithProgress(
                        ctx,
                        metadata.Description,
                        "Book description",
                        eventBus,
                        sessionID,
                )
                if err != nil </span><span class="cov0" title="0">{
                        EmitProgress(eventBus, sessionID, "Warning: Failed to translate description", map[string]interface{}{"error": err.Error()})
                }</span> else<span class="cov0" title="0"> {
                        metadata.Description = translated
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// translateChapter translates a chapter
func (ut *UniversalTranslator) translateChapter(
        ctx context.Context,
        chapter *ebook.Chapter,
        eventBus *events.EventBus,
        sessionID string,
) error <span class="cov0" title="0">{
        // Translate chapter title
        if chapter.Title != "" </span><span class="cov0" title="0">{
                translated, err := ut.translator.TranslateWithProgress(
                        ctx,
                        chapter.Title,
                        "Chapter title",
                        eventBus,
                        sessionID,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to translate chapter title: %w", err)
                }</span>
                <span class="cov0" title="0">chapter.Title = translated</span>
        }

        // Translate sections
        <span class="cov0" title="0">for i := range chapter.Sections </span><span class="cov0" title="0">{
                if err := ut.translateSection(ctx, &amp;chapter.Sections[i], eventBus, sessionID); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// translateSection translates a section recursively
func (ut *UniversalTranslator) translateSection(
        ctx context.Context,
        section *ebook.Section,
        eventBus *events.EventBus,
        sessionID string,
) error <span class="cov0" title="0">{
        // Translate section title
        if section.Title != "" </span><span class="cov0" title="0">{
                translated, err := ut.translator.TranslateWithProgress(
                        ctx,
                        section.Title,
                        "Section title",
                        eventBus,
                        sessionID,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to translate section title: %w", err)
                }</span>
                <span class="cov0" title="0">section.Title = translated</span>
        }

        // Translate content
        <span class="cov0" title="0">if section.Content != "" </span><span class="cov0" title="0">{
                translated, err := ut.translator.TranslateWithProgress(
                        ctx,
                        section.Content,
                        "Section content",
                        eventBus,
                        sessionID,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to translate section content: %w", err)
                }</span>
                <span class="cov0" title="0">section.Content = translated</span>
        }

        // Translate subsections
        <span class="cov0" title="0">for i := range section.Subsections </span><span class="cov0" title="0">{
                if err := ut.translateSection(ctx, &amp;section.Subsections[i], eventBus, sessionID); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetSourceLanguage returns the source language
func (ut *UniversalTranslator) GetSourceLanguage() language.Language <span class="cov0" title="0">{
        return ut.sourceLanguage
}</span>

// GetTargetLanguage returns the target language
func (ut *UniversalTranslator) GetTargetLanguage() language.Language <span class="cov0" title="0">{
        return ut.targetLanguage
}</span>

// CreatePromptForLanguages creates a translation prompt for any language pair
func CreatePromptForLanguages(text, sourceLang, targetLang, context string) string <span class="cov0" title="0">{
        if context == "" </span><span class="cov0" title="0">{
                context = "Literary text"
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(`You are a professional translator specializing in %s to %s translation.
Your task is to translate the following text accurately and naturally.

Guidelines:
1. Preserve the original meaning and tone
2. Use natural, idiomatic %s
3. Maintain cultural context and nuances
4. Keep proper nouns unchanged unless they have standard %s equivalents
5. Preserve formatting and punctuation
6. Ensure grammatical correctness

Context: %s

%s text:
%s

%s translation:`,
                sourceLang, targetLang,
                targetLang,
                targetLang,
                context,
                sourceLang, text,
                targetLang)</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package verification

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "time"

        _ "github.com/mattn/go-sqlite3"
)

// PolishingDatabase manages persistent storage for multi-pass polishing
type PolishingDatabase struct {
        db *sql.DB
}

// PolishingSession represents a complete polishing session
type PolishingSession struct {
        SessionID   string    `json:"session_id"`
        BookID      string    `json:"book_id"`
        BookTitle   string    `json:"book_title"`
        StartedAt   time.Time `json:"started_at"`
        CompletedAt time.Time `json:"completed_at"`
        ConfigJSON  string    `json:"config_json"`
        TotalPasses int       `json:"total_passes"`
        Status      string    `json:"status"` // running, completed, failed
}

// PassRecord represents a single polishing pass
type PassRecord struct {
        PassID      string    `json:"pass_id"`
        SessionID   string    `json:"session_id"`
        PassNumber  int       `json:"pass_number"`
        Providers   string    `json:"providers"` // JSON array
        StartedAt   time.Time `json:"started_at"`
        CompletedAt time.Time `json:"completed_at"`
        Status      string    `json:"status"`
}

// NewPolishingDatabase creates a new polishing database
func NewPolishingDatabase(dbPath string) (*PolishingDatabase, error) <span class="cov0" title="0">{
        db, err := sql.Open("sqlite3", dbPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database: %w", err)
        }</span>

        <span class="cov0" title="0">pdb := &amp;PolishingDatabase{db: db}

        // Initialize schema
        if err := pdb.initSchema(); err != nil </span><span class="cov0" title="0">{
                db.Close()
                return nil, fmt.Errorf("failed to initialize schema: %w", err)
        }</span>

        <span class="cov0" title="0">return pdb, nil</span>
}

// initSchema creates database tables
func (pdb *PolishingDatabase) initSchema() error <span class="cov0" title="0">{
        schema := `
        CREATE TABLE IF NOT EXISTS polishing_sessions (
                session_id TEXT PRIMARY KEY,
                book_id TEXT NOT NULL,
                book_title TEXT,
                started_at TIMESTAMP NOT NULL,
                completed_at TIMESTAMP,
                config_json TEXT,
                total_passes INTEGER DEFAULT 0,
                status TEXT DEFAULT 'running'
        );

        CREATE TABLE IF NOT EXISTS polishing_passes (
                pass_id TEXT PRIMARY KEY,
                session_id TEXT NOT NULL,
                pass_number INTEGER NOT NULL,
                providers TEXT,
                started_at TIMESTAMP NOT NULL,
                completed_at TIMESTAMP,
                status TEXT DEFAULT 'running',
                FOREIGN KEY (session_id) REFERENCES polishing_sessions(session_id)
        );

        CREATE TABLE IF NOT EXISTS section_notes (
                note_id TEXT PRIMARY KEY,
                pass_id TEXT NOT NULL,
                section_id TEXT NOT NULL,
                location TEXT,
                provider TEXT,
                note_type TEXT,
                importance TEXT,
                title TEXT,
                content TEXT,
                examples TEXT,
                implications TEXT,
                created_at TIMESTAMP NOT NULL,
                FOREIGN KEY (pass_id) REFERENCES polishing_passes(pass_id)
        );

        CREATE TABLE IF NOT EXISTS section_results (
                result_id TEXT PRIMARY KEY,
                pass_id TEXT NOT NULL,
                section_id TEXT NOT NULL,
                location TEXT,
                original_text TEXT,
                translated_text TEXT,
                polished_text TEXT,
                spirit_score REAL,
                language_score REAL,
                context_score REAL,
                vocabulary_score REAL,
                overall_score REAL,
                consensus INTEGER,
                confidence REAL,
                created_at TIMESTAMP NOT NULL,
                FOREIGN KEY (pass_id) REFERENCES polishing_passes(pass_id)
        );

        CREATE TABLE IF NOT EXISTS polishing_changes (
                change_id INTEGER PRIMARY KEY AUTOINCREMENT,
                pass_id TEXT NOT NULL,
                section_id TEXT NOT NULL,
                location TEXT,
                change_type TEXT,
                original TEXT,
                polished TEXT,
                reason TEXT,
                agreement INTEGER,
                confidence REAL,
                created_at TIMESTAMP NOT NULL,
                FOREIGN KEY (pass_id) REFERENCES polishing_passes(pass_id)
        );

        CREATE INDEX IF NOT EXISTS idx_notes_pass ON section_notes(pass_id);
        CREATE INDEX IF NOT EXISTS idx_notes_section ON section_notes(section_id);
        CREATE INDEX IF NOT EXISTS idx_results_pass ON section_results(pass_id);
        CREATE INDEX IF NOT EXISTS idx_results_section ON section_results(section_id);
        CREATE INDEX IF NOT EXISTS idx_changes_pass ON polishing_changes(pass_id);
        `

        _, err := pdb.db.Exec(schema)
        return err
}</span>

// CreateSession creates a new polishing session
func (pdb *PolishingDatabase) CreateSession(session *PolishingSession) error <span class="cov0" title="0">{
        query := `INSERT INTO polishing_sessions
        (session_id, book_id, book_title, started_at, config_json, status)
        VALUES (?, ?, ?, ?, ?, ?)`

        _, err := pdb.db.Exec(query,
                session.SessionID,
                session.BookID,
                session.BookTitle,
                session.StartedAt,
                session.ConfigJSON,
                session.Status,
        )

        return err
}</span>

// UpdateSession updates session status
func (pdb *PolishingDatabase) UpdateSession(sessionID string, status string, completedAt time.Time, totalPasses int) error <span class="cov0" title="0">{
        query := `UPDATE polishing_sessions
        SET status = ?, completed_at = ?, total_passes = ?
        WHERE session_id = ?`

        _, err := pdb.db.Exec(query, status, completedAt, totalPasses, sessionID)
        return err
}</span>

// GetSession retrieves a session
func (pdb *PolishingDatabase) GetSession(sessionID string) (*PolishingSession, error) <span class="cov0" title="0">{
        query := `SELECT session_id, book_id, book_title, started_at, completed_at,
        config_json, total_passes, status FROM polishing_sessions WHERE session_id = ?`

        session := &amp;PolishingSession{}
        var completedAt sql.NullTime

        err := pdb.db.QueryRow(query, sessionID).Scan(
                &amp;session.SessionID,
                &amp;session.BookID,
                &amp;session.BookTitle,
                &amp;session.StartedAt,
                &amp;completedAt,
                &amp;session.ConfigJSON,
                &amp;session.TotalPasses,
                &amp;session.Status,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if completedAt.Valid </span><span class="cov0" title="0">{
                session.CompletedAt = completedAt.Time
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

// CreatePass creates a new pass record
func (pdb *PolishingDatabase) CreatePass(pass *PassRecord) error <span class="cov0" title="0">{
        query := `INSERT INTO polishing_passes
        (pass_id, session_id, pass_number, providers, started_at, status)
        VALUES (?, ?, ?, ?, ?, ?)`

        _, err := pdb.db.Exec(query,
                pass.PassID,
                pass.SessionID,
                pass.PassNumber,
                pass.Providers,
                pass.StartedAt,
                pass.Status,
        )

        return err
}</span>

// UpdatePass updates pass status
func (pdb *PolishingDatabase) UpdatePass(passID string, status string, completedAt time.Time) error <span class="cov0" title="0">{
        query := `UPDATE polishing_passes
        SET status = ?, completed_at = ?
        WHERE pass_id = ?`

        _, err := pdb.db.Exec(query, status, completedAt, passID)
        return err
}</span>

// GetPass retrieves a pass record
func (pdb *PolishingDatabase) GetPass(passID string) (*PassRecord, error) <span class="cov0" title="0">{
        query := `SELECT pass_id, session_id, pass_number, providers, started_at, completed_at, status
        FROM polishing_passes WHERE pass_id = ?`

        pass := &amp;PassRecord{}
        var completedAt sql.NullTime

        err := pdb.db.QueryRow(query, passID).Scan(
                &amp;pass.PassID,
                &amp;pass.SessionID,
                &amp;pass.PassNumber,
                &amp;pass.Providers,
                &amp;pass.StartedAt,
                &amp;completedAt,
                &amp;pass.Status,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if completedAt.Valid </span><span class="cov0" title="0">{
                pass.CompletedAt = completedAt.Time
        }</span>

        <span class="cov0" title="0">return pass, nil</span>
}

// SaveNote saves a literary note
func (pdb *PolishingDatabase) SaveNote(note *LiteraryNote, passID string) error <span class="cov0" title="0">{
        examplesJSON, _ := json.Marshal(note.Examples)

        query := `INSERT INTO section_notes
        (note_id, pass_id, section_id, location, provider, note_type, importance,
        title, content, examples, implications, created_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`

        _, err := pdb.db.Exec(query,
                note.ID,
                passID,
                note.SectionID,
                note.Location,
                note.Provider,
                string(note.NoteType),
                string(note.Importance),
                note.Title,
                note.Content,
                string(examplesJSON),
                note.Implications,
                note.CreatedAt,
        )

        return err
}</span>

// GetNotesForSection retrieves all notes for a section
func (pdb *PolishingDatabase) GetNotesForSection(sectionID string) ([]*LiteraryNote, error) <span class="cov0" title="0">{
        query := `SELECT note_id, section_id, location, provider, note_type, importance,
        title, content, examples, implications, created_at
        FROM section_notes WHERE section_id = ? ORDER BY created_at`

        rows, err := pdb.db.Query(query, sectionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        notes := make([]*LiteraryNote, 0)

        for rows.Next() </span><span class="cov0" title="0">{
                note := &amp;LiteraryNote{}
                var examplesJSON string
                var noteType, importance string

                err := rows.Scan(
                        &amp;note.ID,
                        &amp;note.SectionID,
                        &amp;note.Location,
                        &amp;note.Provider,
                        &amp;noteType,
                        &amp;importance,
                        &amp;note.Title,
                        &amp;note.Content,
                        &amp;examplesJSON,
                        &amp;note.Implications,
                        &amp;note.CreatedAt,
                )

                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">note.NoteType = NoteType(noteType)
                note.Importance = ImportanceLevel(importance)
                json.Unmarshal([]byte(examplesJSON), &amp;note.Examples)

                notes = append(notes, note)</span>
        }

        <span class="cov0" title="0">return notes, nil</span>
}

// GetNotesForPass retrieves all notes from a specific pass
func (pdb *PolishingDatabase) GetNotesForPass(passID string) ([]*LiteraryNote, error) <span class="cov0" title="0">{
        query := `SELECT note_id, section_id, location, provider, note_type, importance,
        title, content, examples, implications, created_at
        FROM section_notes WHERE pass_id = ? ORDER BY created_at`

        rows, err := pdb.db.Query(query, passID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        notes := make([]*LiteraryNote, 0)

        for rows.Next() </span><span class="cov0" title="0">{
                note := &amp;LiteraryNote{}
                var examplesJSON string
                var noteType, importance string

                err := rows.Scan(
                        &amp;note.ID,
                        &amp;note.SectionID,
                        &amp;note.Location,
                        &amp;note.Provider,
                        &amp;noteType,
                        &amp;importance,
                        &amp;note.Title,
                        &amp;note.Content,
                        &amp;examplesJSON,
                        &amp;note.Implications,
                        &amp;note.CreatedAt,
                )

                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">note.NoteType = NoteType(noteType)
                note.Importance = ImportanceLevel(importance)
                json.Unmarshal([]byte(examplesJSON), &amp;note.Examples)

                notes = append(notes, note)</span>
        }

        <span class="cov0" title="0">return notes, nil</span>
}

// SaveResult saves a polishing result
func (pdb *PolishingDatabase) SaveResult(result *PolishingResult, passID string) error <span class="cov0" title="0">{
        query := `INSERT INTO section_results
        (result_id, pass_id, section_id, location, original_text, translated_text, polished_text,
        spirit_score, language_score, context_score, vocabulary_score, overall_score,
        consensus, confidence, created_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`

        resultID := fmt.Sprintf("%s_%s", passID, result.SectionID)

        _, err := pdb.db.Exec(query,
                resultID,
                passID,
                result.SectionID,
                result.Location,
                result.OriginalText,
                result.TranslatedText,
                result.PolishedText,
                result.SpiritScore,
                result.LanguageScore,
                result.ContextScore,
                result.VocabularyScore,
                result.OverallScore,
                result.Consensus,
                result.Confidence,
                time.Now(),
        )

        return err
}</span>

// SaveChanges saves all changes from a result
func (pdb *PolishingDatabase) SaveChanges(changes []Change, passID string, sectionID string) error <span class="cov0" title="0">{
        if len(changes) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">tx, err := pdb.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        stmt, err := tx.Prepare(`INSERT INTO polishing_changes
        (pass_id, section_id, location, change_type, original, polished, reason, agreement, confidence, created_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer stmt.Close()

        for _, change := range changes </span><span class="cov0" title="0">{
                _, err := stmt.Exec(
                        passID,
                        sectionID,
                        change.Location,
                        "improvement",
                        change.Original,
                        change.Polished,
                        change.Reason,
                        change.Agreement,
                        change.Confidence,
                        time.Now(),
                )
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return tx.Commit()</span>
}

// GetResultsForPass retrieves all results from a pass
func (pdb *PolishingDatabase) GetResultsForPass(passID string) ([]*PolishingResult, error) <span class="cov0" title="0">{
        query := `SELECT section_id, location, original_text, translated_text, polished_text,
        spirit_score, language_score, context_score, vocabulary_score, overall_score,
        consensus, confidence FROM section_results WHERE pass_id = ?`

        rows, err := pdb.db.Query(query, passID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        results := make([]*PolishingResult, 0)

        for rows.Next() </span><span class="cov0" title="0">{
                result := &amp;PolishingResult{}

                err := rows.Scan(
                        &amp;result.SectionID,
                        &amp;result.Location,
                        &amp;result.OriginalText,
                        &amp;result.TranslatedText,
                        &amp;result.PolishedText,
                        &amp;result.SpiritScore,
                        &amp;result.LanguageScore,
                        &amp;result.ContextScore,
                        &amp;result.VocabularyScore,
                        &amp;result.OverallScore,
                        &amp;result.Consensus,
                        &amp;result.Confidence,
                )

                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">results = append(results, result)</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}

// GetSessionStats retrieves statistics for a session
func (pdb *PolishingDatabase) GetSessionStats(sessionID string) (map[string]interface{}, error) <span class="cov0" title="0">{
        stats := make(map[string]interface{})

        // Total passes
        var totalPasses int
        err := pdb.db.QueryRow(
                "SELECT COUNT(*) FROM polishing_passes WHERE session_id = ?", sessionID,
        ).Scan(&amp;totalPasses)
        if err == nil </span><span class="cov0" title="0">{
                stats["total_passes"] = totalPasses
        }</span>

        // Total notes
        <span class="cov0" title="0">var totalNotes int
        err = pdb.db.QueryRow(`
                SELECT COUNT(*) FROM section_notes
                WHERE pass_id IN (SELECT pass_id FROM polishing_passes WHERE session_id = ?)
        `, sessionID).Scan(&amp;totalNotes)
        if err == nil </span><span class="cov0" title="0">{
                stats["total_notes"] = totalNotes
        }</span>

        // Total changes
        <span class="cov0" title="0">var totalChanges int
        err = pdb.db.QueryRow(`
                SELECT COUNT(*) FROM polishing_changes
                WHERE pass_id IN (SELECT pass_id FROM polishing_passes WHERE session_id = ?)
        `, sessionID).Scan(&amp;totalChanges)
        if err == nil </span><span class="cov0" title="0">{
                stats["total_changes"] = totalChanges
        }</span>

        // Average scores
        <span class="cov0" title="0">var avgOverallScore float64
        err = pdb.db.QueryRow(`
                SELECT AVG(overall_score) FROM section_results
                WHERE pass_id IN (SELECT pass_id FROM polishing_passes WHERE session_id = ?)
        `, sessionID).Scan(&amp;avgOverallScore)
        if err == nil </span><span class="cov0" title="0">{
                stats["avg_overall_score"] = avgOverallScore
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}

// Close closes the database
func (pdb *PolishingDatabase) Close() error <span class="cov0" title="0">{
        return pdb.db.Close()
}</span>

// ExportSession exports all data for a session as JSON
func (pdb *PolishingDatabase) ExportSession(sessionID string) (map[string]interface{}, error) <span class="cov0" title="0">{
        export := make(map[string]interface{})

        // Get session
        session, err := pdb.GetSession(sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">export["session"] = session

        // Get all passes
        rows, err := pdb.db.Query(
                "SELECT pass_id FROM polishing_passes WHERE session_id = ? ORDER BY pass_number",
                sessionID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        passes := make([]map[string]interface{}, 0)

        for rows.Next() </span><span class="cov0" title="0">{
                var passID string
                rows.Scan(&amp;passID)

                passData := make(map[string]interface{})

                // Get pass details
                pass, _ := pdb.GetPass(passID)
                passData["pass"] = pass

                // Get notes for this pass
                notes, _ := pdb.GetNotesForPass(passID)
                passData["notes"] = notes

                // Get results for this pass
                results, _ := pdb.GetResultsForPass(passID)
                passData["results"] = results

                passes = append(passes, passData)
        }</span>

        <span class="cov0" title="0">export["passes"] = passes
        export["stats"], _ = pdb.GetSessionStats(sessionID)

        return export, nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package verification

import (
        "context"
        "digital.vasic.translator/pkg/ebook"
        "digital.vasic.translator/pkg/events"
        "digital.vasic.translator/pkg/translator"
        "encoding/json"
        "fmt"
        "strings"
        "sync"
        "time"
)

// MultiPassConfig configures multi-pass polishing
type MultiPassConfig struct {
        // Number of polishing passes
        PassCount int

        // Provider sets for each pass (different LLMs per pass)
        PassProviders [][]string // e.g., [["deepseek", "anthropic"], ["openai", "claude"]]

        // Minimum consensus per pass
        MinConsensus int

        // Verification dimensions
        VerifySpirit     bool
        VerifyLanguage   bool
        VerifyContext    bool
        VerifyVocabulary bool

        // Note-taking configuration
        EnableNoteTaking     bool
        MinNoteImportance    ImportanceLevel
        CarryNotesForward    bool // Carry notes to next pass

        // Database path for persistence
        DatabasePath string

        // Translation configurations for all providers
        TranslationConfigs map[string]translator.TranslationConfig
}

// MultiPassPolisher orchestrates multi-pass polishing
type MultiPassPolisher struct {
        config    MultiPassConfig
        database  *PolishingDatabase
        eventBus  *events.EventBus
        sessionID string
}

// PassResult contains results from a single pass
type PassResult struct {
        PassNumber   int
        PassID       string
        Providers    []string
        Notes        []*LiteraryNote
        Results      []*PolishingResult
        Report       *PolishingReport
        Duration     time.Duration
        StartedAt    time.Time
        CompletedAt  time.Time
}

// MultiPassResult contains results from all passes
type MultiPassResult struct {
        SessionID    string
        BookID       string
        BookTitle    string
        TotalPasses  int
        PassResults  []*PassResult
        FinalBook    *ebook.Book
        FinalReport  *PolishingReport
        AllNotes     *NoteCollection
        TotalChanges int
        StartedAt    time.Time
        CompletedAt  time.Time
        Duration     time.Duration
}

// NewMultiPassPolisher creates a new multi-pass polisher
func NewMultiPassPolisher(
        config MultiPassConfig,
        eventBus *events.EventBus,
        sessionID string,
) (*MultiPassPolisher, error) <span class="cov0" title="0">{
        // Open database
        var database *PolishingDatabase
        if config.DatabasePath != "" </span><span class="cov0" title="0">{
                db, err := NewPolishingDatabase(config.DatabasePath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to open database: %w", err)
                }</span>
                <span class="cov0" title="0">database = db</span>
        }

        <span class="cov0" title="0">return &amp;MultiPassPolisher{
                config:    config,
                database:  database,
                eventBus:  eventBus,
                sessionID: sessionID,
        }, nil</span>
}

// PolishBook performs multi-pass polishing on a book
func (mpp *MultiPassPolisher) PolishBook(
        ctx context.Context,
        originalBook *ebook.Book,
        translatedBook *ebook.Book,
) (*MultiPassResult, error) <span class="cov0" title="0">{
        startTime := time.Now()

        result := &amp;MultiPassResult{
                SessionID:   mpp.sessionID,
                BookID:      fmt.Sprintf("%s_%d", originalBook.Metadata.Title, time.Now().Unix()),
                BookTitle:   originalBook.Metadata.Title,
                TotalPasses: mpp.config.PassCount,
                PassResults: make([]*PassResult, 0),
                AllNotes:    NewNoteCollection(),
                StartedAt:   startTime,
        }

        // Create session in database
        if mpp.database != nil </span><span class="cov0" title="0">{
                configJSON, _ := json.Marshal(mpp.config)
                session := &amp;PolishingSession{
                        SessionID:  mpp.sessionID,
                        BookID:     result.BookID,
                        BookTitle:  result.BookTitle,
                        StartedAt:  startTime,
                        ConfigJSON: string(configJSON),
                        Status:     "running",
                }
                if err := mpp.database.CreateSession(session); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create session: %w", err)
                }</span>
        }

        <span class="cov0" title="0">mpp.emitProgress("Starting multi-pass polishing", map[string]interface{}{
                "total_passes": mpp.config.PassCount,
                "book_title":   originalBook.Metadata.Title,
        })

        // Current book state (updated after each pass)
        currentBook := translatedBook

        // Perform each pass
        for passNum := 1; passNum &lt;= mpp.config.PassCount; passNum++ </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return result, ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">mpp.emitProgress(fmt.Sprintf("Starting Pass %d/%d", passNum, mpp.config.PassCount), map[string]interface{}{
                        "pass_number":  passNum,
                        "total_passes": mpp.config.PassCount,
                })

                // Get providers for this pass
                providers := mpp.getProvidersForPass(passNum)

                // Get previous notes
                var previousNotes []*LiteraryNote
                if mpp.config.CarryNotesForward &amp;&amp; passNum &gt; 1 </span><span class="cov0" title="0">{
                        previousNotes = result.AllNotes.All
                }</span>

                // Perform pass
                <span class="cov0" title="0">passResult, polishedBook, err := mpp.performPass(
                        ctx,
                        passNum,
                        providers,
                        originalBook,
                        currentBook,
                        previousNotes,
                )

                if err != nil </span><span class="cov0" title="0">{
                        return result, fmt.Errorf("pass %d failed: %w", passNum, err)
                }</span>

                // Update current book for next pass
                <span class="cov0" title="0">currentBook = polishedBook

                // Add pass results
                result.PassResults = append(result.PassResults, passResult)

                // Collect notes
                for _, note := range passResult.Notes </span><span class="cov0" title="0">{
                        result.AllNotes.Add(note)
                }</span>

                // Count changes
                <span class="cov0" title="0">for _, res := range passResult.Results </span><span class="cov0" title="0">{
                        result.TotalChanges += len(res.Changes)
                }</span>

                <span class="cov0" title="0">mpp.emitProgress(fmt.Sprintf("Completed Pass %d/%d", passNum, mpp.config.PassCount), map[string]interface{}{
                        "pass_number":  passNum,
                        "notes_added":  len(passResult.Notes),
                        "changes_made": len(passResult.Results),
                })</span>
        }

        // Final book is the result of last pass
        <span class="cov0" title="0">result.FinalBook = currentBook

        // Generate final report combining all passes
        result.FinalReport = mpp.generateFinalReport(result)

        result.CompletedAt = time.Now()
        result.Duration = result.CompletedAt.Sub(startTime)

        // Update session in database
        if mpp.database != nil </span><span class="cov0" title="0">{
                mpp.database.UpdateSession(mpp.sessionID, "completed", result.CompletedAt, mpp.config.PassCount)
        }</span>

        <span class="cov0" title="0">mpp.emitProgress("Multi-pass polishing completed", map[string]interface{}{
                "total_passes":   mpp.config.PassCount,
                "total_changes":  result.TotalChanges,
                "total_notes":    len(result.AllNotes.All),
                "final_score":    result.FinalReport.OverallScore,
                "duration":       result.Duration.String(),
        })

        return result, nil</span>
}

// performPass performs a single polishing pass
func (mpp *MultiPassPolisher) performPass(
        ctx context.Context,
        passNumber int,
        providers []string,
        originalBook *ebook.Book,
        currentBook *ebook.Book,
        previousNotes []*LiteraryNote,
) (*PassResult, *ebook.Book, error) <span class="cov0" title="0">{
        startTime := time.Now()

        passID := fmt.Sprintf("%s_pass_%d", mpp.sessionID, passNumber)

        // Create pass record in database
        if mpp.database != nil </span><span class="cov0" title="0">{
                providersJSON, _ := json.Marshal(providers)
                passRecord := &amp;PassRecord{
                        PassID:     passID,
                        SessionID:  mpp.sessionID,
                        PassNumber: passNumber,
                        Providers:  string(providersJSON),
                        StartedAt:  startTime,
                        Status:     "running",
                }
                if err := mpp.database.CreatePass(passRecord); err != nil </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("failed to create pass record: %w", err)
                }</span>
        }

        <span class="cov0" title="0">passResult := &amp;PassResult{
                PassNumber: passNumber,
                PassID:     passID,
                Providers:  providers,
                Notes:      make([]*LiteraryNote, 0),
                Results:    make([]*PolishingResult, 0),
                StartedAt:  startTime,
        }

        // Create polishing config for this pass
        polishingConfig := PolishingConfig{
                Providers:    providers,
                MinConsensus: mpp.config.MinConsensus,
                VerifySpirit:      mpp.config.VerifySpirit,
                VerifyLanguage:    mpp.config.VerifyLanguage,
                VerifyContext:     mpp.config.VerifyContext,
                VerifyVocabulary:  mpp.config.VerifyVocabulary,
                TranslationConfigs: make(map[string]translator.TranslationConfig),
        }

        // Add configs for providers
        for _, provider := range providers </span><span class="cov0" title="0">{
                if config, ok := mpp.config.TranslationConfigs[provider]; ok </span><span class="cov0" title="0">{
                        polishingConfig.TranslationConfigs[provider] = config
                }</span>
        }

        // Create polisher
        <span class="cov0" title="0">polisher, err := NewBookPolisher(polishingConfig, mpp.eventBus, fmt.Sprintf("%s_pass%d", mpp.sessionID, passNumber))
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to create polisher: %w", err)
        }</span>

        // Polish with note-taking
        <span class="cov0" title="0">polishedBook, report, notes, err := mpp.polishWithNotes(
                ctx,
                polisher,
                passID,
                passNumber,
                originalBook,
                currentBook,
                previousNotes,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">passResult.Notes = notes
        passResult.Report = report
        passResult.Results = report.SectionResults

        passResult.CompletedAt = time.Now()
        passResult.Duration = passResult.CompletedAt.Sub(startTime)

        // Update pass in database
        if mpp.database != nil </span><span class="cov0" title="0">{
                mpp.database.UpdatePass(passID, "completed", passResult.CompletedAt)
        }</span>

        <span class="cov0" title="0">return passResult, polishedBook, nil</span>
}

// polishWithNotes performs polishing with integrated note-taking
func (mpp *MultiPassPolisher) polishWithNotes(
        ctx context.Context,
        polisher *BookPolisher,
        passID string,
        passNumber int,
        originalBook *ebook.Book,
        currentBook *ebook.Book,
        previousNotes []*LiteraryNote,
) (*ebook.Book, *PolishingReport, []*LiteraryNote, error) <span class="cov0" title="0">{
        polishedBook := currentBook
        report := NewPolishingReport(polisher.config)
        allNotes := make([]*LiteraryNote, 0)

        // Polish metadata with notes
        if mpp.config.EnableNoteTaking </span><span class="cov0" title="0">{
                metadataNotes := mpp.generateMetadataNotes(
                        ctx,
                        passNumber,
                        polisher,
                        &amp;originalBook.Metadata,
                        &amp;currentBook.Metadata,
                        previousNotes,
                )
                allNotes = append(allNotes, metadataNotes...)

                // Save notes to database
                if mpp.database != nil </span><span class="cov0" title="0">{
                        for _, note := range metadataNotes </span><span class="cov0" title="0">{
                                mpp.database.SaveNote(note, passID)
                        }</span>
                }
        }

        // Polish metadata
        <span class="cov0" title="0">if err := polisher.polishMetadata(ctx, &amp;originalBook.Metadata, &amp;polishedBook.Metadata, report); err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>

        // Polish chapters with notes
        <span class="cov0" title="0">totalChapters := len(originalBook.Chapters)
        for i := range originalBook.Chapters </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, nil, nil, ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">location := fmt.Sprintf("Chapter %d/%d", i+1, totalChapters)

                // Generate notes for chapter if enabled
                if mpp.config.EnableNoteTaking </span><span class="cov0" title="0">{
                        chapterNotes := mpp.generateChapterNotes(
                                ctx,
                                passNumber,
                                polisher,
                                &amp;originalBook.Chapters[i],
                                &amp;currentBook.Chapters[i],
                                location,
                                previousNotes,
                        )
                        allNotes = append(allNotes, chapterNotes...)

                        // Save notes to database
                        if mpp.database != nil </span><span class="cov0" title="0">{
                                for _, note := range chapterNotes </span><span class="cov0" title="0">{
                                        mpp.database.SaveNote(note, passID)
                                }</span>
                        }
                }

                // Polish chapter
                <span class="cov0" title="0">if err := polisher.polishChapter(
                        ctx,
                        &amp;originalBook.Chapters[i],
                        &amp;polishedBook.Chapters[i],
                        i+1,
                        report,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, nil, nil, err
                }</span>

                // Save results to database
                <span class="cov0" title="0">if mpp.database != nil </span><span class="cov0" title="0">{
                        for _, result := range report.SectionResults </span><span class="cov0" title="0">{
                                mpp.database.SaveResult(result, passID)
                                mpp.database.SaveChanges(result.Changes, passID, result.SectionID)
                        }</span>
                }
        }

        <span class="cov0" title="0">report.Finalize()

        return polishedBook, report, allNotes, nil</span>
}

// generateMetadataNotes generates notes for metadata
func (mpp *MultiPassPolisher) generateMetadataNotes(
        ctx context.Context,
        passNumber int,
        polisher *BookPolisher,
        originalMetadata *ebook.Metadata,
        currentMetadata *ebook.Metadata,
        previousNotes []*LiteraryNote,
) []*LiteraryNote <span class="cov0" title="0">{
        notes := make([]*LiteraryNote, 0)

        // Generate notes from first provider
        if len(polisher.config.Providers) &gt; 0 </span><span class="cov0" title="0">{
                provider := polisher.config.Providers[0]
                translator := polisher.translators[provider]

                noteTaker := NewNoteTaker(translator, provider)

                // Title notes
                if originalMetadata.Title != "" </span><span class="cov0" title="0">{
                        titleNotes, _ := noteTaker.GenerateNotes(
                                ctx,
                                passNumber,
                                "metadata_title",
                                "Book Title",
                                originalMetadata.Title,
                                currentMetadata.Title,
                                filterNotesBySection(previousNotes, "metadata_title"),
                        )
                        notes = append(notes, titleNotes...)
                }</span>
        }

        <span class="cov0" title="0">return notes</span>
}

// generateChapterNotes generates notes for a chapter
func (mpp *MultiPassPolisher) generateChapterNotes(
        ctx context.Context,
        passNumber int,
        polisher *BookPolisher,
        originalChapter *ebook.Chapter,
        currentChapter *ebook.Chapter,
        location string,
        previousNotes []*LiteraryNote,
) []*LiteraryNote <span class="cov0" title="0">{
        notes := make([]*LiteraryNote, 0)

        // Generate notes from all providers in parallel
        var wg sync.WaitGroup
        var mu sync.Mutex

        for _, provider := range polisher.config.Providers </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(prov string) </span><span class="cov0" title="0">{
                        defer wg.Done()

                        translator := polisher.translators[prov]
                        noteTaker := NewNoteTaker(translator, prov)

                        sectionID := fmt.Sprintf("chapter_%s", strings.ReplaceAll(location, " ", "_"))

                        // Generate notes for chapter content
                        chapterText := extractChapterText(originalChapter)
                        currentText := extractChapterText(currentChapter)

                        if len(chapterText) &gt; 100 </span><span class="cov0" title="0">{ // Only generate notes for substantial text
                                providerNotes, _ := noteTaker.GenerateNotes(
                                        ctx,
                                        passNumber,
                                        sectionID,
                                        location,
                                        chapterText,
                                        currentText,
                                        filterNotesBySection(previousNotes, sectionID),
                                )

                                mu.Lock()
                                notes = append(notes, providerNotes...)
                                mu.Unlock()
                        }</span>
                }(provider)
        }

        <span class="cov0" title="0">wg.Wait()

        // Filter by minimum importance
        if mpp.config.MinNoteImportance != "" </span><span class="cov0" title="0">{
                notes = FilterNotesByImportance(notes, mpp.config.MinNoteImportance)
        }</span>

        <span class="cov0" title="0">return notes</span>
}

// Helper functions

func (mpp *MultiPassPolisher) getProvidersForPass(passNumber int) []string <span class="cov0" title="0">{
        if passNumber &lt;= len(mpp.config.PassProviders) </span><span class="cov0" title="0">{
                return mpp.config.PassProviders[passNumber-1]
        }</span>

        // Default: use all providers
        <span class="cov0" title="0">providers := make([]string, 0)
        for provider := range mpp.config.TranslationConfigs </span><span class="cov0" title="0">{
                providers = append(providers, provider)
        }</span>
        <span class="cov0" title="0">return providers</span>
}

func (mpp *MultiPassPolisher) generateFinalReport(result *MultiPassResult) *PolishingReport <span class="cov0" title="0">{
        // Combine reports from all passes
        if len(result.PassResults) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Use last pass report as base
        <span class="cov0" title="0">finalReport := result.PassResults[len(result.PassResults)-1].Report

        // Add summary of all passes
        finalReport.TotalSections = 0
        finalReport.TotalChanges = result.TotalChanges

        for _, passResult := range result.PassResults </span><span class="cov0" title="0">{
                if passResult.Report != nil </span><span class="cov0" title="0">{
                        finalReport.TotalSections += passResult.Report.TotalSections
                }</span>
        }

        <span class="cov0" title="0">return finalReport</span>
}

func (mpp *MultiPassPolisher) emitProgress(message string, data map[string]interface{}) <span class="cov0" title="0">{
        if mpp.eventBus != nil </span><span class="cov0" title="0">{
                event := events.NewEvent("multipass_progress", message, data)
                event.SessionID = mpp.sessionID
                mpp.eventBus.Publish(event)
        }</span>
}

func filterNotesBySection(notes []*LiteraryNote, sectionID string) []*LiteraryNote <span class="cov0" title="0">{
        filtered := make([]*LiteraryNote, 0)
        for _, note := range notes </span><span class="cov0" title="0">{
                if note.SectionID == sectionID </span><span class="cov0" title="0">{
                        filtered = append(filtered, note)
                }</span>
        }
        <span class="cov0" title="0">return filtered</span>
}

func extractChapterText(chapter *ebook.Chapter) string <span class="cov0" title="0">{
        var sb strings.Builder

        if chapter.Title != "" </span><span class="cov0" title="0">{
                sb.WriteString(chapter.Title)
                sb.WriteString("\n\n")
        }</span>

        <span class="cov0" title="0">for i := range chapter.Sections </span><span class="cov0" title="0">{
                sb.WriteString(extractSectionText(&amp;chapter.Sections[i]))
        }</span>

        <span class="cov0" title="0">return sb.String()</span>
}

func extractSectionText(section *ebook.Section) string <span class="cov0" title="0">{
        var sb strings.Builder

        if section.Title != "" </span><span class="cov0" title="0">{
                sb.WriteString(section.Title)
                sb.WriteString("\n")
        }</span>

        <span class="cov0" title="0">if section.Content != "" </span><span class="cov0" title="0">{
                sb.WriteString(section.Content)
                sb.WriteString("\n")
        }</span>

        <span class="cov0" title="0">for i := range section.Subsections </span><span class="cov0" title="0">{
                sb.WriteString(extractSectionText(&amp;section.Subsections[i]))
        }</span>

        <span class="cov0" title="0">return sb.String()</span>
}

// Close closes the multi-pass polisher and database
func (mpp *MultiPassPolisher) Close() error <span class="cov0" title="0">{
        if mpp.database != nil </span><span class="cov0" title="0">{
                return mpp.database.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package verification

import (
        "context"
        "digital.vasic.translator/pkg/translator/llm"
        "fmt"
        "strings"
        "time"

        "golang.org/x/text/cases"
        "golang.org/x/text/language"
)

// NoteType represents different types of literary notes
type NoteType string

const (
        NoteTypeCharacter  NoteType = "character"  // Character development, traits, arcs
        NoteTypeTone       NoteType = "tone"       // Tone, atmosphere, mood
        NoteTypeTheme      NoteType = "theme"      // Themes, motifs, symbols
        NoteTypeCulture    NoteType = "culture"    // Cultural references, idioms
        NoteTypeStyle      NoteType = "style"      // Literary style, techniques
        NoteTypeContext    NoteType = "context"    // Historical, social context
        NoteTypeVocabulary NoteType = "vocabulary" // Key terms, specialized vocabulary
        NoteTypeStructure  NoteType = "structure"  // Narrative structure, pacing
)

// ImportanceLevel represents the importance of a note
type ImportanceLevel string

const (
        ImportanceCritical ImportanceLevel = "critical" // Must preserve exactly
        ImportanceHigh     ImportanceLevel = "high"     // Very important to preserve
        ImportanceMedium   ImportanceLevel = "medium"   // Important context
        ImportanceLow      ImportanceLevel = "low"      // Minor observation
)

// LiteraryNote represents an observation about the text
type LiteraryNote struct {
        ID           string          `json:"id"`
        PassNumber   int             `json:"pass_number"`
        SectionID    string          `json:"section_id"`
        Location     string          `json:"location"`
        Provider     string          `json:"provider"`
        NoteType     NoteType        `json:"note_type"`
        Importance   ImportanceLevel `json:"importance"`
        Title        string          `json:"title"`
        Content      string          `json:"content"`
        Examples     []string        `json:"examples"`
        Implications string          `json:"implications"`
        CreatedAt    time.Time       `json:"created_at"`
}

// NoteCollection groups notes for efficient access
type NoteCollection struct {
        ByType     map[NoteType][]*LiteraryNote
        BySection  map[string][]*LiteraryNote
        ByProvider map[string][]*LiteraryNote
        ByPass     map[int][]*LiteraryNote
        All        []*LiteraryNote
}

// NewNoteCollection creates a new note collection
func NewNoteCollection() *NoteCollection <span class="cov8" title="1">{
        return &amp;NoteCollection{
                ByType:     make(map[NoteType][]*LiteraryNote),
                BySection:  make(map[string][]*LiteraryNote),
                ByProvider: make(map[string][]*LiteraryNote),
                ByPass:     make(map[int][]*LiteraryNote),
                All:        make([]*LiteraryNote, 0),
        }
}</span>

// Add adds a note to the collection
func (nc *NoteCollection) Add(note *LiteraryNote) <span class="cov8" title="1">{
        nc.All = append(nc.All, note)
        nc.ByType[note.NoteType] = append(nc.ByType[note.NoteType], note)
        nc.BySection[note.SectionID] = append(nc.BySection[note.SectionID], note)
        nc.ByProvider[note.Provider] = append(nc.ByProvider[note.Provider], note)
        nc.ByPass[note.PassNumber] = append(nc.ByPass[note.PassNumber], note)
}</span>

// GetForSection retrieves all notes for a specific section
func (nc *NoteCollection) GetForSection(sectionID string) []*LiteraryNote <span class="cov8" title="1">{
        return nc.BySection[sectionID]
}</span>

// GetByType retrieves all notes of a specific type
func (nc *NoteCollection) GetByType(noteType NoteType) []*LiteraryNote <span class="cov8" title="1">{
        return nc.ByType[noteType]
}</span>

// GetCritical retrieves all critical notes
func (nc *NoteCollection) GetCritical() []*LiteraryNote <span class="cov8" title="1">{
        var critical []*LiteraryNote
        for _, note := range nc.All </span><span class="cov8" title="1">{
                if note.Importance == ImportanceCritical </span><span class="cov8" title="1">{
                        critical = append(critical, note)
                }</span>
        }
        <span class="cov8" title="1">return critical</span>
}

// GetByPass retrieves all notes from a specific pass
func (nc *NoteCollection) GetByPass(passNumber int) []*LiteraryNote <span class="cov0" title="0">{
        return nc.ByPass[passNumber]
}</span>

// Summary generates a text summary of the collection
func (nc *NoteCollection) Summary() string <span class="cov0" title="0">{
        var sb strings.Builder

        sb.WriteString(fmt.Sprintf("Total Notes: %d\n\n", len(nc.All)))

        // By type
        sb.WriteString("By Type:\n")
        for noteType, notes := range nc.ByType </span><span class="cov0" title="0">{
                sb.WriteString(fmt.Sprintf("  %s: %d\n", noteType, len(notes)))
        }</span>
        <span class="cov0" title="0">sb.WriteString("\n")

        // By importance
        critical := nc.GetCritical()
        sb.WriteString(fmt.Sprintf("Critical Notes: %d\n", len(critical)))

        return sb.String()</span>
}

// NoteTaker generates literary notes using LLMs
type NoteTaker struct {
        translator *llm.LLMTranslator
        provider   string
}

// NewNoteTaker creates a new note taker
func NewNoteTaker(translator *llm.LLMTranslator, provider string) *NoteTaker <span class="cov0" title="0">{
        return &amp;NoteTaker{
                translator: translator,
                provider:   provider,
        }
}</span>

// GenerateNotes generates literary notes for a text section
func (nt *NoteTaker) GenerateNotes(
        ctx context.Context,
        passNumber int,
        sectionID string,
        location string,
        originalText string,
        translatedText string,
        previousNotes []*LiteraryNote,
) ([]*LiteraryNote, error) <span class="cov0" title="0">{
        // Create note-taking prompt
        prompt := nt.createNotePrompt(originalText, translatedText, previousNotes)

        // Get LLM analysis
        response, err := nt.translator.Translate(ctx, prompt, location)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("note generation failed: %w", err)
        }</span>

        // Parse notes from response
        <span class="cov0" title="0">notes := nt.parseNotes(response, passNumber, sectionID, location)

        return notes, nil</span>
}

// createNotePrompt creates the prompt for note generation
func (nt *NoteTaker) createNotePrompt(
        originalText string,
        translatedText string,
        previousNotes []*LiteraryNote,
) string <span class="cov0" title="0">{
        var sb strings.Builder

        sb.WriteString(`You are a literary analyst reviewing a translation. Generate detailed notes about important aspects that must be preserved or improved.

**Original Text:**
`)
        sb.WriteString(originalText)
        sb.WriteString("\n\n**Current Translation:**\n")
        sb.WriteString(translatedText)
        sb.WriteString("\n\n")

        // Include previous notes if available
        if len(previousNotes) &gt; 0 </span><span class="cov0" title="0">{
                sb.WriteString("**Previous Analysis (from earlier pass):**\n")
                for _, note := range previousNotes </span><span class="cov0" title="0">{
                        sb.WriteString(fmt.Sprintf("- [%s] %s: %s\n", note.NoteType, note.Title, note.Content))
                }</span>
                <span class="cov0" title="0">sb.WriteString("\n")</span>
        }

        <span class="cov0" title="0">sb.WriteString(`**Generate notes for the following dimensions:**

1. **CHARACTER**: Character traits, development, voice, relationships
2. **TONE**: Atmosphere, mood, emotional tone, narrative voice
3. **THEME**: Themes, motifs, symbols, deeper meanings
4. **CULTURE**: Cultural references, idioms, historical context
5. **STYLE**: Literary techniques, sentence structure, rhythm
6. **VOCABULARY**: Key terms, specialized vocabulary, word choice significance

**Response Format:**

NOTE: [TYPE]
IMPORTANCE: [critical/high/medium/low]
TITLE: [Brief title]
CONTENT: [Detailed observation]
EXAMPLES: [Specific examples from text, one per line]
IMPLICATIONS: [Why this matters for translation]
---

Provide 3-10 notes covering different aspects. Focus on elements that are critical for translation quality.
`)

        return sb.String()</span>
}

// parseNotes parses notes from LLM response
func (nt *NoteTaker) parseNotes(
        response string,
        passNumber int,
        sectionID string,
        location string,
) []*LiteraryNote <span class="cov0" title="0">{
        notes := make([]*LiteraryNote, 0)

        // Split by note separator
        noteSections := strings.Split(response, "---")

        for _, noteSection := range noteSections </span><span class="cov0" title="0">{
                noteSection = strings.TrimSpace(noteSection)
                if noteSection == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">note := nt.parseNote(noteSection, passNumber, sectionID, location)
                if note != nil </span><span class="cov0" title="0">{
                        notes = append(notes, note)
                }</span>
        }

        <span class="cov0" title="0">return notes</span>
}

// parseNote parses a single note from text
func (nt *NoteTaker) parseNote(
        text string,
        passNumber int,
        sectionID string,
        location string,
) *LiteraryNote <span class="cov0" title="0">{
        note := &amp;LiteraryNote{
                ID:         fmt.Sprintf("%s_%s_%d_%d", nt.provider, sectionID, passNumber, time.Now().UnixNano()),
                PassNumber: passNumber,
                SectionID:  sectionID,
                Location:   location,
                Provider:   nt.provider,
                Examples:   make([]string, 0),
                CreatedAt:  time.Now(),
        }

        lines := strings.Split(text, "\n")
        var currentField string
        var contentBuilder strings.Builder

        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check for field markers
                <span class="cov0" title="0">if strings.HasPrefix(line, "NOTE:") </span><span class="cov0" title="0">{
                        noteType := strings.TrimSpace(strings.TrimPrefix(line, "NOTE:"))
                        noteType = strings.Trim(noteType, "[]")
                        note.NoteType = NoteType(strings.ToLower(noteType))
                        currentField = "note_type"
                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(line, "IMPORTANCE:") </span><span class="cov0" title="0">{
                        importance := strings.TrimSpace(strings.TrimPrefix(line, "IMPORTANCE:"))
                        importance = strings.Trim(importance, "[]")
                        note.Importance = ImportanceLevel(strings.ToLower(importance))
                        currentField = "importance"
                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(line, "TITLE:") </span><span class="cov0" title="0">{
                        note.Title = strings.TrimSpace(strings.TrimPrefix(line, "TITLE:"))
                        note.Title = strings.Trim(note.Title, "[]")
                        currentField = "title"
                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(line, "CONTENT:") </span><span class="cov0" title="0">{
                        contentBuilder.Reset()
                        content := strings.TrimSpace(strings.TrimPrefix(line, "CONTENT:"))
                        if content != "" </span><span class="cov0" title="0">{
                                contentBuilder.WriteString(content)
                        }</span>
                        <span class="cov0" title="0">currentField = "content"</span>
                } else<span class="cov0" title="0"> if strings.HasPrefix(line, "EXAMPLES:") </span><span class="cov0" title="0">{
                        currentField = "examples"
                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(line, "IMPLICATIONS:") </span><span class="cov0" title="0">{
                        note.Content = contentBuilder.String()
                        contentBuilder.Reset()
                        implications := strings.TrimSpace(strings.TrimPrefix(line, "IMPLICATIONS:"))
                        if implications != "" </span><span class="cov0" title="0">{
                                contentBuilder.WriteString(implications)
                        }</span>
                        <span class="cov0" title="0">currentField = "implications"</span>
                } else<span class="cov0" title="0"> {
                        // Continuation of current field
                        switch currentField </span>{
                        case "content":<span class="cov0" title="0">
                                if contentBuilder.Len() &gt; 0 </span><span class="cov0" title="0">{
                                        contentBuilder.WriteString(" ")
                                }</span>
                                <span class="cov0" title="0">contentBuilder.WriteString(line)</span>
                        case "examples":<span class="cov0" title="0">
                                if line != "" &amp;&amp; !strings.HasPrefix(line, "IMPLICATIONS:") </span><span class="cov0" title="0">{
                                        note.Examples = append(note.Examples, line)
                                }</span>
                        case "implications":<span class="cov0" title="0">
                                if contentBuilder.Len() &gt; 0 </span><span class="cov0" title="0">{
                                        contentBuilder.WriteString(" ")
                                }</span>
                                <span class="cov0" title="0">contentBuilder.WriteString(line)</span>
                        }
                }
        }

        // Finalize implications
        <span class="cov0" title="0">if currentField == "implications" </span><span class="cov0" title="0">{
                note.Implications = contentBuilder.String()
        }</span>

        // Validate note has minimum required fields
        <span class="cov0" title="0">if note.NoteType == "" || note.Title == "" || note.Content == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Default importance
        <span class="cov0" title="0">if note.Importance == "" </span><span class="cov0" title="0">{
                note.Importance = ImportanceMedium
        }</span>

        <span class="cov0" title="0">return note</span>
}

// FormatNotesForContext formats notes for inclusion in polishing prompt
func FormatNotesForContext(notes []*LiteraryNote) string <span class="cov8" title="1">{
        if len(notes) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">var sb strings.Builder

        sb.WriteString("**Previous Literary Analysis:**\n\n")

        // Group by type
        byType := make(map[NoteType][]*LiteraryNote)
        for _, note := range notes </span><span class="cov8" title="1">{
                byType[note.NoteType] = append(byType[note.NoteType], note)
        }</span>

        // Format each type
        <span class="cov8" title="1">for noteType, typeNotes := range byType </span><span class="cov8" title="1">{
                sb.WriteString(fmt.Sprintf("### %s\n", cases.Title(language.English, cases.Compact).String(string(noteType))))

                for _, note := range typeNotes </span><span class="cov8" title="1">{
                        importance := ""
                        if note.Importance == ImportanceCritical </span><span class="cov8" title="1">{
                                importance = " ‚ö†Ô∏è"
                        }</span> else<span class="cov0" title="0"> if note.Importance == ImportanceHigh </span><span class="cov0" title="0">{
                                importance = " ‚≠ê"
                        }</span>

                        <span class="cov8" title="1">sb.WriteString(fmt.Sprintf("- **%s**%s: %s\n", note.Title, importance, note.Content))

                        if len(note.Examples) &gt; 0 </span><span class="cov8" title="1">{
                                sb.WriteString("  Examples: ")
                                sb.WriteString(strings.Join(note.Examples, "; "))
                                sb.WriteString("\n")
                        }</span>

                        <span class="cov8" title="1">if note.Implications != "" </span><span class="cov8" title="1">{
                                sb.WriteString(fmt.Sprintf("  ‚Üí %s\n", note.Implications))
                        }</span>
                }

                <span class="cov8" title="1">sb.WriteString("\n")</span>
        }

        <span class="cov8" title="1">return sb.String()</span>
}

// FilterNotesByImportance filters notes by minimum importance level
func FilterNotesByImportance(notes []*LiteraryNote, minImportance ImportanceLevel) []*LiteraryNote <span class="cov8" title="1">{
        importanceOrder := map[ImportanceLevel]int{
                ImportanceLow:      1,
                ImportanceMedium:   2,
                ImportanceHigh:     3,
                ImportanceCritical: 4,
        }

        minLevel := importanceOrder[minImportance]
        filtered := make([]*LiteraryNote, 0)

        for _, note := range notes </span><span class="cov8" title="1">{
                if importanceOrder[note.Importance] &gt;= minLevel </span><span class="cov8" title="1">{
                        filtered = append(filtered, note)
                }</span>
        }

        <span class="cov8" title="1">return filtered</span>
}

// MergeNotes merges notes from multiple passes, deduplicating similar ones
func MergeNotes(allNotes []*LiteraryNote) []*LiteraryNote <span class="cov8" title="1">{
        // Simple deduplication based on title similarity
        // More sophisticated merging can be added later
        seen := make(map[string]*LiteraryNote)
        merged := make([]*LiteraryNote, 0)

        for _, note := range allNotes </span><span class="cov8" title="1">{
                key := fmt.Sprintf("%s:%s:%s", note.SectionID, note.NoteType, strings.ToLower(note.Title))

                if existing, found := seen[key]; found </span><span class="cov8" title="1">{
                        // Merge: keep higher importance, append examples
                        if importanceLevel(note.Importance) &gt; importanceLevel(existing.Importance) </span><span class="cov8" title="1">{
                                existing.Importance = note.Importance
                        }</span>

                        // Append unique examples
                        <span class="cov8" title="1">for _, example := range note.Examples </span><span class="cov8" title="1">{
                                if !contains(existing.Examples, example) </span><span class="cov8" title="1">{
                                        existing.Examples = append(existing.Examples, example)
                                }</span>
                        }

                        // Append implications
                        <span class="cov8" title="1">if note.Implications != "" &amp;&amp; !strings.Contains(existing.Implications, note.Implications) </span><span class="cov0" title="0">{
                                if existing.Implications != "" </span><span class="cov0" title="0">{
                                        existing.Implications += " "
                                }</span>
                                <span class="cov0" title="0">existing.Implications += note.Implications</span>
                        }
                } else<span class="cov8" title="1"> {
                        seen[key] = note
                        merged = append(merged, note)
                }</span>
        }

        <span class="cov8" title="1">return merged</span>
}

// Helper functions

func importanceLevel(importance ImportanceLevel) int <span class="cov8" title="1">{
        levels := map[ImportanceLevel]int{
                ImportanceLow:      1,
                ImportanceMedium:   2,
                ImportanceHigh:     3,
                ImportanceCritical: 4,
        }
        return levels[importance]
}</span>

func contains(slice []string, item string) bool <span class="cov8" title="1">{
        for _, s := range slice </span><span class="cov8" title="1">{
                if s == item </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package verification

import (
        "context"
        "digital.vasic.translator/pkg/ebook"
        "digital.vasic.translator/pkg/events"
        "digital.vasic.translator/pkg/translator"
        "digital.vasic.translator/pkg/translator/llm"
        "fmt"
        "strings"
        "sync"
)

// PolishingConfig configures the multi-LLM polishing process
type PolishingConfig struct {
        // LLM providers to use for verification (e.g., ["openai", "anthropic", "deepseek"])
        Providers []string

        // Minimum number of LLMs that must agree for a change to be accepted
        MinConsensus int

        // Verification dimensions
        VerifySpirit      bool // Verify if translation preserves the spirit of original
        VerifyLanguage    bool // Verify target language quality and naturalness
        VerifyContext     bool // Verify context and deep meanings
        VerifyVocabulary  bool // Verify word choice and vocabulary richness

        // Translation configurations for each provider
        TranslationConfigs map[string]translator.TranslationConfig
}

// PolishingResult contains detailed results of the polishing process
type PolishingResult struct {
        // Section identification
        SectionID      string
        Location       string

        // Content
        OriginalText   string
        TranslatedText string
        PolishedText   string

        // Changes made
        Changes        []Change

        // Consensus details
        Consensus      int     // Number of LLMs that agreed on changes
        Confidence     float64 // Confidence score (0.0-1.0)

        // Issues found
        Issues         []Issue
        Suggestions    []Suggestion

        // Quality scores per dimension
        SpiritScore      float64
        LanguageScore    float64
        ContextScore     float64
        VocabularyScore  float64
        OverallScore     float64
}

// Change represents a modification made during polishing
type Change struct {
        Location    string  // Where in the text
        Original    string  // Original translated text
        Polished    string  // Polished version
        Reason      string  // Why the change was made
        Agreement   int     // How many LLMs agreed
        Confidence  float64 // Confidence in this change
}

// Issue represents a problem found during verification
type Issue struct {
        Type        string  // "spirit", "language", "context", "vocabulary"
        Severity    string  // "critical", "major", "minor"
        Description string
        Location    string
        Suggestion  string
}

// Suggestion represents an improvement suggestion
type Suggestion struct {
        Type        string  // Type of suggestion
        Description string
        Location    string
        Example     string
}

// LLMVerification holds verification from a single LLM
type llmVerification struct {
        Provider       string
        SpiritScore    float64
        LanguageScore  float64
        ContextScore   float64
        VocabularyScore float64
        Suggestions    []string
        PolishedText   string
        Issues         []Issue
}

// BookPolisher performs multi-LLM verification and polishing
type BookPolisher struct {
        config       PolishingConfig
        translators  map[string]*llm.LLMTranslator
        eventBus     *events.EventBus
        sessionID    string
}

// NewBookPolisher creates a new multi-LLM book polisher
func NewBookPolisher(
        config PolishingConfig,
        eventBus *events.EventBus,
        sessionID string,
) (*BookPolisher, error) <span class="cov8" title="1">{
        // Create LLM translators for each provider
        translators := make(map[string]*llm.LLMTranslator)

        for _, provider := range config.Providers </span><span class="cov8" title="1">{
                translatorConfig, ok := config.TranslationConfigs[provider]
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("missing translation config for provider: %s", provider)
                }</span>

                <span class="cov8" title="1">translator, err := llm.NewLLMTranslator(translatorConfig)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to create translator for %s: %w", provider, err)
                }</span>

                <span class="cov0" title="0">translators[provider] = translator</span>
        }

        <span class="cov0" title="0">return &amp;BookPolisher{
                config:      config,
                translators: translators,
                eventBus:    eventBus,
                sessionID:   sessionID,
        }, nil</span>
}

// PolishBook performs comprehensive multi-LLM verification and polishing
func (bp *BookPolisher) PolishBook(
        ctx context.Context,
        originalBook *ebook.Book,
        translatedBook *ebook.Book,
) (*ebook.Book, *PolishingReport, error) <span class="cov0" title="0">{
        // Create polished book copy
        polishedBook := translatedBook

        // Initialize report
        report := NewPolishingReport(bp.config)

        bp.emitProgress("Starting multi-LLM verification and polishing", map[string]interface{}{
                "providers":      bp.config.Providers,
                "min_consensus":  bp.config.MinConsensus,
                "total_chapters": len(originalBook.Chapters),
        })

        // Polish metadata
        if err := bp.polishMetadata(ctx, &amp;originalBook.Metadata, &amp;polishedBook.Metadata, report); err != nil </span><span class="cov0" title="0">{
                return nil, report, err
        }</span>

        // Polish chapters
        <span class="cov0" title="0">totalChapters := len(originalBook.Chapters)
        for i := range originalBook.Chapters </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, report, ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">location := fmt.Sprintf("Chapter %d/%d", i+1, totalChapters)
                bp.emitProgress(fmt.Sprintf("Polishing %s", location), map[string]interface{}{
                        "chapter":  i + 1,
                        "total":    totalChapters,
                        "progress": float64(i+1) / float64(totalChapters) * 100,
                })

                if err := bp.polishChapter(
                        ctx,
                        &amp;originalBook.Chapters[i],
                        &amp;polishedBook.Chapters[i],
                        i+1,
                        report,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, report, err
                }</span>
        }

        // Finalize report
        <span class="cov0" title="0">report.Finalize()

        bp.emitProgress("Polishing completed", map[string]interface{}{
                "total_changes":    report.TotalChanges,
                "overall_score":    report.OverallScore,
                "consensus_rate":   report.ConsensusRate,
                "spirit_score":     report.AverageSpiritScore,
                "language_score":   report.AverageLanguageScore,
                "context_score":    report.AverageContextScore,
                "vocabulary_score": report.AverageVocabularyScore,
        })

        return polishedBook, report, nil</span>
}

// polishMetadata verifies and polishes book metadata
func (bp *BookPolisher) polishMetadata(
        ctx context.Context,
        original *ebook.Metadata,
        translated *ebook.Metadata,
        report *PolishingReport,
) error <span class="cov0" title="0">{
        // Polish title
        if original.Title != "" &amp;&amp; translated.Title != "" </span><span class="cov0" title="0">{
                result, err := bp.polishSection(
                        ctx,
                        "metadata_title",
                        "Book Title",
                        original.Title,
                        translated.Title,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">translated.Title = result.PolishedText
                report.AddSectionResult(result)</span>
        }

        // Polish description
        <span class="cov0" title="0">if original.Description != "" &amp;&amp; translated.Description != "" </span><span class="cov0" title="0">{
                result, err := bp.polishSection(
                        ctx,
                        "metadata_description",
                        "Book Description",
                        original.Description,
                        translated.Description,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">translated.Description = result.PolishedText
                report.AddSectionResult(result)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// polishChapter verifies and polishes a chapter
func (bp *BookPolisher) polishChapter(
        ctx context.Context,
        original *ebook.Chapter,
        translated *ebook.Chapter,
        chapterNum int,
        report *PolishingReport,
) error <span class="cov0" title="0">{
        location := fmt.Sprintf("Chapter %d", chapterNum)

        // Polish chapter title
        if original.Title != "" &amp;&amp; translated.Title != "" </span><span class="cov0" title="0">{
                result, err := bp.polishSection(
                        ctx,
                        fmt.Sprintf("chapter_%d_title", chapterNum),
                        location+" - Title",
                        original.Title,
                        translated.Title,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">translated.Title = result.PolishedText
                report.AddSectionResult(result)</span>
        }

        // Polish sections
        <span class="cov0" title="0">for i := range original.Sections </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">if err := bp.polishSectionRecursive(
                        ctx,
                        &amp;original.Sections[i],
                        &amp;translated.Sections[i],
                        fmt.Sprintf("%s, Section %d", location, i+1),
                        report,
                ); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// polishSectionRecursive verifies and polishes a section recursively
func (bp *BookPolisher) polishSectionRecursive(
        ctx context.Context,
        original *ebook.Section,
        translated *ebook.Section,
        location string,
        report *PolishingReport,
) error <span class="cov0" title="0">{
        // Polish section title
        if original.Title != "" &amp;&amp; translated.Title != "" </span><span class="cov0" title="0">{
                result, err := bp.polishSection(
                        ctx,
                        fmt.Sprintf("%s_title", strings.ReplaceAll(location, " ", "_")),
                        location+" - Title",
                        original.Title,
                        translated.Title,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">translated.Title = result.PolishedText
                report.AddSectionResult(result)</span>
        }

        // Polish section content
        <span class="cov0" title="0">if original.Content != "" &amp;&amp; translated.Content != "" </span><span class="cov0" title="0">{
                result, err := bp.polishSection(
                        ctx,
                        fmt.Sprintf("%s_content", strings.ReplaceAll(location, " ", "_")),
                        location+" - Content",
                        original.Content,
                        translated.Content,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">translated.Content = result.PolishedText
                report.AddSectionResult(result)</span>
        }

        // Polish subsections
        <span class="cov0" title="0">for i := range original.Subsections </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">if err := bp.polishSectionRecursive(
                        ctx,
                        &amp;original.Subsections[i],
                        &amp;translated.Subsections[i],
                        fmt.Sprintf("%s, Subsection %d", location, i+1),
                        report,
                ); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// polishSection performs multi-LLM verification and polishing for a single section
func (bp *BookPolisher) polishSection(
        ctx context.Context,
        sectionID string,
        location string,
        originalText string,
        translatedText string,
) (*PolishingResult, error) <span class="cov0" title="0">{
        // Get verifications from all LLMs in parallel
        verifications := make([]llmVerification, len(bp.config.Providers))
        var wg sync.WaitGroup
        var mu sync.Mutex
        errors := make([]error, len(bp.config.Providers))

        for i, provider := range bp.config.Providers </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(idx int, prov string) </span><span class="cov0" title="0">{
                        defer wg.Done()

                        verification, err := bp.verifyWithLLM(
                                ctx,
                                prov,
                                originalText,
                                translatedText,
                                location,
                        )

                        mu.Lock()
                        if err != nil </span><span class="cov0" title="0">{
                                errors[idx] = err
                        }</span> else<span class="cov0" title="0"> {
                                verifications[idx] = *verification
                        }</span>
                        <span class="cov0" title="0">mu.Unlock()</span>
                }(i, provider)
        }

        <span class="cov0" title="0">wg.Wait()

        // Check for errors
        for i, err := range errors </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        bp.emitWarning(fmt.Sprintf("Verification failed for %s with %s: %v",
                                location, bp.config.Providers[i], err))
                }</span>
        }

        // Build consensus from verifications
        <span class="cov0" title="0">result := bp.buildConsensus(
                sectionID,
                location,
                originalText,
                translatedText,
                verifications,
        )

        return result, nil</span>
}

// verifyWithLLM performs verification with a single LLM
func (bp *BookPolisher) verifyWithLLM(
        ctx context.Context,
        provider string,
        originalText string,
        translatedText string,
        location string,
) (*llmVerification, error) <span class="cov0" title="0">{
        translator := bp.translators[provider]

        // Create verification prompt
        prompt := bp.createVerificationPrompt(originalText, translatedText)

        // Get LLM analysis and polishing
        response, err := translator.Translate(ctx, prompt, location)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("LLM verification failed: %w", err)
        }</span>

        // Parse LLM response
        <span class="cov0" title="0">verification := bp.parseVerificationResponse(provider, response, translatedText)

        return verification, nil</span>
}

// createVerificationPrompt creates the multi-dimensional verification prompt
func (bp *BookPolisher) createVerificationPrompt(originalText, translatedText string) string <span class="cov8" title="1">{
        var dimensions []string

        if bp.config.VerifySpirit </span><span class="cov8" title="1">{
                dimensions = append(dimensions, "**Spirit**: Does the translation preserve the spirit, tone, and emotional resonance of the original?")
        }</span>
        <span class="cov8" title="1">if bp.config.VerifyLanguage </span><span class="cov8" title="1">{
                dimensions = append(dimensions, "**Language**: Is the target language natural, idiomatic, and grammatically correct?")
        }</span>
        <span class="cov8" title="1">if bp.config.VerifyContext </span><span class="cov8" title="1">{
                dimensions = append(dimensions, "**Context**: Are all contexts, deep meanings, and nuances properly conveyed?")
        }</span>
        <span class="cov8" title="1">if bp.config.VerifyVocabulary </span><span class="cov8" title="1">{
                dimensions = append(dimensions, "**Vocabulary**: Is the word choice rich, appropriate, and varied?")
        }</span>

        <span class="cov8" title="1">dimensionsList := strings.Join(dimensions, "\n")

        return fmt.Sprintf(`You are a professional translation quality assessor and polisher. Your task is to verify and improve a literary translation.

**Original Text (Russian):**
%s

**Current Translation (Serbian):**
%s

**Verification Dimensions:**
%s

**CRITICAL REQUIREMENT - Ekavica Dialect:**
All Serbian translations MUST use ONLY Ekavica dialect (–µ–∫–∞–≤–∏—Ü–∞), the standard dialect of Serbia.
- Use "–µ" instead of "–∏—ò–µ/—ò–µ": mleko (not mlijeko), dete (not dijete), pesma (not pjesma)
- Use hteo (not htio), lepo (not lijepo), reka (not rijeka)
- ANY use of Ijekavica forms (–∏—ò–µ/—ò–µ) is a CRITICAL ERROR that must be corrected

**CRITICAL REQUIREMENT - Pure Serbian Vocabulary:**
When translating to Serbian, ONLY use pure Serbian vocabulary. Replace any Croatian, Bosnian, or Montenegrin word choices with standard Serbian equivalents.
- Use standard Serbian words preferred in Serbia, not regional variants from other countries
- Avoid Croatianisms, Bosnianisms, or Montenegrin-specific vocabulary
- This ensures the translation is natural and idiomatic for Serbian readers in Serbia
- Example differences to avoid: Croatian "zrakoplov" ‚Üí Serbian "avion", Croatian "kazali≈°te" ‚Üí Serbian "pozori≈°te"

**Your Task:**
1. Evaluate the translation on each dimension listed above
2. Score each dimension from 0.0 to 1.0 (where 1.0 is perfect)
3. **CRITICAL**: Check for Ijekavica dialect usage - this is mandatory verification
4. Identify any issues or improvements needed
5. Provide a polished version if improvements are needed (always use Ekavica)

**Response Format:**
SPIRIT_SCORE: [0.0-1.0]
LANGUAGE_SCORE: [0.0-1.0]
CONTEXT_SCORE: [0.0-1.0]
VOCABULARY_SCORE: [0.0-1.0]

ISSUES:
[List any issues found, one per line with format "TYPE: description"]
[MUST include "DIALECT: Uses Ijekavica instead of Ekavica" if any Ijekavica forms detected]
[MUST include "VOCABULARY: Uses Croatian/Bosnian/Montenegrin words" if any regional vocabulary detected]

POLISHED_TEXT:
[Your improved version in Ekavica dialect, or UNCHANGED if translation is perfect]

EXPLANATION:
[Brief explanation of changes made and why, especially any dialect corrections]`,
                originalText,
                translatedText,
                dimensionsList)</span>
}

// parseVerificationResponse parses LLM verification response
func (bp *BookPolisher) parseVerificationResponse(
        provider string,
        response string,
        originalTranslation string,
) *llmVerification <span class="cov8" title="1">{
        verification := &amp;llmVerification{
                Provider:        provider,
                SpiritScore:     0.9, // Default scores
                LanguageScore:   0.9,
                ContextScore:    0.9,
                VocabularyScore: 0.9,
                Suggestions:     make([]string, 0),
                PolishedText:    originalTranslation,
                Issues:          make([]Issue, 0),
        }

        // Parse scores
        if score := extractScore(response, "SPIRIT_SCORE:"); score &gt;= 0 </span><span class="cov8" title="1">{
                verification.SpiritScore = score
        }</span>
        <span class="cov8" title="1">if score := extractScore(response, "LANGUAGE_SCORE:"); score &gt;= 0 </span><span class="cov8" title="1">{
                verification.LanguageScore = score
        }</span>
        <span class="cov8" title="1">if score := extractScore(response, "CONTEXT_SCORE:"); score &gt;= 0 </span><span class="cov8" title="1">{
                verification.ContextScore = score
        }</span>
        <span class="cov8" title="1">if score := extractScore(response, "VOCABULARY_SCORE:"); score &gt;= 0 </span><span class="cov8" title="1">{
                verification.VocabularyScore = score
        }</span>

        // Extract polished text
        <span class="cov8" title="1">if polished := extractSection(response, "POLISHED_TEXT:", "EXPLANATION:"); polished != "" </span><span class="cov8" title="1">{
                polished = strings.TrimSpace(polished)
                if polished != "UNCHANGED" &amp;&amp; polished != "" </span><span class="cov8" title="1">{
                        verification.PolishedText = polished
                }</span>
        }

        // Extract issues
        <span class="cov8" title="1">if issuesText := extractSection(response, "ISSUES:", "POLISHED_TEXT:"); issuesText != "" </span><span class="cov8" title="1">{
                lines := strings.Split(issuesText, "\n")
                for _, line := range lines </span><span class="cov8" title="1">{
                        line = strings.TrimSpace(line)
                        if line == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">parts := strings.SplitN(line, ":", 2)
                        if len(parts) == 2 </span><span class="cov8" title="1">{
                                issueType := strings.ToLower(strings.TrimSpace(parts[0]))
                                description := strings.TrimSpace(parts[1])

                                verification.Issues = append(verification.Issues, Issue{
                                        Type:        issueType,
                                        Severity:    "minor",
                                        Description: description,
                                        Location:    "",
                                })
                        }</span>
                }
        }

        <span class="cov8" title="1">return verification</span>
}

// buildConsensus builds consensus from multiple LLM verifications
func (bp *BookPolisher) buildConsensus(
        sectionID string,
        location string,
        originalText string,
        translatedText string,
        verifications []llmVerification,
) *PolishingResult <span class="cov8" title="1">{
        result := &amp;PolishingResult{
                SectionID:      sectionID,
                Location:       location,
                OriginalText:   originalText,
                TranslatedText: translatedText,
                PolishedText:   translatedText, // Default to original
                Changes:        make([]Change, 0),
                Issues:         make([]Issue, 0),
                Suggestions:    make([]Suggestion, 0),
        }

        // Calculate average scores
        totalSpirit := 0.0
        totalLanguage := 0.0
        totalContext := 0.0
        totalVocabulary := 0.0
        count := float64(len(verifications))

        for _, v := range verifications </span><span class="cov8" title="1">{
                totalSpirit += v.SpiritScore
                totalLanguage += v.LanguageScore
                totalContext += v.ContextScore
                totalVocabulary += v.VocabularyScore

                // Collect issues
                for _, issue := range v.Issues </span><span class="cov0" title="0">{
                        issue.Location = location
                        result.Issues = append(result.Issues, issue)
                }</span>
        }

        <span class="cov8" title="1">if count &gt; 0 </span><span class="cov8" title="1">{
                result.SpiritScore = totalSpirit / count
                result.LanguageScore = totalLanguage / count
                result.ContextScore = totalContext / count
                result.VocabularyScore = totalVocabulary / count
                result.OverallScore = (result.SpiritScore + result.LanguageScore +
                        result.ContextScore + result.VocabularyScore) / 4.0
        }</span>

        // Check consensus for polishing
        <span class="cov8" title="1">polishedVersions := make(map[string]int)
        for _, v := range verifications </span><span class="cov8" title="1">{
                if v.PolishedText != translatedText </span><span class="cov8" title="1">{
                        polishedVersions[v.PolishedText]++
                }</span>
        }

        // Find most agreed-upon polished version
        <span class="cov8" title="1">maxAgreement := 0
        bestPolished := translatedText

        for polished, agreement := range polishedVersions </span><span class="cov8" title="1">{
                if agreement &gt; maxAgreement </span><span class="cov8" title="1">{
                        maxAgreement = agreement
                        bestPolished = polished
                }</span>
        }

        <span class="cov8" title="1">result.Consensus = maxAgreement
        result.Confidence = float64(maxAgreement) / count

        // Apply polished version if consensus reached
        if maxAgreement &gt;= bp.config.MinConsensus </span><span class="cov8" title="1">{
                result.PolishedText = bestPolished

                // Record change
                if bestPolished != translatedText </span><span class="cov8" title="1">{
                        result.Changes = append(result.Changes, Change{
                                Location:   location,
                                Original:   translatedText,
                                Polished:   bestPolished,
                                Reason:     "Multi-LLM consensus improvement",
                                Agreement:  maxAgreement,
                                Confidence: result.Confidence,
                        })
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

// Helper functions

func extractScore(text, prefix string) float64 <span class="cov8" title="1">{
        lines := strings.Split(text, "\n")
        for _, line := range lines </span><span class="cov8" title="1">{
                if strings.HasPrefix(strings.TrimSpace(line), prefix) </span><span class="cov8" title="1">{
                        scoreStr := strings.TrimPrefix(strings.TrimSpace(line), prefix)
                        scoreStr = strings.TrimSpace(scoreStr)

                        var score float64
                        if _, err := fmt.Sscanf(scoreStr, "%f", &amp;score); err == nil </span><span class="cov8" title="1">{
                                if score &gt;= 0.0 &amp;&amp; score &lt;= 1.0 </span><span class="cov8" title="1">{
                                        return score
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return -1.0</span>
}

func extractSection(text, startMarker, endMarker string) string <span class="cov8" title="1">{
        startIdx := strings.Index(text, startMarker)
        if startIdx == -1 </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">startIdx += len(startMarker)

        endIdx := strings.Index(text[startIdx:], endMarker)
        if endIdx == -1 </span><span class="cov8" title="1">{
                return strings.TrimSpace(text[startIdx:])
        }</span>

        <span class="cov8" title="1">return strings.TrimSpace(text[startIdx : startIdx+endIdx])</span>
}

func (bp *BookPolisher) emitProgress(message string, data map[string]interface{}) <span class="cov0" title="0">{
        if bp.eventBus != nil </span><span class="cov0" title="0">{
                event := events.NewEvent("polishing_progress", message, data)
                event.SessionID = bp.sessionID
                bp.eventBus.Publish(event)
        }</span>
}

func (bp *BookPolisher) emitWarning(message string) <span class="cov0" title="0">{
        if bp.eventBus != nil </span><span class="cov0" title="0">{
                event := events.NewEvent("polishing_warning", message, nil)
                event.SessionID = bp.sessionID
                bp.eventBus.Publish(event)
        }</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package verification

import (
        "fmt"
        "sort"
        "strings"
        "time"

        "golang.org/x/text/cases"
        "golang.org/x/text/language"
)

// PolishingReport contains comprehensive details of the polishing process
type PolishingReport struct {
        // Configuration
        Config PolishingConfig

        // Timing
        StartTime time.Time
        EndTime   time.Time
        Duration  time.Duration

        // Section results
        SectionResults []*PolishingResult

        // Aggregate statistics
        TotalSections    int
        TotalChanges     int
        TotalIssues      int
        TotalSuggestions int

        // Consensus statistics
        ConsensusRate     float64 // Percentage of sections where consensus was reached
        AverageConfidence float64

        // Quality scores
        AverageSpiritScore     float64
        AverageLanguageScore   float64
        AverageContextScore    float64
        AverageVocabularyScore float64
        OverallScore           float64

        // Issue breakdown by type
        IssuesByType     map[string]int
        IssuesBySeverity map[string]int

        // Provider statistics
        ProviderAgreements map[string]int // How often each provider agreed with consensus
        ProviderScores     map[string]float64

        // Top issues and changes
        TopIssues          []Issue
        SignificantChanges []Change
}

// NewPolishingReport creates a new polishing report
func NewPolishingReport(config PolishingConfig) *PolishingReport <span class="cov0" title="0">{
        return &amp;PolishingReport{
                Config:             config,
                StartTime:          time.Now(),
                SectionResults:     make([]*PolishingResult, 0),
                IssuesByType:       make(map[string]int),
                IssuesBySeverity:   make(map[string]int),
                ProviderAgreements: make(map[string]int),
                ProviderScores:     make(map[string]float64),
                TopIssues:          make([]Issue, 0),
                SignificantChanges: make([]Change, 0),
        }
}</span>

// AddSectionResult adds a section result to the report
func (pr *PolishingReport) AddSectionResult(result *PolishingResult) <span class="cov0" title="0">{
        pr.SectionResults = append(pr.SectionResults, result)

        // Update statistics
        pr.TotalSections++
        pr.TotalChanges += len(result.Changes)
        pr.TotalIssues += len(result.Issues)
        pr.TotalSuggestions += len(result.Suggestions)

        // Track issues by type and severity
        for _, issue := range result.Issues </span><span class="cov0" title="0">{
                pr.IssuesByType[issue.Type]++
                pr.IssuesBySeverity[issue.Severity]++

                // Track significant issues
                if issue.Severity == "critical" || issue.Severity == "major" </span><span class="cov0" title="0">{
                        pr.TopIssues = append(pr.TopIssues, issue)
                }</span>
        }

        // Track significant changes (high confidence)
        <span class="cov0" title="0">for _, change := range result.Changes </span><span class="cov0" title="0">{
                if change.Confidence &gt;= 0.8 </span><span class="cov0" title="0">{
                        pr.SignificantChanges = append(pr.SignificantChanges, change)
                }</span>
        }
}

// Finalize completes the report calculations
func (pr *PolishingReport) Finalize() <span class="cov0" title="0">{
        pr.EndTime = time.Now()
        pr.Duration = pr.EndTime.Sub(pr.StartTime)

        if pr.TotalSections == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // Calculate averages
        <span class="cov0" title="0">totalSpirit := 0.0
        totalLanguage := 0.0
        totalContext := 0.0
        totalVocabulary := 0.0
        totalConfidence := 0.0
        consensusCount := 0

        for _, result := range pr.SectionResults </span><span class="cov0" title="0">{
                totalSpirit += result.SpiritScore
                totalLanguage += result.LanguageScore
                totalContext += result.ContextScore
                totalVocabulary += result.VocabularyScore
                totalConfidence += result.Confidence

                if result.Consensus &gt;= pr.Config.MinConsensus </span><span class="cov0" title="0">{
                        consensusCount++
                }</span>
        }

        <span class="cov0" title="0">count := float64(pr.TotalSections)
        pr.AverageSpiritScore = totalSpirit / count
        pr.AverageLanguageScore = totalLanguage / count
        pr.AverageContextScore = totalContext / count
        pr.AverageVocabularyScore = totalVocabulary / count
        pr.AverageConfidence = totalConfidence / count
        pr.OverallScore = (pr.AverageSpiritScore + pr.AverageLanguageScore +
                pr.AverageContextScore + pr.AverageVocabularyScore) / 4.0
        pr.ConsensusRate = float64(consensusCount) / count * 100.0

        // Sort top issues by severity
        sort.Slice(pr.TopIssues, func(i, j int) bool </span><span class="cov0" title="0">{
                severityOrder := map[string]int{"critical": 0, "major": 1, "minor": 2}
                return severityOrder[pr.TopIssues[i].Severity] &lt; severityOrder[pr.TopIssues[j].Severity]
        }</span>)

        // Limit top issues
        <span class="cov0" title="0">if len(pr.TopIssues) &gt; 50 </span><span class="cov0" title="0">{
                pr.TopIssues = pr.TopIssues[:50]
        }</span>

        // Sort significant changes by confidence
        <span class="cov0" title="0">sort.Slice(pr.SignificantChanges, func(i, j int) bool </span><span class="cov0" title="0">{
                return pr.SignificantChanges[i].Confidence &gt; pr.SignificantChanges[j].Confidence
        }</span>)

        // Limit significant changes
        <span class="cov0" title="0">if len(pr.SignificantChanges) &gt; 100 </span><span class="cov0" title="0">{
                pr.SignificantChanges = pr.SignificantChanges[:100]
        }</span>
}

// GenerateMarkdownReport generates a detailed markdown report
func (pr *PolishingReport) GenerateMarkdownReport() string <span class="cov0" title="0">{
        var sb strings.Builder

        // Header
        sb.WriteString("# Translation Polishing Report\n\n")
        sb.WriteString(fmt.Sprintf("**Generated:** %s\n\n",
                pr.EndTime.Format("2006-01-02 15:04:05")))
        sb.WriteString(fmt.Sprintf("**Duration:** %s\n\n",
                pr.Duration.Round(time.Second)))

        // Configuration
        sb.WriteString("## Configuration\n\n")
        sb.WriteString(fmt.Sprintf("- **LLM Providers:** %s\n",
                strings.Join(pr.Config.Providers, ", ")))
        sb.WriteString(fmt.Sprintf("- **Minimum Consensus:** %d/%d providers\n",
                pr.Config.MinConsensus, len(pr.Config.Providers)))
        sb.WriteString("- **Verification Dimensions:**\n")
        if pr.Config.VerifySpirit </span><span class="cov0" title="0">{
                sb.WriteString("  - ‚úÖ Spirit &amp; Tone\n")
        }</span>
        <span class="cov0" title="0">if pr.Config.VerifyLanguage </span><span class="cov0" title="0">{
                sb.WriteString("  - ‚úÖ Language Quality\n")
        }</span>
        <span class="cov0" title="0">if pr.Config.VerifyContext </span><span class="cov0" title="0">{
                sb.WriteString("  - ‚úÖ Context &amp; Meaning\n")
        }</span>
        <span class="cov0" title="0">if pr.Config.VerifyVocabulary </span><span class="cov0" title="0">{
                sb.WriteString("  - ‚úÖ Vocabulary Richness\n")
        }</span>
        <span class="cov0" title="0">sb.WriteString("\n")

        // Executive Summary
        sb.WriteString("## Executive Summary\n\n")
        sb.WriteString(fmt.Sprintf("- **Total Sections Verified:** %d\n", pr.TotalSections))
        sb.WriteString(fmt.Sprintf("- **Total Changes Made:** %d\n", pr.TotalChanges))
        sb.WriteString(fmt.Sprintf("- **Consensus Rate:** %.1f%%\n", pr.ConsensusRate))
        sb.WriteString(fmt.Sprintf("- **Average Confidence:** %.1f%%\n", pr.AverageConfidence*100))
        sb.WriteString(fmt.Sprintf("- **Overall Quality Score:** %.1f%%\n", pr.OverallScore*100))
        sb.WriteString("\n")

        // Quality Scores
        sb.WriteString("## Quality Scores\n\n")
        sb.WriteString("| Dimension | Score | Grade |\n")
        sb.WriteString("|-----------|-------|-------|\n")
        sb.WriteString(fmt.Sprintf("| **Spirit &amp; Tone** | %.1f%% | %s |\n",
                pr.AverageSpiritScore*100, getGrade(pr.AverageSpiritScore)))
        sb.WriteString(fmt.Sprintf("| **Language Quality** | %.1f%% | %s |\n",
                pr.AverageLanguageScore*100, getGrade(pr.AverageLanguageScore)))
        sb.WriteString(fmt.Sprintf("| **Context &amp; Meaning** | %.1f%% | %s |\n",
                pr.AverageContextScore*100, getGrade(pr.AverageContextScore)))
        sb.WriteString(fmt.Sprintf("| **Vocabulary Richness** | %.1f%% | %s |\n",
                pr.AverageVocabularyScore*100, getGrade(pr.AverageVocabularyScore)))
        sb.WriteString(fmt.Sprintf("| **Overall** | %.1f%% | %s |\n",
                pr.OverallScore*100, getGrade(pr.OverallScore)))
        sb.WriteString("\n")

        // Issues Summary
        if pr.TotalIssues &gt; 0 </span><span class="cov0" title="0">{
                sb.WriteString("## Issues Summary\n\n")
                sb.WriteString(fmt.Sprintf("**Total Issues Found:** %d\n\n", pr.TotalIssues))

                // By severity
                if len(pr.IssuesBySeverity) &gt; 0 </span><span class="cov0" title="0">{
                        sb.WriteString("### By Severity\n\n")
                        for severity, count := range pr.IssuesBySeverity </span><span class="cov0" title="0">{
                                icon := "‚ÑπÔ∏è"
                                if severity == "critical" </span><span class="cov0" title="0">{
                                        icon = "üî¥"
                                }</span> else<span class="cov0" title="0"> if severity == "major" </span><span class="cov0" title="0">{
                                        icon = "üü†"
                                }</span>
                                <span class="cov0" title="0">sb.WriteString(fmt.Sprintf("- %s **%s:** %d\n", icon, severity, count))</span>
                        }
                        <span class="cov0" title="0">sb.WriteString("\n")</span>
                }

                // By type
                <span class="cov0" title="0">if len(pr.IssuesByType) &gt; 0 </span><span class="cov0" title="0">{
                        sb.WriteString("### By Type\n\n")
                        for issueType, count := range pr.IssuesByType </span><span class="cov0" title="0">{
                                sb.WriteString(fmt.Sprintf("- **%s:** %d\n", issueType, count))
                        }</span>
                        <span class="cov0" title="0">sb.WriteString("\n")</span>
                }
        }

        // Top Issues
        <span class="cov0" title="0">if len(pr.TopIssues) &gt; 0 </span><span class="cov0" title="0">{
                sb.WriteString("## Top Issues\n\n")
                sb.WriteString("These are the most significant issues found:\n\n")

                displayCount := len(pr.TopIssues)
                if displayCount &gt; 20 </span><span class="cov0" title="0">{
                        displayCount = 20
                }</span>

                <span class="cov0" title="0">for i := 0; i &lt; displayCount; i++ </span><span class="cov0" title="0">{
                        issue := pr.TopIssues[i]
                        icon := "‚ÑπÔ∏è"
                        if issue.Severity == "critical" </span><span class="cov0" title="0">{
                                icon = "üî¥"
                        }</span> else<span class="cov0" title="0"> if issue.Severity == "major" </span><span class="cov0" title="0">{
                                icon = "üü†"
                        }</span>

                        <span class="cov0" title="0">sb.WriteString(fmt.Sprintf("### %s %s - %s\n\n",
                                icon, cases.Title(language.English, cases.Compact).String(issue.Severity), issue.Location))
                        sb.WriteString(fmt.Sprintf("**Type:** %s\n\n", issue.Type))
                        sb.WriteString(fmt.Sprintf("**Description:** %s\n\n", issue.Description))
                        if issue.Suggestion != "" </span><span class="cov0" title="0">{
                                sb.WriteString(fmt.Sprintf("**Suggestion:** %s\n\n", issue.Suggestion))
                        }</span>
                        <span class="cov0" title="0">sb.WriteString("---\n\n")</span>
                }
        }

        // Significant Changes
        <span class="cov0" title="0">if len(pr.SignificantChanges) &gt; 0 </span><span class="cov0" title="0">{
                sb.WriteString("## Significant Changes\n\n")
                sb.WriteString("These are the most impactful improvements made:\n\n")

                displayCount := len(pr.SignificantChanges)
                if displayCount &gt; 30 </span><span class="cov0" title="0">{
                        displayCount = 30
                }</span>

                <span class="cov0" title="0">for i := 0; i &lt; displayCount; i++ </span><span class="cov0" title="0">{
                        change := pr.SignificantChanges[i]
                        sb.WriteString(fmt.Sprintf("### %s\n\n", change.Location))
                        sb.WriteString(fmt.Sprintf("**Confidence:** %.1f%% (%d/%d LLMs agreed)\n\n",
                                change.Confidence*100, change.Agreement, len(pr.Config.Providers)))
                        sb.WriteString(fmt.Sprintf("**Reason:** %s\n\n", change.Reason))
                        sb.WriteString("**Original:**\n```\n")
                        sb.WriteString(truncateForDisplay(change.Original, 200))
                        sb.WriteString("\n```\n\n")
                        sb.WriteString("**Polished:**\n```\n")
                        sb.WriteString(truncateForDisplay(change.Polished, 200))
                        sb.WriteString("\n```\n\n")
                        sb.WriteString("---\n\n")
                }</span>
        }

        // Detailed Section Results
        <span class="cov0" title="0">sb.WriteString("## Detailed Section Results\n\n")
        sb.WriteString("Complete verification results for all sections:\n\n")

        for _, result := range pr.SectionResults </span><span class="cov0" title="0">{
                sb.WriteString(fmt.Sprintf("### %s\n\n", result.Location))

                // Scores
                sb.WriteString("**Quality Scores:**\n")
                sb.WriteString(fmt.Sprintf("- Spirit: %.1f%%\n", result.SpiritScore*100))
                sb.WriteString(fmt.Sprintf("- Language: %.1f%%\n", result.LanguageScore*100))
                sb.WriteString(fmt.Sprintf("- Context: %.1f%%\n", result.ContextScore*100))
                sb.WriteString(fmt.Sprintf("- Vocabulary: %.1f%%\n", result.VocabularyScore*100))
                sb.WriteString(fmt.Sprintf("- Overall: %.1f%%\n\n", result.OverallScore*100))

                // Consensus
                if result.Consensus &gt;= pr.Config.MinConsensus </span><span class="cov0" title="0">{
                        sb.WriteString(fmt.Sprintf("**Consensus:** ‚úÖ %d/%d providers agreed\n\n",
                                result.Consensus, len(pr.Config.Providers)))
                }</span> else<span class="cov0" title="0"> {
                        sb.WriteString(fmt.Sprintf("**Consensus:** ‚ùå No consensus (%d/%d required)\n\n",
                                pr.Config.MinConsensus, len(pr.Config.Providers)))
                }</span>

                // Changes
                <span class="cov0" title="0">if len(result.Changes) &gt; 0 </span><span class="cov0" title="0">{
                        sb.WriteString("**Changes Made:**\n")
                        for _, change := range result.Changes </span><span class="cov0" title="0">{
                                sb.WriteString(fmt.Sprintf("- %s (confidence: %.1f%%)\n",
                                        change.Reason, change.Confidence*100))
                        }</span>
                        <span class="cov0" title="0">sb.WriteString("\n")</span>
                }

                // Issues
                <span class="cov0" title="0">if len(result.Issues) &gt; 0 </span><span class="cov0" title="0">{
                        sb.WriteString("**Issues Found:**\n")
                        for _, issue := range result.Issues </span><span class="cov0" title="0">{
                                sb.WriteString(fmt.Sprintf("- [%s] %s: %s\n",
                                        issue.Severity, issue.Type, issue.Description))
                        }</span>
                        <span class="cov0" title="0">sb.WriteString("\n")</span>
                }

                <span class="cov0" title="0">sb.WriteString("---\n\n")</span>
        }

        // Footer
        <span class="cov0" title="0">sb.WriteString("## Conclusion\n\n")
        if pr.OverallScore &gt;= 0.95 </span><span class="cov0" title="0">{
                sb.WriteString("‚úÖ **Excellent** - Translation quality is outstanding.\n")
        }</span> else<span class="cov0" title="0"> if pr.OverallScore &gt;= 0.85 </span><span class="cov0" title="0">{
                sb.WriteString("‚úÖ **Good** - Translation quality is very good with minor improvements made.\n")
        }</span> else<span class="cov0" title="0"> if pr.OverallScore &gt;= 0.75 </span><span class="cov0" title="0">{
                sb.WriteString("‚ö†Ô∏è **Acceptable** - Translation quality is acceptable with some improvements made.\n")
        }</span> else<span class="cov0" title="0"> {
                sb.WriteString("‚ùå **Needs Improvement** - Significant issues were found and addressed.\n")
        }</span>
        <span class="cov0" title="0">sb.WriteString("\n")
        sb.WriteString(fmt.Sprintf("A total of **%d changes** were made to improve translation quality.\n",
                pr.TotalChanges))

        return sb.String()</span>
}

// GenerateJSONReport generates a JSON report (structure only, actual JSON marshaling done by caller)
func (pr *PolishingReport) GenerateJSONReport() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "timestamp": pr.EndTime.Format(time.RFC3339),
                "duration":  pr.Duration.String(),
                "config": map[string]interface{}{
                        "providers":         pr.Config.Providers,
                        "min_consensus":     pr.Config.MinConsensus,
                        "verify_spirit":     pr.Config.VerifySpirit,
                        "verify_language":   pr.Config.VerifyLanguage,
                        "verify_context":    pr.Config.VerifyContext,
                        "verify_vocabulary": pr.Config.VerifyVocabulary,
                },
                "summary": map[string]interface{}{
                        "total_sections":     pr.TotalSections,
                        "total_changes":      pr.TotalChanges,
                        "total_issues":       pr.TotalIssues,
                        "total_suggestions":  pr.TotalSuggestions,
                        "consensus_rate":     pr.ConsensusRate,
                        "average_confidence": pr.AverageConfidence,
                },
                "quality_scores": map[string]interface{}{
                        "spirit":     pr.AverageSpiritScore,
                        "language":   pr.AverageLanguageScore,
                        "context":    pr.AverageContextScore,
                        "vocabulary": pr.AverageVocabularyScore,
                        "overall":    pr.OverallScore,
                },
                "issues": map[string]interface{}{
                        "by_type":     pr.IssuesByType,
                        "by_severity": pr.IssuesBySeverity,
                        "top_issues":  pr.TopIssues,
                },
                "changes": map[string]interface{}{
                        "significant_changes": pr.SignificantChanges,
                },
                "section_results": pr.SectionResults,
        }
}</span>

// GenerateSummary generates a brief text summary
func (pr *PolishingReport) GenerateSummary() string <span class="cov0" title="0">{
        var sb strings.Builder

        sb.WriteString("=== POLISHING SUMMARY ===\n\n")
        sb.WriteString(fmt.Sprintf("Duration: %s\n", pr.Duration.Round(time.Second)))
        sb.WriteString(fmt.Sprintf("Sections Verified: %d\n", pr.TotalSections))
        sb.WriteString(fmt.Sprintf("Changes Made: %d\n", pr.TotalChanges))
        sb.WriteString(fmt.Sprintf("Consensus Rate: %.1f%%\n", pr.ConsensusRate))
        sb.WriteString(fmt.Sprintf("Overall Quality: %.1f%% (%s)\n\n",
                pr.OverallScore*100, getGrade(pr.OverallScore)))

        sb.WriteString("Quality Breakdown:\n")
        sb.WriteString(fmt.Sprintf("  Spirit:     %.1f%%\n", pr.AverageSpiritScore*100))
        sb.WriteString(fmt.Sprintf("  Language:   %.1f%%\n", pr.AverageLanguageScore*100))
        sb.WriteString(fmt.Sprintf("  Context:    %.1f%%\n", pr.AverageContextScore*100))
        sb.WriteString(fmt.Sprintf("  Vocabulary: %.1f%%\n\n", pr.AverageVocabularyScore*100))

        if pr.TotalIssues &gt; 0 </span><span class="cov0" title="0">{
                sb.WriteString(fmt.Sprintf("Issues Found: %d\n", pr.TotalIssues))
                for severity, count := range pr.IssuesBySeverity </span><span class="cov0" title="0">{
                        sb.WriteString(fmt.Sprintf("  %s: %d\n", cases.Title(language.English, cases.Compact).String(severity), count))
                }</span>
        }

        <span class="cov0" title="0">return sb.String()</span>
}

// Helper functions

func getGrade(score float64) string <span class="cov0" title="0">{
        if score &gt;= 0.95 </span><span class="cov0" title="0">{
                return "A+"
        }</span> else<span class="cov0" title="0"> if score &gt;= 0.90 </span><span class="cov0" title="0">{
                return "A"
        }</span> else<span class="cov0" title="0"> if score &gt;= 0.85 </span><span class="cov0" title="0">{
                return "A-"
        }</span> else<span class="cov0" title="0"> if score &gt;= 0.80 </span><span class="cov0" title="0">{
                return "B+"
        }</span> else<span class="cov0" title="0"> if score &gt;= 0.75 </span><span class="cov0" title="0">{
                return "B"
        }</span> else<span class="cov0" title="0"> if score &gt;= 0.70 </span><span class="cov0" title="0">{
                return "B-"
        }</span> else<span class="cov0" title="0"> if score &gt;= 0.65 </span><span class="cov0" title="0">{
                return "C+"
        }</span> else<span class="cov0" title="0"> if score &gt;= 0.60 </span><span class="cov0" title="0">{
                return "C"
        }</span> else<span class="cov0" title="0"> {
                return "D"
        }</span>
}

func truncateForDisplay(text string, maxLen int) string <span class="cov0" title="0">{
        if len(text) &lt;= maxLen </span><span class="cov0" title="0">{
                return text
        }</span>
        <span class="cov0" title="0">return text[:maxLen] + "..."</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package verification

import (
        "context"
        "fmt"
        "regexp"
        "strings"
        "unicode"

        "digital.vasic.translator/pkg/ebook"
        "digital.vasic.translator/pkg/events"
        "digital.vasic.translator/pkg/language"
)

// VerificationResult represents the result of content verification
type VerificationResult struct {
        IsValid            bool
        UntranslatedBlocks []UntranslatedBlock
        HTMLArtifacts      []HTMLArtifact
        QualityScore       float64
        Warnings           []string
        Errors             []string
}

// UntranslatedBlock represents a piece of content that wasn't translated
type UntranslatedBlock struct {
        Location    string // e.g., "Chapter 5, Section 2, Paragraph 3"
        OriginalText string
        Language     string
        Length       int
}

// HTMLArtifact represents HTML/XML found in translated content
type HTMLArtifact struct {
        Location string
        Content  string
        Type     string // "tag", "entity", "attribute"
}

// Verifier validates translation quality
type Verifier struct {
        sourceLanguage language.Language
        targetLanguage language.Language
        eventBus       *events.EventBus
        sessionID      string
}

// NewVerifier creates a new content verifier
func NewVerifier(
        sourceLanguage, targetLanguage language.Language,
        eventBus *events.EventBus,
        sessionID string,
) *Verifier <span class="cov0" title="0">{
        return &amp;Verifier{
                sourceLanguage: sourceLanguage,
                targetLanguage: targetLanguage,
                eventBus:       eventBus,
                sessionID:      sessionID,
        }
}</span>

// VerifyBook performs comprehensive verification of translated book
func (v *Verifier) VerifyBook(ctx context.Context, book *ebook.Book) (*VerificationResult, error) <span class="cov0" title="0">{
        result := &amp;VerificationResult{
                IsValid:            true,
                UntranslatedBlocks: make([]UntranslatedBlock, 0),
                HTMLArtifacts:      make([]HTMLArtifact, 0),
                Warnings:           make([]string, 0),
                Errors:             make([]string, 0),
        }

        // Emit verification start event
        v.emitEvent(events.Event{
                Type:      "verification_started",
                SessionID: v.sessionID,
                Message:   "Starting translation verification",
        })

        // Verify metadata
        if err := v.verifyMetadata(&amp;book.Metadata, result); err != nil </span><span class="cov0" title="0">{
                return result, err
        }</span>

        // Verify chapters
        <span class="cov0" title="0">totalChapters := len(book.Chapters)
        for i := range book.Chapters </span><span class="cov0" title="0">{
                location := fmt.Sprintf("Chapter %d/%d", i+1, totalChapters)

                v.emitEvent(events.Event{
                        Type:      "verification_progress",
                        SessionID: v.sessionID,
                        Message:   fmt.Sprintf("Verifying %s", location),
                        Data: map[string]interface{}{
                                "chapter":        i + 1,
                                "total_chapters": totalChapters,
                                "progress":       float64(i+1) / float64(totalChapters) * 100,
                        },
                })

                if err := v.verifyChapter(&amp;book.Chapters[i], i+1, result); err != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>
        }

        // Calculate quality score
        <span class="cov0" title="0">result.QualityScore = v.calculateQualityScore(result, book)

        // Determine if valid
        result.IsValid = len(result.Errors) == 0 &amp;&amp; result.QualityScore &gt;= 0.95

        // Emit completion event
        completionEvent := events.NewEvent(
                "verification_completed",
                fmt.Sprintf("Verification completed - Score: %.2f%%", result.QualityScore*100),
                map[string]interface{}{
                        "quality_score":       result.QualityScore,
                        "is_valid":            result.IsValid,
                        "untranslated_blocks": len(result.UntranslatedBlocks),
                        "html_artifacts":      len(result.HTMLArtifacts),
                        "warnings":            len(result.Warnings),
                        "errors":              len(result.Errors),
                },
        )
        completionEvent.SessionID = v.sessionID
        v.emitEvent(completionEvent)

        // Emit warnings for untranslated content
        if len(result.UntranslatedBlocks) &gt; 0 </span><span class="cov0" title="0">{
                v.emitWarning(fmt.Sprintf("Found %d untranslated blocks", len(result.UntranslatedBlocks)))
                for i, block := range result.UntranslatedBlocks </span><span class="cov0" title="0">{
                        if i &lt; 10 </span><span class="cov0" title="0">{ // Limit to first 10 warnings
                                v.emitWarning(fmt.Sprintf("Untranslated: %s - %s", block.Location, truncate(block.OriginalText, 100)))
                        }</span>
                }
        }

        // Emit warnings for HTML artifacts
        <span class="cov0" title="0">if len(result.HTMLArtifacts) &gt; 0 </span><span class="cov0" title="0">{
                v.emitWarning(fmt.Sprintf("Found %d HTML artifacts in translation", len(result.HTMLArtifacts)))
                for i, artifact := range result.HTMLArtifacts </span><span class="cov0" title="0">{
                        if i &lt; 10 </span><span class="cov0" title="0">{ // Limit to first 10 warnings
                                v.emitWarning(fmt.Sprintf("HTML in %s: %s", artifact.Location, artifact.Content))
                        }</span>
                }
        }

        <span class="cov0" title="0">return result, nil</span>
}

// verifyMetadata checks if metadata is properly translated
func (v *Verifier) verifyMetadata(metadata *ebook.Metadata, result *VerificationResult) error <span class="cov0" title="0">{
        if metadata.Title != "" </span><span class="cov0" title="0">{
                if v.isSourceLanguage(metadata.Title) </span><span class="cov0" title="0">{
                        result.UntranslatedBlocks = append(result.UntranslatedBlocks, UntranslatedBlock{
                                Location:    "Book Title",
                                OriginalText: metadata.Title,
                                Language:     v.sourceLanguage.Code,
                                Length:       len(metadata.Title),
                        })
                        result.Errors = append(result.Errors, "Book title not translated")
                }</span>
        }

        <span class="cov0" title="0">if metadata.Description != "" </span><span class="cov0" title="0">{
                if v.isSourceLanguage(metadata.Description) </span><span class="cov0" title="0">{
                        result.UntranslatedBlocks = append(result.UntranslatedBlocks, UntranslatedBlock{
                                Location:    "Book Description",
                                OriginalText: truncate(metadata.Description, 200),
                                Language:     v.sourceLanguage.Code,
                                Length:       len(metadata.Description),
                        })
                        result.Warnings = append(result.Warnings, "Book description not translated")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// verifyChapter checks if chapter is properly translated
func (v *Verifier) verifyChapter(chapter *ebook.Chapter, chapterNum int, result *VerificationResult) error <span class="cov0" title="0">{
        location := fmt.Sprintf("Chapter %d", chapterNum)

        // Verify chapter title
        if chapter.Title != "" </span><span class="cov0" title="0">{
                if v.isSourceLanguage(chapter.Title) </span><span class="cov0" title="0">{
                        result.UntranslatedBlocks = append(result.UntranslatedBlocks, UntranslatedBlock{
                                Location:    location + " - Title",
                                OriginalText: chapter.Title,
                                Language:     v.sourceLanguage.Code,
                                Length:       len(chapter.Title),
                        })
                        result.Errors = append(result.Errors, fmt.Sprintf("%s title not translated", location))
                }</span>
        }

        // Verify sections
        <span class="cov0" title="0">for i := range chapter.Sections </span><span class="cov0" title="0">{
                sectionLoc := fmt.Sprintf("%s, Section %d", location, i+1)
                if err := v.verifySection(&amp;chapter.Sections[i], sectionLoc, result); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// verifySection checks if section is properly translated
func (v *Verifier) verifySection(section *ebook.Section, location string, result *VerificationResult) error <span class="cov0" title="0">{
        // Verify section title
        if section.Title != "" </span><span class="cov0" title="0">{
                if v.isSourceLanguage(section.Title) </span><span class="cov0" title="0">{
                        result.UntranslatedBlocks = append(result.UntranslatedBlocks, UntranslatedBlock{
                                Location:    location + " - Title",
                                OriginalText: section.Title,
                                Language:     v.sourceLanguage.Code,
                                Length:       len(section.Title),
                        })
                        result.Errors = append(result.Errors, fmt.Sprintf("%s title not translated", location))
                }</span>
        }

        // Verify section content
        <span class="cov0" title="0">if section.Content != "" </span><span class="cov0" title="0">{
                // Check if content is translated
                if v.isSourceLanguage(section.Content) </span><span class="cov0" title="0">{
                        result.UntranslatedBlocks = append(result.UntranslatedBlocks, UntranslatedBlock{
                                Location:    location + " - Content",
                                OriginalText: truncate(section.Content, 500),
                                Language:     v.sourceLanguage.Code,
                                Length:       len(section.Content),
                        })
                        result.Errors = append(result.Errors, fmt.Sprintf("%s content not translated", location))
                }</span>

                // Check for HTML artifacts
                <span class="cov0" title="0">htmlArtifacts := v.detectHTMLArtifacts(section.Content)
                for _, artifact := range htmlArtifacts </span><span class="cov0" title="0">{
                        artifact.Location = location
                        result.HTMLArtifacts = append(result.HTMLArtifacts, artifact)
                        result.Warnings = append(result.Warnings, fmt.Sprintf("HTML artifact in %s: %s", location, artifact.Content))
                }</span>

                // Verify paragraphs
                <span class="cov0" title="0">paragraphs := v.splitIntoParagraphs(section.Content)
                for pi, para := range paragraphs </span><span class="cov0" title="0">{
                        if v.isSourceLanguage(para) </span><span class="cov0" title="0">{
                                paraLoc := fmt.Sprintf("%s, Paragraph %d", location, pi+1)
                                result.UntranslatedBlocks = append(result.UntranslatedBlocks, UntranslatedBlock{
                                        Location:    paraLoc,
                                        OriginalText: truncate(para, 200),
                                        Language:     v.sourceLanguage.Code,
                                        Length:       len(para),
                                })
                        }</span>
                }
        }

        // Verify subsections recursively
        <span class="cov0" title="0">for i := range section.Subsections </span><span class="cov0" title="0">{
                subLoc := fmt.Sprintf("%s, Subsection %d", location, i+1)
                if err := v.verifySection(&amp;section.Subsections[i], subLoc, result); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// isSourceLanguage detects if text is in source language (not translated)
func (v *Verifier) isSourceLanguage(text string) bool <span class="cov0" title="0">{
        if text == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        // Clean text
        <span class="cov0" title="0">cleanText := strings.TrimSpace(text)

        // For Cyrillic-to-Cyrillic (e.g., Russian to Serbian), check specific characters
        // This check doesn't need minimum length as finding even one Russian-specific char is conclusive
        if v.sourceLanguage.Code == "ru" &amp;&amp; v.targetLanguage.Code == "sr" </span><span class="cov0" title="0">{
                // Russian-specific letters that don't exist in Serbian
                russianOnlyChars := []rune{'—ã', '—ç', '–´', '–≠'}
                for _, char := range cleanText </span><span class="cov0" title="0">{
                        for _, rusChar := range russianOnlyChars </span><span class="cov0" title="0">{
                                if char == rusChar </span><span class="cov0" title="0">{
                                        return true // Definitely Russian
                                }</span>
                        }
                }
        }

        // Check script - if source is Cyrillic and target is Latin (or vice versa)
        <span class="cov0" title="0">hasCyrillic := false
        hasLatin := false
        charCount := 0

        for _, r := range cleanText </span><span class="cov0" title="0">{
                if unicode.IsLetter(r) </span><span class="cov0" title="0">{
                        charCount++
                        if unicode.Is(unicode.Cyrillic, r) </span><span class="cov0" title="0">{
                                hasCyrillic = true
                        }</span> else<span class="cov0" title="0"> if unicode.Is(unicode.Latin, r) </span><span class="cov0" title="0">{
                                hasLatin = true
                        }</span>
                }
        }

        <span class="cov0" title="0">if charCount &lt; 10 </span><span class="cov0" title="0">{
                return false // Too few letters
        }</span>

        // If we expect Cyrillic but got Latin, or vice versa
        <span class="cov0" title="0">targetCyrillic := v.targetLanguage.Code == "sr" || v.targetLanguage.Code == "ru" ||
                           v.targetLanguage.Code == "bg" || v.targetLanguage.Code == "uk"
        sourceCyrillic := v.sourceLanguage.Code == "ru" || v.sourceLanguage.Code == "sr" ||
                           v.sourceLanguage.Code == "bg" || v.sourceLanguage.Code == "uk"

        if sourceCyrillic &amp;&amp; !targetCyrillic </span><span class="cov0" title="0">{
                // Source is Cyrillic, target is not - if we have Cyrillic, not translated
                return hasCyrillic
        }</span>

        <span class="cov0" title="0">if !sourceCyrillic &amp;&amp; targetCyrillic </span><span class="cov0" title="0">{
                // Source is Latin, target is Cyrillic - if we have Latin, not translated
                return hasLatin
        }</span>

        // Default: assume if mostly Cyrillic and source is Cyrillic, might be untranslated
        // This is a heuristic and may need refinement
        <span class="cov0" title="0">return false</span>
}

// detectHTMLArtifacts finds HTML/XML tags in content
func (v *Verifier) detectHTMLArtifacts(content string) []HTMLArtifact <span class="cov0" title="0">{
        artifacts := make([]HTMLArtifact, 0)

        // Regex patterns for HTML detection
        tagPattern := regexp.MustCompile(`&lt;[^&gt;]+&gt;`)
        entityPattern := regexp.MustCompile(`&amp;[a-zA-Z]+;|&amp;#[0-9]+;`)

        // Find HTML tags
        tags := tagPattern.FindAllString(content, -1)
        for _, tag := range tags </span><span class="cov0" title="0">{
                // Skip common allowed tags if any
                if !strings.Contains(tag, "&lt;!") &amp;&amp; !strings.Contains(tag, "&lt;?") </span><span class="cov0" title="0">{
                        artifacts = append(artifacts, HTMLArtifact{
                                Content: tag,
                                Type:    "tag",
                        })
                }</span>
        }

        // Find HTML entities
        <span class="cov0" title="0">entities := entityPattern.FindAllString(content, -1)
        for _, entity := range entities </span><span class="cov0" title="0">{
                artifacts = append(artifacts, HTMLArtifact{
                        Content: entity,
                        Type:    "entity",
                })
        }</span>

        <span class="cov0" title="0">return artifacts</span>
}

// splitIntoParagraphs splits content into paragraphs
func (v *Verifier) splitIntoParagraphs(content string) []string <span class="cov0" title="0">{
        // Split by double newlines or paragraph breaks
        paragraphs := regexp.MustCompile(`\n\n+`).Split(content, -1)
        result := make([]string, 0, len(paragraphs))

        for _, para := range paragraphs </span><span class="cov0" title="0">{
                cleaned := strings.TrimSpace(para)
                if cleaned != "" </span><span class="cov0" title="0">{
                        result = append(result, cleaned)
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

// calculateQualityScore computes overall translation quality
func (v *Verifier) calculateQualityScore(result *VerificationResult, book *ebook.Book) float64 <span class="cov0" title="0">{
        // Count total translatable items
        totalItems := 0
        totalChars := 0

        // Count book elements
        if book.Metadata.Title != "" </span><span class="cov0" title="0">{
                totalItems++
                totalChars += len(book.Metadata.Title)
        }</span>
        <span class="cov0" title="0">if book.Metadata.Description != "" </span><span class="cov0" title="0">{
                totalItems++
                totalChars += len(book.Metadata.Description)
        }</span>

        <span class="cov0" title="0">for _, chapter := range book.Chapters </span><span class="cov0" title="0">{
                if chapter.Title != "" </span><span class="cov0" title="0">{
                        totalItems++
                        totalChars += len(chapter.Title)
                }</span>
                <span class="cov0" title="0">totalItems += v.countSectionItems(&amp;chapter.Sections, &amp;totalChars)</span>
        }

        <span class="cov0" title="0">if totalItems == 0 || totalChars == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        // Calculate untranslated character count
        <span class="cov0" title="0">untranslatedChars := 0
        for _, block := range result.UntranslatedBlocks </span><span class="cov0" title="0">{
                untranslatedChars += block.Length
        }</span>

        // Calculate character-based quality score
        <span class="cov0" title="0">charScore := 1.0 - (float64(untranslatedChars) / float64(totalChars))

        // Penalize for HTML artifacts
        htmlPenalty := float64(len(result.HTMLArtifacts)) * 0.01
        if htmlPenalty &gt; 0.1 </span><span class="cov0" title="0">{
                htmlPenalty = 0.1 // Cap at 10% penalty
        }</span>

        // Penalize for errors more than warnings
        <span class="cov0" title="0">errorPenalty := float64(len(result.Errors)) * 0.05
        if errorPenalty &gt; 0.3 </span><span class="cov0" title="0">{
                errorPenalty = 0.3 // Cap at 30% penalty
        }</span>

        <span class="cov0" title="0">finalScore := charScore - htmlPenalty - errorPenalty
        if finalScore &lt; 0 </span><span class="cov0" title="0">{
                finalScore = 0
        }</span>

        <span class="cov0" title="0">return finalScore</span>
}

// countSectionItems recursively counts sections for quality calculation
func (v *Verifier) countSectionItems(sections *[]ebook.Section, totalChars *int) int <span class="cov0" title="0">{
        count := 0
        for i := range *sections </span><span class="cov0" title="0">{
                section := &amp;(*sections)[i]
                if section.Title != "" </span><span class="cov0" title="0">{
                        count++
                        *totalChars += len(section.Title)
                }</span>
                <span class="cov0" title="0">if section.Content != "" </span><span class="cov0" title="0">{
                        count++
                        *totalChars += len(section.Content)
                }</span>
                <span class="cov0" title="0">count += v.countSectionItems(&amp;section.Subsections, totalChars)</span>
        }
        <span class="cov0" title="0">return count</span>
}

// emitEvent emits a verification event
func (v *Verifier) emitEvent(event events.Event) <span class="cov0" title="0">{
        if v.eventBus != nil </span><span class="cov0" title="0">{
                v.eventBus.Publish(event)
        }</span>
}

// emitWarning emits a warning event
func (v *Verifier) emitWarning(message string) <span class="cov0" title="0">{
        if v.eventBus != nil </span><span class="cov0" title="0">{
                warningEvent := events.NewEvent("verification_warning", message, nil)
                warningEvent.SessionID = v.sessionID
                v.eventBus.Publish(warningEvent)
        }</span>
}

// truncate truncates text to specified length
func truncate(text string, maxLen int) string <span class="cov0" title="0">{
        if len(text) &lt;= maxLen </span><span class="cov0" title="0">{
                return text
        }</span>
        <span class="cov0" title="0">return text[:maxLen] + "..."</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package websocket

import (
        "digital.vasic.translator/pkg/events"
        "encoding/json"
        "sync"

        "github.com/gorilla/websocket"
)

// Client represents a WebSocket client
type Client struct {
        ID        string
        SessionID string
        Conn      *websocket.Conn
        Send      chan []byte
        Hub       *Hub
}

// Hub manages WebSocket connections
type Hub struct {
        clients    map[*Client]bool
        register   chan *Client
        unregister chan *Client
        mu         sync.RWMutex
        eventBus   *events.EventBus
}

// NewHub creates a new WebSocket hub
func NewHub(eventBus *events.EventBus) *Hub <span class="cov8" title="1">{
        hub := &amp;Hub{
                clients:    make(map[*Client]bool),
                register:   make(chan *Client),
                unregister: make(chan *Client),
                eventBus:   eventBus,
        }

        // Subscribe to all events
        eventBus.SubscribeAll(hub.handleEvent)

        return hub
}</span>

// Run starts the hub
func (h *Hub) Run() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case client := &lt;-h.register:<span class="cov8" title="1">
                        h.mu.Lock()
                        h.clients[client] = true
                        h.mu.Unlock()</span>

                case client := &lt;-h.unregister:<span class="cov8" title="1">
                        h.mu.Lock()
                        if _, ok := h.clients[client]; ok </span><span class="cov8" title="1">{
                                delete(h.clients, client)
                                close(client.Send)
                        }</span>
                        <span class="cov8" title="1">h.mu.Unlock()</span>
                }
        }
}

// Register registers a new client
func (h *Hub) Register(client *Client) <span class="cov8" title="1">{
        h.register &lt;- client
}</span>

// Unregister unregisters a client
func (h *Hub) Unregister(client *Client) <span class="cov8" title="1">{
        h.unregister &lt;- client
}</span>

// handleEvent handles events from the event bus
func (h *Hub) handleEvent(event events.Event) <span class="cov8" title="1">{
        // Convert event to JSON
        data, err := json.Marshal(event)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Send to all clients (or filter by session ID)
        <span class="cov8" title="1">h.mu.RLock()
        defer h.mu.RUnlock()

        for client := range h.clients </span><span class="cov8" title="1">{
                // Filter by session ID if specified
                if event.SessionID != "" &amp;&amp; client.SessionID != "" &amp;&amp; client.SessionID != event.SessionID </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">select </span>{
                case client.Send &lt;- data:<span class="cov8" title="1"></span>
                default:<span class="cov0" title="0"></span>
                        // Client's send channel is full, skip
                }
        }
}

// Broadcast sends a message to all clients
func (h *Hub) Broadcast(message []byte) <span class="cov8" title="1">{
        h.mu.RLock()
        defer h.mu.RUnlock()

        for client := range h.clients </span><span class="cov8" title="1">{
                select </span>{
                case client.Send &lt;- message:<span class="cov8" title="1"></span>
                default:<span class="cov8" title="1"></span>
                        // Client's send channel is full, skip
                }
        }
}

// GetClientCount returns the number of connected clients
func (h *Hub) GetClientCount() int <span class="cov8" title="1">{
        h.mu.RLock()
        defer h.mu.RUnlock()
        return len(h.clients)
}</span>

// ReadPump handles reading messages from the client
func (c *Client) ReadPump() <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                c.Hub.Unregister(c)
                c.Conn.Close()
        }</span>()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                _, _, err := c.Conn.ReadMessage()
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                // We don't expect messages from clients in this implementation
                // But we need to read to detect disconnections
        }
}

// WritePump handles writing messages to the client
func (c *Client) WritePump() <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                c.Conn.Close()
        }</span>()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                message, ok := &lt;-c.Send
                if !ok </span><span class="cov0" title="0">{
                        // Hub closed the channel
                        _ = c.Conn.WriteMessage(websocket.CloseMessage, []byte{})
                        return
                }</span>

                <span class="cov0" title="0">w, err := c.Conn.NextWriter(websocket.TextMessage)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">if _, err := w.Write(message); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                // Add queued messages to current websocket message
                <span class="cov0" title="0">n := len(c.Send)
                for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                        if _, err := w.Write([]byte{'\n'}); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">if _, err := w.Write(&lt;-c.Send); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }

                <span class="cov0" title="0">if err := w.Close(); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package main

import (
        "digital.vasic.translator/pkg/markdown"
        "fmt"
        "os"
        "strings"
)

func main() <span class="cov0" title="0">{
        fmt.Println("üß™ End-to-End Markdown Translation Pipeline Test")
        fmt.Println("=" + strings.Repeat("=", 60))

        // Test files
        inputEPUB := "Books/Stepanova_T._Detektivtriller1._Son_Nad_Bezdnoyi.epub"
        sourceMD := "/tmp/markdown_e2e_source.md"
        translatedMD := "/tmp/markdown_e2e_translated.md"
        outputEPUB := "/tmp/markdown_e2e_output.epub"

        // Clean up from previous runs
        os.Remove(sourceMD)
        os.Remove(translatedMD)
        os.Remove(outputEPUB)

        // Step 1: EPUB ‚Üí Markdown
        fmt.Println("üìñ Step 1/4: Converting EPUB to Markdown...")
        converter := markdown.NewEPUBToMarkdownConverter(false, "")
        if err := converter.ConvertEPUBToMarkdown(inputEPUB, sourceMD); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("‚ùå FAILED: %v\n", err)
                os.Exit(1)
        }</span>

        // Verify source markdown
        <span class="cov0" title="0">sourceContent, err := os.ReadFile(sourceMD)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("‚ùå FAILED to read source markdown: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">sourceLines := strings.Split(string(sourceContent), "\n")
        fmt.Printf("‚úÖ Created source markdown: %s\n", sourceMD)
        fmt.Printf("   Size: %d bytes, %d lines\n", len(sourceContent), len(sourceLines))
        fmt.Printf("   Preview (first 15 lines):\n")
        for i := 0; i &lt; 15 &amp;&amp; i &lt; len(sourceLines); i++ </span><span class="cov0" title="0">{
                line := sourceLines[i]
                if len(line) &gt; 80 </span><span class="cov0" title="0">{
                        line = line[:77] + "..."
                }</span>
                <span class="cov0" title="0">fmt.Printf("      %s\n", line)</span>
        }
        <span class="cov0" title="0">fmt.Println()

        // Step 2: Translate Markdown
        fmt.Println("üåç Step 2/4: Translating markdown content...")

        // Mock translator - just prepends "SR: " to text
        mockTranslator := func(text string) (string, error) </span><span class="cov0" title="0">{
                if strings.TrimSpace(text) == "" </span><span class="cov0" title="0">{
                        return text, nil
                }</span>
                <span class="cov0" title="0">return "SR: " + text, nil</span>
        }

        <span class="cov0" title="0">mdTranslator := markdown.NewMarkdownTranslator(mockTranslator)
        if err := mdTranslator.TranslateMarkdownFile(sourceMD, translatedMD); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("‚ùå FAILED: %v\n", err)
                os.Exit(1)
        }</span>

        // Verify translated markdown
        <span class="cov0" title="0">translatedContent, err := os.ReadFile(translatedMD)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("‚ùå FAILED to read translated markdown: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">translatedLines := strings.Split(string(translatedContent), "\n")
        fmt.Printf("‚úÖ Created translated markdown: %s\n", translatedMD)
        fmt.Printf("   Size: %d bytes, %d lines\n", len(translatedContent), len(translatedLines))
        fmt.Printf("   Preview (first 15 lines):\n")
        for i := 0; i &lt; 15 &amp;&amp; i &lt; len(translatedLines); i++ </span><span class="cov0" title="0">{
                line := translatedLines[i]
                if len(line) &gt; 80 </span><span class="cov0" title="0">{
                        line = line[:77] + "..."
                }</span>
                <span class="cov0" title="0">fmt.Printf("      %s\n", line)</span>
        }
        <span class="cov0" title="0">fmt.Println()

        // Step 3: Markdown ‚Üí EPUB
        fmt.Println("üìö Step 3/4: Converting translated markdown to EPUB...")
        epubConverter := markdown.NewMarkdownToEPUBConverter()
        if err := epubConverter.ConvertMarkdownToEPUB(translatedMD, outputEPUB); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("‚ùå FAILED: %v\n", err)
                os.Exit(1)
        }</span>

        // Verify output EPUB
        <span class="cov0" title="0">epubInfo, err := os.Stat(outputEPUB)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("‚ùå FAILED: Output EPUB not created\n")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Printf("‚úÖ Created output EPUB: %s\n", outputEPUB)
        fmt.Printf("   Size: %d bytes (%.2f KB)\n", epubInfo.Size(), float64(epubInfo.Size())/1024.0)
        fmt.Println()

        // Step 4: Verify EPUB structure
        fmt.Println("üîç Step 4/4: Verifying EPUB structure...")

        // Basic EPUB validation - check if it's a valid ZIP with required files
        // (Full validation would require unzipping and checking structure)
        if epubInfo.Size() &lt; 100 </span><span class="cov0" title="0">{
                fmt.Printf("‚ùå FAILED: EPUB file is too small (%d bytes)\n", epubInfo.Size())
                os.Exit(1)
        }</span>

        // Check if file starts with PK (ZIP signature)
        <span class="cov0" title="0">f, err := os.Open(outputEPUB)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("‚ùå FAILED: Cannot open EPUB: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer f.Close()

        header := make([]byte, 2)
        if _, err := f.Read(header); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("‚ùå FAILED: Cannot read EPUB header: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if header[0] != 'P' || header[1] != 'K' </span><span class="cov0" title="0">{
                fmt.Printf("‚ùå FAILED: EPUB is not a valid ZIP file (header: %v)\n", header)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Println("‚úÖ EPUB structure valid (ZIP format confirmed)")
        fmt.Println()

        // Summary
        fmt.Println("=" + strings.Repeat("=", 60))
        fmt.Println("‚úÖ END-TO-END TEST PASSED!")
        fmt.Println()
        fmt.Println("Pipeline verified:")
        fmt.Println("  1. EPUB ‚Üí Markdown: Extracted structure and formatting")
        fmt.Println("  2. Translation: Applied to markdown while preserving format")
        fmt.Println("  3. Markdown ‚Üí EPUB: Generated valid EPUB file")
        fmt.Println()
        fmt.Println("Generated files:")
        fmt.Printf("  - Source markdown:     %s\n", sourceMD)
        fmt.Printf("  - Translated markdown: %s\n", translatedMD)
        fmt.Printf("  - Output EPUB:         %s\n", outputEPUB)
        fmt.Println()
        fmt.Println("To inspect the markdown files:")
        fmt.Printf("  head -50 %s\n", sourceMD)
        fmt.Printf("  head -50 %s\n", translatedMD)</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package security

import (
        "context"
        "strings"

        "digital.vasic.translator/pkg/events"
        "digital.vasic.translator/pkg/translator"
)

// MockTranslator implements the translator.Translator interface for security testing
type MockTranslator struct {
        stats translator.TranslationStats
        name  string
}

func NewMockTranslator() *MockTranslator <span class="cov0" title="0">{
        return &amp;MockTranslator{
                stats: translator.TranslationStats{},
                name:  "mock",
        }
}</span>

func (m *MockTranslator) Translate(ctx context.Context, text string, context string) (string, error) <span class="cov0" title="0">{
        // For security testing, return a simple translation that doesn't contain malicious content
        m.stats.Total++
        m.stats.Translated++

        // Sanitize input for security testing
        sanitized := text

        // Remove null bytes
        sanitized = strings.ReplaceAll(sanitized, "\x00", "")

        // Basic XSS sanitization for testing
        sanitized = strings.ReplaceAll(sanitized, "&lt;script&gt;", "[script]")
        sanitized = strings.ReplaceAll(sanitized, "&lt;/script&gt;", "[/script]")
        sanitized = strings.ReplaceAll(sanitized, "javascript:", "[javascript:]")
        sanitized = strings.ReplaceAll(sanitized, "onerror=", "[onerror=]")
        sanitized = strings.ReplaceAll(sanitized, "onload=", "[onload=]")
        sanitized = strings.ToLower(sanitized)
        // Check for remaining dangerous patterns
        if strings.Contains(sanitized, "&lt;script") ||
                strings.Contains(sanitized, "javascript:") ||
                strings.Contains(sanitized, "onerror") ||
                strings.Contains(sanitized, "onload") </span><span class="cov0" title="0">{
                sanitized = "[sanitized]"
        }</span>

        <span class="cov0" title="0">return "[translated: " + sanitized + "]", nil</span>
}

func (m *MockTranslator) TranslateWithProgress(ctx context.Context, text string, context string, eventBus *events.EventBus, sessionID string) (string, error) <span class="cov0" title="0">{
        return m.Translate(ctx, text, context)
}</span>

func (m *MockTranslator) GetStats() translator.TranslationStats <span class="cov0" title="0">{
        return m.stats
}</span>

func (m *MockTranslator) GetName() string <span class="cov0" title="0">{
        return m.name
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
